{"version":3,"file":"js/chunk-vendors-1656f0b4.55d2ebe6.js","mappings":"wnBAMA,IAAIA,EACJ,MAAMC,EACFC,YAAYC,GAAW,GACnBC,KAAKD,SAAWA,EAIhBC,KAAKC,SAAU,EAIfD,KAAKE,QAAU,GAIfF,KAAKG,SAAW,GAChBH,KAAKI,OAASR,GACTG,GAAYH,IACbI,KAAKK,OACAT,EAAkBU,SAAWV,EAAkBU,OAAS,KAAKC,KAAKP,MAAQ,EAEvF,CACIQ,aACA,OAAOR,KAAKC,OAChB,CACAQ,IAAIC,GACA,GAAIV,KAAKC,QAAS,CACd,MAAMU,EAAqBf,EAC3B,IAEI,OADAA,EAAoBI,KACbU,GACX,CAAC,QAEGd,EAAoBe,CACxB,CACJ,MACUC,CAGd,CAKAC,KACIjB,EAAoBI,IACxB,CAKAc,MACIlB,EAAoBI,KAAKI,MAC7B,CACAW,KAAKC,GACD,GAAIhB,KAAKC,QAAS,CACd,IAAIgB,EAAGC,EACP,IAAKD,EAAI,EAAGC,EAAIlB,KAAKE,QAAQiB,OAAQF,EAAIC,EAAGD,IACxCjB,KAAKE,QAAQe,GAAGF,OAEpB,IAAKE,EAAI,EAAGC,EAAIlB,KAAKG,SAASgB,OAAQF,EAAIC,EAAGD,IACzCjB,KAAKG,SAASc,KAElB,GAAIjB,KAAKM,OACL,IAAKW,EAAI,EAAGC,EAAIlB,KAAKM,OAAOa,OAAQF,EAAIC,EAAGD,IACvCjB,KAAKM,OAAOW,GAAGF,MAAK,GAI5B,IAAKf,KAAKD,UAAYC,KAAKI,SAAWY,EAAY,CAE9C,MAAMI,EAAOpB,KAAKI,OAAOE,OAAOe,MAC5BD,GAAQA,IAASpB,OACjBA,KAAKI,OAAOE,OAAON,KAAKK,OAASe,EACjCA,EAAKf,MAAQL,KAAKK,MAE1B,CACAL,KAAKI,YAASkB,EACdtB,KAAKC,SAAU,CACnB,CACJ,EAKJ,SAASsB,EAAkBC,EAAQC,EAAQ7B,GACnC6B,GAASA,EAAMjB,QACfiB,EAAMvB,QAAQK,KAAKiB,EAE3B,CACA,SAASE,IACL,OAAO9B,CACX,CAWA,MAAM+B,EAAazB,IACf,MAAM0B,EAAM,IAAIC,IAAI3B,GAGpB,OAFA0B,EAAIE,EAAI,EACRF,EAAIG,EAAI,EACDH,CAAG,EAERI,EAAcJ,IAASA,EAAIE,EAAIG,GAAc,EAC7CC,EAAcN,IAASA,EAAIG,EAAIE,GAAc,EAC7CE,EAAiBA,EAAGC,WACtB,GAAIA,EAAKjB,OACL,IAAK,IAAIF,EAAI,EAAGA,EAAImB,EAAKjB,OAAQF,IAC7BmB,EAAKnB,GAAGa,GAAKG,CAErB,EAEEI,EAAsBb,IACxB,MAAM,KAAEY,GAASZ,EACjB,GAAIY,EAAKjB,OAAQ,CACb,IAAImB,EAAM,EACV,IAAK,IAAIrB,EAAI,EAAGA,EAAImB,EAAKjB,OAAQF,IAAK,CAClC,MAAMW,EAAMQ,EAAKnB,GACbe,EAAWJ,KAASM,EAAWN,GAC/BA,EAAIW,OAAOf,GAGXY,EAAKE,KAASV,EAGlBA,EAAIE,IAAMG,EACVL,EAAIG,IAAME,CACd,CACAG,EAAKjB,OAASmB,CAClB,GAGEE,EAAY,IAAIC,QAEtB,IAAIC,EAAmB,EACnBT,EAAa,EAMjB,MAAMU,EAAgB,GACtB,IAAIC,EACJ,MAAMC,EAAcC,OAA6D,IAC3EC,EAAsBD,OAAqE,IACjG,MAAME,EACFlD,YAAYY,EAAIuC,EAAY,KAAMxB,GAC9BzB,KAAKU,GAAKA,EACVV,KAAKiD,UAAYA,EACjBjD,KAAKQ,QAAS,EACdR,KAAKoC,KAAO,GACZpC,KAAKI,YAASkB,EACdC,EAAkBvB,KAAMyB,EAC5B,CACAhB,MACI,IAAKT,KAAKQ,OACN,OAAOR,KAAKU,KAEhB,IAAIN,EAASwC,EACTM,EAAkBC,EACtB,MAAO/C,EAAQ,CACX,GAAIA,IAAWJ,KACX,OAEJI,EAASA,EAAOA,MACpB,CACA,IAWI,OAVAJ,KAAKI,OAASwC,EACdA,EAAe5C,KACfmD,GAAc,EACdlB,EAAa,KAAOS,EAChBA,GAAoBC,EACpBR,EAAenC,MAGfoD,EAAcpD,MAEXA,KAAKU,IAChB,CAAC,QAEOgC,GAAoBC,GACpBN,EAAmBrC,MAEvBiC,EAAa,KAAOS,EACpBE,EAAe5C,KAAKI,OACpB+C,EAAcD,EACdlD,KAAKI,YAASkB,EACVtB,KAAKqD,WACLrD,KAAKe,MAEb,CACJ,CACAA,OAEQ6B,IAAiB5C,KACjBA,KAAKqD,WAAY,EAEZrD,KAAKQ,SACV4C,EAAcpD,MACVA,KAAKsD,QACLtD,KAAKsD,SAETtD,KAAKQ,QAAS,EAEtB,EAEJ,SAAS4C,EAAc5B,GACnB,MAAM,KAAEY,GAASZ,EACjB,GAAIY,EAAKjB,OAAQ,CACb,IAAK,IAAIF,EAAI,EAAGA,EAAImB,EAAKjB,OAAQF,IAC7BmB,EAAKnB,GAAGsB,OAAOf,GAEnBY,EAAKjB,OAAS,CAClB,CACJ,CAqBA,IAAIgC,GAAc,EAClB,MAAMI,EAAa,GACnB,SAASC,IACLD,EAAWhD,KAAK4C,GAChBA,GAAc,CAClB,CAKA,SAASM,IACL,MAAMrC,EAAOmC,EAAWlC,MACxB8B,OAAuB7B,IAATF,GAA4BA,CAC9C,CACA,SAASsC,EAAMC,EAAQC,EAAMC,GACzB,GAAIV,GAAeP,EAAc,CAC7B,IAAIkB,EAAUtB,EAAUuB,IAAIJ,GACvBG,GACDtB,EAAUwB,IAAIL,EAASG,EAAU,IAAIG,KAEzC,IAAIrC,EAAMkC,EAAQC,IAAIF,GACjBjC,GACDkC,EAAQE,IAAIH,EAAMjC,EAAMD,KAE5B,MAAMuC,OAEA5C,EACN6C,EAAavC,EAAKsC,EACtB,CACJ,CACA,SAASC,EAAavC,EAAKwC,GACvB,IAAIjB,GAAc,EACdT,GAAoBC,EACfT,EAAWN,KACZA,EAAIG,GAAKE,EACTkB,GAAenB,EAAWJ,IAK9BuB,GAAevB,EAAIyC,IAAIzB,GAEvBO,IACAvB,EAAI0C,IAAI1B,GACRA,EAAaR,KAAK7B,KAAKqB,GAK/B,CACA,SAAS2C,EAAQZ,EAAQC,EAAMC,EAAKW,EAAUC,EAAUC,GACpD,MAAMZ,EAAUtB,EAAUuB,IAAIJ,GAC9B,IAAKG,EAED,OAEJ,IAAI1B,EAAO,GACX,GAAa,UAATwB,EAGAxB,EAAO,IAAI0B,EAAQa,eAElB,GAAY,WAARd,IAAoBe,EAAAA,EAAAA,IAAQjB,GAAS,CAC1C,MAAMkB,EAAYC,OAAON,GACzBV,EAAQiB,SAAQ,CAACnD,EAAKiC,MACN,WAARA,GAAoBA,GAAOgB,IAC3BzC,EAAK7B,KAAKqB,EACd,GAER,MAOI,YAJY,IAARiC,GACAzB,EAAK7B,KAAKuD,EAAQC,IAAIF,IAGlBD,GACJ,IAAK,OACIgB,EAAAA,EAAAA,IAAQjB,IAMJqB,EAAAA,EAAAA,IAAanB,IAElBzB,EAAK7B,KAAKuD,EAAQC,IAAI,YAPtB3B,EAAK7B,KAAKuD,EAAQC,IAAIlB,KAClBoC,EAAAA,EAAAA,IAAMtB,IACNvB,EAAK7B,KAAKuD,EAAQC,IAAIhB,KAO9B,MACJ,IAAK,UACI6B,EAAAA,EAAAA,IAAQjB,KACTvB,EAAK7B,KAAKuD,EAAQC,IAAIlB,KAClBoC,EAAAA,EAAAA,IAAMtB,IACNvB,EAAK7B,KAAKuD,EAAQC,IAAIhB,KAG9B,MACJ,IAAK,OACGkC,EAAAA,EAAAA,IAAMtB,IACNvB,EAAK7B,KAAKuD,EAAQC,IAAIlB,IAE1B,MAMZ,GAAoB,IAAhBT,EAAKjB,OACDiB,EAAK,IAKD8C,EAAe9C,EAAK,QAI3B,CACD,MAAMlC,EAAU,GAChB,IAAK,MAAM0B,KAAOQ,EACVR,GACA1B,EAAQK,QAAQqB,GAOpBsD,EAAevD,EAAUzB,GAEjC,CACJ,CACA,SAASgF,EAAetD,EAAKwC,GAEzB,MAAMlE,GAAU0E,EAAAA,EAAAA,IAAQhD,GAAOA,EAAM,IAAIA,GACzC,IAAK,MAAMJ,KAAUtB,EACbsB,EAAO2D,UACPC,EAAc5D,EAAQ4C,GAG9B,IAAK,MAAM5C,KAAUtB,EACZsB,EAAO2D,UACRC,EAAc5D,EAAQ4C,EAGlC,CACA,SAASgB,EAAc5D,EAAQ4C,IACvB5C,IAAWoB,GAAgBpB,EAAO6D,gBAI9B7D,EAAOyB,UACPzB,EAAOyB,YAGPzB,EAAOf,MAGnB,CAMA,MAAM6E,GAAmCC,EAAAA,EAAAA,IAAS,+BAC5CC,EAAiB,IAAI3D,IAE3B4D,OAAOC,oBAAoB5C,QAItB6C,QAAO9B,GAAe,cAARA,GAA+B,WAARA,IACrC+B,KAAI/B,GAAOf,OAAOe,KAClB8B,OAAOE,EAAAA,KACNC,EAAsBC,IACtBC,EAA2BD,GAAa,GAAO,GAC/CE,EAA4BF,GAAa,GAEzCG,EAAsCC,IAC5C,SAASA,IACL,MAAMC,EAAmB,CAAC,EA0B1B,MAzBA,CAAC,WAAY,UAAW,eAAerB,SAAQlB,IAC3CuC,EAAiBvC,GAAO,YAAawC,GACjC,MAAMC,EAAMC,GAAMvG,MAClB,IAAK,IAAIiB,EAAI,EAAGC,EAAIlB,KAAKmB,OAAQF,EAAIC,EAAGD,IACpCyC,EAAM4C,EAAK,MAA8BrF,EAAI,IAGjD,MAAMuF,EAAMF,EAAIzC,MAAQwC,GACxB,OAAa,IAATG,IAAsB,IAARA,EAEPF,EAAIzC,MAAQwC,EAAKT,IAAIW,KAGrBC,CAEf,CAAC,IAEL,CAAC,OAAQ,MAAO,QAAS,UAAW,UAAUzB,SAAQlB,IAClDuC,EAAiBvC,GAAO,YAAawC,GACjC7C,IACA,MAAMgD,EAAMD,GAAMvG,MAAM6D,GAAK4C,MAAMzG,KAAMqG,GAEzC,OADA5C,IACO+C,CACX,CAAC,IAEEJ,CACX,CACA,SAASM,EAAe7C,GACpB,MAAM8C,EAAMJ,GAAMvG,MAElB,OADA0D,EAAMiD,EAAK,MAA8B9C,GAClC8C,EAAID,eAAe7C,EAC9B,CACA,SAASkC,EAAaa,GAAa,EAAOC,GAAU,GAChD,OAAO,SAAalD,EAAQE,EAAKiD,GAC7B,GAAY,mBAARjD,EACA,OAAQ+C,EAEP,GAAY,mBAAR/C,EACL,OAAO+C,EAEN,GAAY,kBAAR/C,EACL,OAAOgD,EAEN,GAAY,YAARhD,GACLiD,KACKF,EACKC,EACIE,GACAC,GACJH,EACII,GACAC,IAAanD,IAAIJ,GAC/B,OAAOA,EAEX,MAAMwD,GAAgBvC,EAAAA,EAAAA,IAAQjB,GAC9B,IAAKiD,EAAY,CACb,GAAIO,IAAiBC,EAAAA,EAAAA,IAAOlB,EAAuBrC,GAC/C,OAAOwD,QAAQtD,IAAImC,EAAuBrC,EAAKiD,GAEnD,GAAY,mBAARjD,EACA,OAAO6C,CAEf,CACA,MAAMF,EAAMa,QAAQtD,IAAIJ,EAAQE,EAAKiD,GACrC,QAAIjB,EAAAA,EAAAA,IAAShC,GAAO2B,EAAenB,IAAIR,GAAOyB,EAAmBzB,IACtD2C,GAENI,GACDlD,EAAMC,EAAQ,MAA8BE,GAE5CgD,EACOL,EAEPc,GAAMd,GAECW,IAAiBnC,EAAAA,EAAAA,IAAanB,GAAO2C,EAAMA,EAAIe,OAEtDC,EAAAA,EAAAA,IAAShB,GAIFI,EAAaa,GAASjB,GAAOkB,GAASlB,GAE1CA,EACX,CACJ,CACA,MAAMmB,EAAsBC,IACtBC,EAA2BD,GAAa,GAC9C,SAASA,EAAaf,GAAU,GAC5B,OAAO,SAAalD,EAAQE,EAAK0D,EAAOT,GACpC,IAAIrC,EAAWd,EAAOE,GACtB,GAAI+C,GAAWnC,IAAa6C,GAAM7C,KAAc6C,GAAMC,GAClD,OAAO,EAEX,IAAKV,IACIiB,GAAUP,IAAWX,GAAWW,KACjC9C,EAAW8B,GAAM9B,GACjB8C,EAAQhB,GAAMgB,MAEb3C,EAAAA,EAAAA,IAAQjB,IAAW2D,GAAM7C,KAAc6C,GAAMC,IAE9C,OADA9C,EAAS8C,MAAQA,GACV,EAGf,MAAMQ,GAASnD,EAAAA,EAAAA,IAAQjB,KAAWqB,EAAAA,EAAAA,IAAanB,GACzCiB,OAAOjB,GAAOF,EAAOxC,QACrBiG,EAAAA,EAAAA,IAAOzD,EAAQE,GACfmE,EAASX,QAAQrD,IAAIL,EAAQE,EAAK0D,EAAOT,GAU/C,OARInD,IAAW4C,GAAMO,KACZiB,GAGIE,EAAAA,EAAAA,IAAWV,EAAO9C,IACvBF,EAAQZ,EAAQ,MAAgCE,EAAK0D,EAAO9C,GAH5DF,EAAQZ,EAAQ,MAAgCE,EAAK0D,IAMtDS,CACX,CACJ,CACA,SAASE,EAAevE,EAAQE,GAC5B,MAAMkE,GAASX,EAAAA,EAAAA,IAAOzD,EAAQE,GACxBY,EAAWd,EAAOE,GAClBmE,EAASX,QAAQa,eAAevE,EAAQE,GAI9C,OAHImE,GAAUD,GACVxD,EAAQZ,EAAQ,SAAsCE,OAAKvC,EAAWmD,GAEnEuD,CACX,CACA,SAASG,EAAMxE,EAAQE,GACnB,MAAMmE,EAASX,QAAQhD,IAAIV,EAAQE,GAInC,OAHKgC,EAAAA,EAAAA,IAAShC,IAAS2B,EAAenB,IAAIR,IACtCH,EAAMC,EAAQ,MAA8BE,GAEzCmE,CACX,CACA,SAASI,EAAQzE,GAEb,OADAD,EAAMC,EAAQ,WAAsCiB,EAAAA,EAAAA,IAAQjB,GAAU,SAAWd,GAC1EwE,QAAQe,QAAQzE,EAC3B,CACA,MAAM0E,EAAkB,CACpBtE,IAAK+B,EACL9B,IAAK2D,EACLO,iBACA7D,IAAK8D,EACLC,WAEEE,EAAmB,CACrBvE,IAAKkC,EACLjC,IAAIL,EAAQE,GAIR,OAAO,CACX,EACAqE,eAAevE,EAAQE,GAInB,OAAO,CACX,GAEE0E,GAAwCC,EAAAA,EAAAA,IAAO,CAAC,EAAGH,EAAiB,CACtEtE,IAAKiC,EACLhC,IAAK6D,IASHY,EAAalB,GAAUA,EACvBmB,EAAYC,GAAMtB,QAAQuB,eAAeD,GAC/C,SAAS5E,EAAIJ,EAAQE,EAAK+C,GAAa,EAAOkB,GAAY,GAGtDnE,EAASA,EAAO,WAChB,MAAMkF,EAAYtC,GAAM5C,GAClBmF,EAASvC,GAAM1C,GAChB+C,IACG/C,IAAQiF,GACRpF,EAAMmF,EAAW,MAA8BhF,GAEnDH,EAAMmF,EAAW,MAA8BC,IAEnD,MAAM,IAAEzE,GAAQqE,EAASG,GACnBE,EAAOjB,EAAYW,EAAY7B,EAAaoC,GAAaC,GAC/D,OAAI5E,EAAI6E,KAAKL,EAAWhF,GACbkF,EAAKpF,EAAOI,IAAIF,IAElBQ,EAAI6E,KAAKL,EAAWC,GAClBC,EAAKpF,EAAOI,IAAI+E,SAElBnF,IAAWkF,GAGhBlF,EAAOI,IAAIF,GAEnB,CACA,SAASQ,EAAIR,EAAK+C,GAAa,GAC3B,MAAMjD,EAAS3D,KAAK,WACd6I,EAAYtC,GAAM5C,GAClBmF,EAASvC,GAAM1C,GAOrB,OANK+C,IACG/C,IAAQiF,GACRpF,EAAMmF,EAAW,MAA8BhF,GAEnDH,EAAMmF,EAAW,MAA8BC,IAE5CjF,IAAQiF,EACTnF,EAAOU,IAAIR,GACXF,EAAOU,IAAIR,IAAQF,EAAOU,IAAIyE,EACxC,CACA,SAASK,EAAKxF,EAAQiD,GAAa,GAG/B,OAFAjD,EAASA,EAAO,YACfiD,GAAclD,EAAM6C,GAAM5C,GAAS,UAAsCd,GACnEwE,QAAQtD,IAAIJ,EAAQ,OAAQA,EACvC,CACA,SAASW,GAAIiD,GACTA,EAAQhB,GAAMgB,GACd,MAAM5D,EAAS4C,GAAMvG,MACfoJ,EAAQV,EAAS/E,GACjBoE,EAASqB,EAAM/E,IAAI6E,KAAKvF,EAAQ4D,GAKtC,OAJKQ,IACDpE,EAAOW,IAAIiD,GACXhD,EAAQZ,EAAQ,MAAgC4D,EAAOA,IAEpDvH,IACX,CACA,SAASgE,GAAIH,EAAK0D,GACdA,EAAQhB,GAAMgB,GACd,MAAM5D,EAAS4C,GAAMvG,OACf,IAAEqE,EAAG,IAAEN,GAAQ2E,EAAS/E,GAC9B,IAAIoE,EAAS1D,EAAI6E,KAAKvF,EAAQE,GACzBkE,IACDlE,EAAM0C,GAAM1C,GACZkE,EAAS1D,EAAI6E,KAAKvF,EAAQE,IAK9B,MAAMY,EAAWV,EAAImF,KAAKvF,EAAQE,GAQlC,OAPAF,EAAOK,IAAIH,EAAK0D,GACXQ,GAGIE,EAAAA,EAAAA,IAAWV,EAAO9C,IACvBF,EAAQZ,EAAQ,MAAgCE,EAAK0D,EAAO9C,GAH5DF,EAAQZ,EAAQ,MAAgCE,EAAK0D,GAKlDvH,IACX,CACA,SAASqJ,GAAYxF,GACjB,MAAMF,EAAS4C,GAAMvG,OACf,IAAEqE,EAAG,IAAEN,GAAQ2E,EAAS/E,GAC9B,IAAIoE,EAAS1D,EAAI6E,KAAKvF,EAAQE,GACzBkE,IACDlE,EAAM0C,GAAM1C,GACZkE,EAAS1D,EAAI6E,KAAKvF,EAAQE,IAK9B,MAAMY,EAAWV,EAAMA,EAAImF,KAAKvF,EAAQE,QAAOvC,EAEzC0G,EAASrE,EAAOpB,OAAOsB,GAI7B,OAHIkE,GACAxD,EAAQZ,EAAQ,SAAsCE,OAAKvC,EAAWmD,GAEnEuD,CACX,CACA,SAASsB,KACL,MAAM3F,EAAS4C,GAAMvG,MACfuJ,EAA2B,IAAhB5F,EAAOwF,KAClBzE,OAIApD,EAEA0G,EAASrE,EAAO2F,QAItB,OAHIC,GACAhF,EAAQZ,EAAQ,aAAoCrC,OAAWA,EAAWoD,GAEvEsD,CACX,CACA,SAASwB,GAAc5C,EAAYkB,GAC/B,OAAO,SAAiB2B,EAAUC,GAC9B,MAAMC,EAAW3J,KACX2D,EAASgG,EAAS,WAClBd,EAAYtC,GAAM5C,GAClBoF,EAAOjB,EAAYW,EAAY7B,EAAaoC,GAAaC,GAE/D,OADCrC,GAAclD,EAAMmF,EAAW,UAAsChG,GAC/Dc,EAAOoB,SAAQ,CAACwC,EAAO1D,IAInB4F,EAASP,KAAKQ,EAASX,EAAKxB,GAAQwB,EAAKlF,GAAM8F,IAE9D,CACJ,CACA,SAASC,GAAqBC,EAAQjD,EAAYkB,GAC9C,OAAO,YAAazB,GAChB,MAAM1C,EAAS3D,KAAK,WACd6I,EAAYtC,GAAM5C,GAClBmG,GAAc7E,EAAAA,EAAAA,IAAM4D,GACpBkB,EAAoB,YAAXF,GAAyBA,IAAW/G,OAAOkH,UAAYF,EAChEG,EAAuB,SAAXJ,GAAqBC,EACjCI,EAAgBvG,EAAOkG,MAAWxD,GAClC0C,EAAOjB,EAAYW,EAAY7B,EAAaoC,GAAaC,GAK/D,OAJCrC,GACGlD,EAAMmF,EAAW,UAAsCoB,EAAYlH,EAAsBF,GAGtF,CAEHsH,OACI,MAAM,MAAE5C,EAAK,KAAE6C,GAASF,EAAcC,OACtC,OAAOC,EACD,CAAE7C,QAAO6C,QACT,CACE7C,MAAOwC,EAAS,CAAChB,EAAKxB,EAAM,IAAKwB,EAAKxB,EAAM,KAAOwB,EAAKxB,GACxD6C,OAEZ,EAEA,CAACtH,OAAOkH,YACJ,OAAOhK,IACX,EAER,CACJ,CACA,SAASqK,GAAqBzG,GAC1B,OAAO,YAAayC,GAKhB,MAAgB,WAATzC,GAAwD5D,IACnE,CACJ,CACA,SAASsK,KACL,MAAMC,EAA0B,CAC5BxG,IAAIF,GACA,OAAOE,EAAI/D,KAAM6D,EACrB,EACIsF,WACA,OAAOA,EAAKnJ,KAChB,EACAqE,MACAC,OACAN,OACAzB,OAAQ8G,GACRC,SACAvE,QAASyE,IAAc,GAAO,IAE5BgB,EAA0B,CAC5BzG,IAAIF,GACA,OAAOE,EAAI/D,KAAM6D,GAAK,GAAO,EACjC,EACIsF,WACA,OAAOA,EAAKnJ,KAChB,EACAqE,MACAC,OACAN,OACAzB,OAAQ8G,GACRC,SACAvE,QAASyE,IAAc,GAAO,IAE5BiB,EAA2B,CAC7B1G,IAAIF,GACA,OAAOE,EAAI/D,KAAM6D,GAAK,EAC1B,EACIsF,WACA,OAAOA,EAAKnJ,MAAM,EACtB,EACAqE,IAAIR,GACA,OAAOQ,EAAI6E,KAAKlJ,KAAM6D,GAAK,EAC/B,EACAS,IAAK+F,GAAqB,OAC1BrG,IAAKqG,GAAqB,OAC1B9H,OAAQ8H,GAAqB,UAC7Bf,MAAOe,GAAqB,SAC5BtF,QAASyE,IAAc,GAAM,IAE3BkB,EAAkC,CACpC3G,IAAIF,GACA,OAAOE,EAAI/D,KAAM6D,GAAK,GAAM,EAChC,EACIsF,WACA,OAAOA,EAAKnJ,MAAM,EACtB,EACAqE,IAAIR,GACA,OAAOQ,EAAI6E,KAAKlJ,KAAM6D,GAAK,EAC/B,EACAS,IAAK+F,GAAqB,OAC1BrG,IAAKqG,GAAqB,OAC1B9H,OAAQ8H,GAAqB,UAC7Bf,MAAOe,GAAqB,SAC5BtF,QAASyE,IAAc,GAAM,IAE3BmB,EAAkB,CAAC,OAAQ,SAAU,UAAW7H,OAAOkH,UAO7D,OANAW,EAAgB5F,SAAQ8E,IACpBU,EAAwBV,GAAUD,GAAqBC,GAAQ,GAAO,GACtEY,EAAyBZ,GAAUD,GAAqBC,GAAQ,GAAM,GACtEW,EAAwBX,GAAUD,GAAqBC,GAAQ,GAAO,GACtEa,EAAgCb,GAAUD,GAAqBC,GAAQ,GAAM,EAAK,IAE/E,CACHU,EACAE,EACAD,EACAE,EAER,CACA,MAAOH,GAAyBE,GAA0BD,GAAyBE,IAAkDJ,KACrI,SAASM,GAA4BhE,EAAYC,GAC7C,MAAMT,EAAmBS,EACnBD,EACI8D,GACAF,GACJ5D,EACI6D,GACAF,GACV,MAAO,CAAC5G,EAAQE,EAAKiD,IACL,mBAARjD,GACQ+C,EAEK,mBAAR/C,EACE+C,EAEM,YAAR/C,EACEF,EAEJ0D,QAAQtD,KAAIqD,EAAAA,EAAAA,IAAOhB,EAAkBvC,IAAQA,KAAOF,EACrDyC,EACAzC,EAAQE,EAAKiD,EAE3B,CACA,MAAM+D,GAA4B,CAC9B9G,IAAmB6G,IAA4B,GAAO,IAEpDE,GAA4B,CAC9B/G,IAAmB6G,IAA4B,GAAO,IAEpDG,GAA6B,CAC/BhH,IAAmB6G,IAA4B,GAAM,IAiBzD,MAAM1D,GAAc,IAAIzE,QAClBwE,GAAqB,IAAIxE,QACzBuE,GAAc,IAAIvE,QAClBsE,GAAqB,IAAItE,QAC/B,SAASuI,GAAcC,GACnB,OAAQA,GACJ,IAAK,SACL,IAAK,QACD,OAAO,EACX,IAAK,MACL,IAAK,MACL,IAAK,UACL,IAAK,UACD,OAAO,EACX,QACI,OAAO,EAEnB,CACA,SAASC,GAAc3D,GACnB,OAAOA,EAAM,cAAyC9B,OAAO0F,aAAa5D,GACpE,EACAyD,IAAcI,EAAAA,EAAAA,IAAU7D,GAClC,CACA,SAASG,GAAS/D,GAEd,OAAIiD,GAAWjD,GACJA,EAEJ0H,GAAqB1H,GAAQ,EAAO0E,EAAiBwC,GAA2B3D,GAC3F,CAMA,SAASoE,GAAgB3H,GACrB,OAAO0H,GAAqB1H,GAAQ,EAAO4E,EAAyBuC,GAA2B7D,GACnG,CAKA,SAASQ,GAAS9D,GACd,OAAO0H,GAAqB1H,GAAQ,EAAM2E,EAAkByC,GAA4B/D,GAC5F,CAUA,SAASqE,GAAqB1H,EAAQiD,EAAY2E,EAAcC,EAAoBC,GAChF,KAAKjE,EAAAA,EAAAA,IAAS7D,GAIV,OAAOA,EAIX,GAAIA,EAAO,cACLiD,IAAcjD,EAAO,mBACvB,OAAOA,EAGX,MAAM+H,EAAgBD,EAAS1H,IAAIJ,GACnC,GAAI+H,EACA,OAAOA,EAGX,MAAMC,EAAaT,GAAcvH,GACjC,GAAmB,IAAfgI,EACA,OAAOhI,EAEX,MAAMiI,EAAQ,IAAIC,MAAMlI,EAAuB,IAAfgI,EAA+CH,EAAqBD,GAEpG,OADAE,EAASzH,IAAIL,EAAQiI,GACdA,CACX,CACA,SAASE,GAAWvE,GAChB,OAAIX,GAAWW,GACJuE,GAAWvE,EAAM,eAElBA,IAASA,EAAM,kBAC7B,CACA,SAASX,GAAWW,GAChB,SAAUA,IAASA,EAAM,kBAC7B,CACA,SAASO,GAAUP,GACf,SAAUA,IAASA,EAAM,iBAC7B,CACA,SAASwE,GAAQxE,GACb,OAAOuE,GAAWvE,IAAUX,GAAWW,EAC3C,CACA,SAAShB,GAAMoD,GACX,MAAMqC,EAAMrC,GAAYA,EAAS,WACjC,OAAOqC,EAAMzF,GAAMyF,GAAOrC,CAC9B,CACA,SAASsC,GAAQ1E,GAEb,OADA2E,EAAAA,EAAAA,IAAI3E,EAAO,YAAqC,GACzCA,CACX,CACA,MAAM0B,GAAc1B,IAAUC,EAAAA,EAAAA,IAASD,GAASG,GAASH,GAASA,EAC5DyB,GAAczB,IAAUC,EAAAA,EAAAA,IAASD,GAASE,GAASF,GAASA,EAElE,SAAS4E,GAAcC,GACfjJ,GAAeP,IACfwJ,EAAM7F,GAAM6F,GASRjI,EAAaiI,EAAIxK,MAAQwK,EAAIxK,IAAMD,MAG/C,CACA,SAAS0K,GAAgBD,EAAKE,GAC1BF,EAAM7F,GAAM6F,GACZ,MAAMxK,EAAMwK,EAAIxK,IACZA,GAUIsD,EAAetD,EAG3B,CACA,SAAS0F,GAAMiF,GACX,SAAUA,IAAqB,IAAhBA,EAAEC,UACrB,CACA,SAASJ,GAAI7E,GACT,OAAOkF,GAAUlF,GAAO,EAC5B,CACA,SAASmF,GAAWnF,GAChB,OAAOkF,GAAUlF,GAAO,EAC5B,CACA,SAASkF,GAAUE,EAAU9F,GACzB,OAAIS,GAAMqF,GACCA,EAEJ,IAAIC,GAAQD,EAAU9F,EACjC,CACA,MAAM+F,GACF9M,YAAYyH,EAAOsF,GACf7M,KAAK6M,cAAgBA,EACrB7M,KAAK4B,SAAMN,EACXtB,KAAKwM,WAAY,EACjBxM,KAAK8M,UAAYD,EAAgBtF,EAAQhB,GAAMgB,GAC/CvH,KAAK+M,OAASF,EAAgBtF,EAAQ0B,GAAW1B,EACrD,CACIA,YAEA,OADA4E,GAAcnM,MACPA,KAAK+M,MAChB,CACIxF,UAAM+E,GACN,MAAMU,EAAiBhN,KAAK6M,eAAiB/E,GAAUwE,IAAW1F,GAAW0F,GAC7EA,EAASU,EAAiBV,EAAS/F,GAAM+F,IACrCrE,EAAAA,EAAAA,IAAWqE,EAAQtM,KAAK8M,aACxB9M,KAAK8M,UAAYR,EACjBtM,KAAK+M,OAASC,EAAiBV,EAASrD,GAAWqD,GACnDD,GAAgBrM,KAAMsM,GAE9B,EAKJ,SAASW,GAAMb,GACX,OAAO9E,GAAM8E,GAAOA,EAAI7E,MAAQ6E,CACpC,CACA,MAAMc,GAAwB,CAC1BnJ,IAAKA,CAACJ,EAAQE,EAAKiD,IAAamG,GAAM5F,QAAQtD,IAAIJ,EAAQE,EAAKiD,IAC/D9C,IAAKA,CAACL,EAAQE,EAAK0D,EAAOT,KACtB,MAAMrC,EAAWd,EAAOE,GACxB,OAAIyD,GAAM7C,KAAc6C,GAAMC,IAC1B9C,EAAS8C,MAAQA,GACV,GAGAF,QAAQrD,IAAIL,EAAQE,EAAK0D,EAAOT,EAC3C,GAGR,SAASqG,GAAUC,GACf,OAAOtB,GAAWsB,GACZA,EACA,IAAIvB,MAAMuB,EAAgBF,GACpC,CAsDA,IAAIG,GACJ,MAAMC,GACFxN,YAAYyN,EAAQC,EAAS5G,EAAY6G,GACrCzN,KAAKwN,QAAUA,EACfxN,KAAK4B,SAAMN,EACXtB,KAAKwM,WAAY,EACjBxM,KAAKqN,KAAQ,EACbrN,KAAK0N,QAAS,EACd1N,KAAKwB,OAAS,IAAIwB,EAAeuK,GAAQ,KAChCvN,KAAK0N,SACN1N,KAAK0N,QAAS,EACdrB,GAAgBrM,MACpB,IAEJA,KAAKwB,OAAO2D,SAAWnF,KACvBA,KAAKwB,OAAOhB,OAASR,KAAK2N,YAAcF,EACxCzN,KAAK,kBAAoD4G,CAC7D,CACIW,YAEA,MAAMqG,EAAOrH,GAAMvG,MAMnB,OALAmM,GAAcyB,IACVA,EAAKF,QAAWE,EAAKD,aACrBC,EAAKF,QAAS,EACdE,EAAKb,OAASa,EAAKpM,OAAOf,OAEvBmN,EAAKb,MAChB,CACIxF,UAAM/C,GACNxE,KAAKwN,QAAQhJ,EACjB,EAGJ,SAASW,GAAS0I,EAAiBC,EAAcL,GAAQ,GACrD,IAAIF,EACAQ,EACJ,MAAMC,GAAaC,EAAAA,EAAAA,IAAWJ,GAC1BG,GACAT,EAASM,EACTE,EAIMG,EAAAA,KAGNX,EAASM,EAAgB9J,IACzBgK,EAASF,EAAgB7J,KAE7B,MAAMmK,EAAO,IAAIb,GAAgBC,EAAQQ,EAAQC,IAAeD,EAAQN,GAKxE,OAAOU,CACX,CAvBAd,GAAO,gB,6OCtpCP,MAAMe,EAAQ,6BACRC,EAA2B,qBAAbC,SAA2BA,SAAW,KACpDC,EAAoBF,GAAqBA,EAAIG,cAAc,YAC3DC,EAAU,CACZC,OAAQA,CAACC,EAAOvO,EAAQwO,KACpBxO,EAAOyO,aAAaF,EAAOC,GAAU,KAAK,EAE9CE,OAAQH,IACJ,MAAMvO,EAASuO,EAAMI,WACjB3O,GACAA,EAAO4O,YAAYL,EACvB,EAEJH,cAAeA,CAACS,EAAKC,EAAOC,EAAIC,KAC5B,MAAMC,EAAKH,EACLb,EAAIiB,gBAAgBlB,EAAOa,GAC3BZ,EAAIG,cAAcS,EAAKE,EAAK,CAAEA,WAAO7N,GAI3C,MAHY,WAAR2N,GAAoBG,GAA2B,MAAlBA,EAAMG,UACnCF,EAAGG,aAAa,WAAYJ,EAAMG,UAE/BF,CAAE,EAEbI,WAAYC,GAAQrB,EAAIsB,eAAeD,GACvCE,cAAeF,GAAQrB,EAAIuB,cAAcF,GACzCG,QAASA,CAACC,EAAMJ,KACZI,EAAKC,UAAYL,CAAI,EAEzBM,eAAgBA,CAACX,EAAIK,KACjBL,EAAGY,YAAcP,CAAI,EAEzBX,WAAYe,GAAQA,EAAKf,WACzBmB,YAAaJ,GAAQA,EAAKI,YAC1BC,cAAeC,GAAY/B,EAAI8B,cAAcC,GAC7CC,WAAWhB,EAAIiB,GACXjB,EAAGG,aAAac,EAAI,GACxB,EAKAC,oBAAoBC,EAASpQ,EAAQwO,EAAQM,EAAOuB,EAAOC,GAEvD,MAAMC,EAAS/B,EAASA,EAAOgC,gBAAkBxQ,EAAOyQ,UAIxD,GAAIJ,IAAUA,IAAUC,GAAOD,EAAMP,cAEjC,MAAO,EAEH,GADA9P,EAAOyO,aAAa4B,EAAMK,WAAU,GAAOlC,GACvC6B,IAAUC,KAASD,EAAQA,EAAMP,aACjC,UAGP,CAED3B,EAAkBwC,UAAY7B,EAAS,QAAOsB,UAAkBA,EAChE,MAAMQ,EAAWzC,EAAkBiC,QACnC,GAAItB,EAAO,CAEP,MAAM+B,EAAUD,EAASE,WACzB,MAAOD,EAAQC,WACXF,EAASG,YAAYF,EAAQC,YAEjCF,EAAShC,YAAYiC,EACzB,CACA7Q,EAAOyO,aAAamC,EAAUpC,EAClC,CACA,MAAO,CAEH+B,EAASA,EAAOT,YAAc9P,EAAO8Q,WAErCtC,EAASA,EAAOgC,gBAAkBxQ,EAAOyQ,UAEjD,GAKJ,SAASO,EAAW/B,EAAI9H,EAAO2H,GAI3B,MAAMmC,EAAoBhC,EAAGiC,KACzBD,IACA9J,GAASA,EAAQ,CAACA,KAAU8J,GAAqB,IAAIA,IAAoBE,KAAK,MAErE,MAAThK,EACA8H,EAAGmC,gBAAgB,SAEdtC,EACLG,EAAGG,aAAa,QAASjI,GAGzB8H,EAAGoC,UAAYlK,CAEvB,CAEA,SAASmK,EAAWrC,EAAIsC,EAAMxH,GAC1B,MAAMyH,EAAQvC,EAAGuC,MACXC,GAAcC,EAAAA,EAAAA,IAAS3H,GAC7B,GAAIA,IAAS0H,EAAa,CACtB,GAAIF,KAASG,EAAAA,EAAAA,IAASH,GAClB,IAAK,MAAM9N,KAAO8N,EACG,MAAbxH,EAAKtG,IACLkO,EAASH,EAAO/N,EAAK,IAIjC,IAAK,MAAMA,KAAOsG,EACd4H,EAASH,EAAO/N,EAAKsG,EAAKtG,GAElC,KACK,CACD,MAAMmO,EAAiBJ,EAAMK,QACzBJ,EACIF,IAASxH,IACTyH,EAAMM,QAAU/H,GAGfwH,GACLtC,EAAGmC,gBAAgB,SAKnB,SAAUnC,IACVuC,EAAMK,QAAUD,EAExB,CACJ,CACA,MACMG,EAAc,iBACpB,SAASJ,EAASH,EAAOQ,EAAMC,GAC3B,IAAIzN,EAAAA,EAAAA,IAAQyN,GACRA,EAAItN,SAAQ4D,GAAKoJ,EAASH,EAAOQ,EAAMzJ,UAUvC,GAPW,MAAP0J,IACAA,EAAM,IAMND,EAAKE,WAAW,MAEhBV,EAAMW,YAAYH,EAAMC,OAEvB,CACD,MAAMG,EAAWC,EAAWb,EAAOQ,GAC/BD,EAAYO,KAAKL,GAEjBT,EAAMW,aAAYI,EAAAA,EAAAA,IAAUH,GAAWH,EAAIO,QAAQT,EAAa,IAAK,aAGrEP,EAAMY,GAAYH,CAE1B,CAER,CACA,MAAMQ,EAAW,CAAC,SAAU,MAAO,MAC7BC,EAAc,CAAC,EACrB,SAASL,EAAWb,EAAOmB,GACvB,MAAMC,EAASF,EAAYC,GAC3B,GAAIC,EACA,OAAOA,EAEX,IAAIZ,GAAOa,EAAAA,EAAAA,IAASF,GACpB,GAAa,WAATX,GAAqBA,KAAQR,EAC7B,OAAQkB,EAAYC,GAAWX,EAEnCA,GAAOc,EAAAA,EAAAA,IAAWd,GAClB,IAAK,IAAInR,EAAI,EAAGA,EAAI4R,EAAS1R,OAAQF,IAAK,CACtC,MAAMuR,EAAWK,EAAS5R,GAAKmR,EAC/B,GAAII,KAAYZ,EACZ,OAAQkB,EAAYC,GAAWP,CAEvC,CACA,OAAOO,CACX,CAEA,MAAMI,EAAU,+BAChB,SAASC,EAAU/D,EAAIxL,EAAK0D,EAAO2H,EAAOmE,GACtC,GAAInE,GAASrL,EAAIyO,WAAW,UACX,MAAT/K,EACA8H,EAAGiE,kBAAkBH,EAAStP,EAAI0P,MAAM,EAAG1P,EAAI1C,SAG/CkO,EAAGmE,eAAeL,EAAStP,EAAK0D,OAGnC,CAGD,MAAMkM,GAAYC,EAAAA,EAAAA,IAAqB7P,GAC1B,MAAT0D,GAAkBkM,KAAcE,EAAAA,EAAAA,IAAmBpM,GACnD8H,EAAGmC,gBAAgB3N,GAGnBwL,EAAGG,aAAa3L,EAAK4P,EAAY,GAAKlM,EAE9C,CACJ,CAIA,SAASqM,EAAavE,EAAIxL,EAAK0D,EAI/BsM,EAAcC,EAAiBC,EAAgBC,GAC3C,GAAY,cAARnQ,GAA+B,gBAARA,EAKvB,OAJIgQ,GACAG,EAAgBH,EAAcC,EAAiBC,QAEnD1E,EAAGxL,GAAgB,MAAT0D,EAAgB,GAAKA,GAGnC,GAAY,UAAR1D,GACe,aAAfwL,EAAG4E,UAEF5E,EAAG4E,QAAQC,SAAS,KAAM,CAG3B7E,EAAGtC,OAASxF,EACZ,MAAM/C,EAAoB,MAAT+C,EAAgB,GAAKA,EAWtC,OAVI8H,EAAG9H,QAAU/C,GAIE,WAAf6K,EAAG4E,UACH5E,EAAG9H,MAAQ/C,QAEF,MAAT+C,GACA8H,EAAGmC,gBAAgB3N,GAG3B,CACA,IAAIsQ,GAAa,EACjB,GAAc,KAAV5M,GAAyB,MAATA,EAAe,CAC/B,MAAM3D,SAAcyL,EAAGxL,GACV,YAATD,EAEA2D,GAAQoM,EAAAA,EAAAA,IAAmBpM,GAEb,MAATA,GAA0B,WAAT3D,GAEtB2D,EAAQ,GACR4M,GAAa,GAEC,WAATvQ,IAEL2D,EAAQ,EACR4M,GAAa,EAErB,CAIA,IACI9E,EAAGxL,GAAO0D,CACd,CACA,MAAO6M,GAEExT,CAIT,CACAuT,GAAc9E,EAAGmC,gBAAgB3N,EACrC,CAEA,SAASwQ,EAAiBhF,EAAIiF,EAAOC,EAASC,GAC1CnF,EAAGgF,iBAAiBC,EAAOC,EAASC,EACxC,CACA,SAASC,EAAoBpF,EAAIiF,EAAOC,EAASC,GAC7CnF,EAAGoF,oBAAoBH,EAAOC,EAASC,EAC3C,CACA,SAASE,EAAWrF,EAAI0D,EAAS4B,EAAWC,EAAWvB,EAAW,MAE9D,MAAMwB,EAAWxF,EAAGyF,OAASzF,EAAGyF,KAAO,CAAC,GAClCC,EAAkBF,EAAS9B,GACjC,GAAI6B,GAAaG,EAEbA,EAAgBxN,MAAQqN,MAEvB,CACD,MAAOxC,EAAMoC,GAAWQ,EAAUjC,GAClC,GAAI6B,EAAW,CAEX,MAAMK,EAAWJ,EAAS9B,GAAWmC,EAAcN,EAAWvB,GAC9DgB,EAAiBhF,EAAI+C,EAAM6C,EAAST,EACxC,MACSO,IAELN,EAAoBpF,EAAI+C,EAAM2C,EAAiBP,GAC/CK,EAAS9B,QAAWzR,EAE5B,CACJ,CACA,MAAM6T,EAAoB,4BAC1B,SAASH,EAAU5C,GACf,IAAIoC,EACJ,GAAIW,EAAkBzC,KAAKN,GAAO,CAE9B,IAAIgD,EADJZ,EAAU,CAAC,EAEX,MAAQY,EAAIhD,EAAKiD,MAAMF,GACnB/C,EAAOA,EAAKmB,MAAM,EAAGnB,EAAKjR,OAASiU,EAAE,GAAGjU,QACxCqT,EAAQY,EAAE,GAAGE,gBAAiB,CAEtC,CACA,MAAMhB,EAAoB,MAAZlC,EAAK,GAAaA,EAAKmB,MAAM,IAAKZ,EAAAA,EAAAA,IAAUP,EAAKmB,MAAM,IACrE,MAAO,CAACe,EAAOE,EACnB,CAGA,IAAIe,EAAY,EAChB,MAAMC,EAAkBC,QAAQC,UAC1BC,EAASA,IAAMJ,IAAcC,EAAEI,MAAK,IAAOL,EAAY,IAAMA,EAAYM,KAAKC,OACpF,SAASZ,EAAca,EAAc1C,GACjC,MAAM4B,EAAWb,IAab,GAAKA,EAAE4B,MAGF,GAAI5B,EAAE4B,MAAQf,EAAQgB,SACvB,YAHA7B,EAAE4B,KAAOH,KAAKC,OAKlBI,EAAAA,EAAAA,IAA2BC,EAA8B/B,EAAGa,EAAQ1N,OAAQ8L,EAAU,EAAyC,CAACe,GAAG,EAIvI,OAFAa,EAAQ1N,MAAQwO,EAChBd,EAAQgB,SAAWN,IACZV,CACX,CACA,SAASkB,EAA8B/B,EAAG7M,GACtC,IAAI3C,EAAAA,EAAAA,IAAQ2C,GAAQ,CAChB,MAAM6O,EAAehC,EAAEiC,yBAKvB,OAJAjC,EAAEiC,yBAA2B,KACzBD,EAAalN,KAAKkL,GAClBA,EAAEkC,UAAW,CAAI,EAEd/O,EAAM3B,KAAIlF,GAAO0T,IAAOA,EAAEkC,UAAY5V,GAAMA,EAAG0T,IAC1D,CAEI,OAAO7M,CAEf,CAEA,MAAMgP,EAAa,WACbC,EAAYA,CAACnH,EAAIxL,EAAK8Q,EAAWC,EAAW1F,GAAQ,EAAO2E,EAAcC,EAAiBC,EAAgBC,KAChG,UAARnQ,EACAuN,EAAW/B,EAAIuF,EAAW1F,GAEb,UAARrL,EACL6N,EAAWrC,EAAIsF,EAAWC,IAErB6B,EAAAA,EAAAA,IAAK5S,IAEL6S,EAAAA,EAAAA,IAAgB7S,IACjB6Q,EAAWrF,EAAIxL,EAAK8Q,EAAWC,EAAWd,IAG9B,MAAXjQ,EAAI,IACLA,EAAMA,EAAI0P,MAAM,GAAK,GACZ,MAAX1P,EAAI,IACEA,EAAMA,EAAI0P,MAAM,GAAK,GACvBoD,EAAgBtH,EAAIxL,EAAK+Q,EAAW1F,IAC1C0E,EAAavE,EAAIxL,EAAK+Q,EAAWf,EAAcC,EAAiBC,EAAgBC,IAOpE,eAARnQ,EACAwL,EAAGuH,WAAahC,EAEH,gBAAR/Q,IACLwL,EAAGwH,YAAcjC,GAErBxB,EAAU/D,EAAIxL,EAAK+Q,EAAW1F,GAClC,EAEJ,SAASyH,EAAgBtH,EAAIxL,EAAK0D,EAAO2H,GACrC,OAAIA,EAGY,cAARrL,GAA+B,gBAARA,MAIvBA,KAAOwL,GAAMkH,EAAW7D,KAAK7O,KAAQoK,EAAAA,EAAAA,IAAW1G,IAW5C,eAAR1D,GAAgC,cAARA,GAA+B,cAARA,IAKvC,SAARA,KAIQ,SAARA,GAAiC,UAAfwL,EAAG4E,YAIb,SAARpQ,GAAiC,aAAfwL,EAAG4E,aAIrBsC,EAAW7D,KAAK7O,MAAQiO,EAAAA,EAAAA,IAASvK,KAG9B1D,KAAOwL,KAClB,CAgB0C,qBAAhByH,aAA8BA,YAsTxD,MAAMC,EAAa,aACbC,EAAY,YAGZC,EAAaA,CAAC7H,GAAS8H,YAAYC,EAAAA,EAAAA,GAAEC,EAAAA,GAAgBC,EAAuBjI,GAAQ8H,GAC1FD,EAAWK,YAAc,aACzB,MAAMC,EAA+B,CACjCnF,KAAMoF,OACN5T,KAAM4T,OACNC,IAAK,CACD7T,KAAM8T,QACNC,SAAS,GAEbC,SAAU,CAACJ,OAAQ1S,OAAQW,QAC3BoS,eAAgBL,OAChBM,iBAAkBN,OAClBO,aAAcP,OACdQ,gBAAiBR,OACjBS,kBAAmBT,OACnBU,cAAeV,OACfW,eAAgBX,OAChBY,iBAAkBZ,OAClBa,aAAcb,QAEZc,EAA6BrB,EAAW7H,OAC5B5G,EAAAA,EAAAA,IAAO,CAAC,EAAG4O,EAAAA,GAAAA,MAAsBG,GAK7CgB,EAAWA,CAACC,EAAMnS,EAAO,OACvBzB,EAAAA,EAAAA,IAAQ4T,GACRA,EAAKzT,SAAQoS,GAAKA,KAAK9Q,KAElBmS,GACLA,KAAQnS,EACZ,EAMEoS,EAAuBD,KAClBA,KACD5T,EAAAA,EAAAA,IAAQ4T,GACJA,EAAKE,MAAKvB,GAAKA,EAAEhW,OAAS,IAC1BqX,EAAKrX,OAAS,GAG5B,SAASkW,EAAuBsB,GAC5B,MAAMC,EAAY,CAAC,EACnB,IAAK,MAAM/U,KAAO8U,EACR9U,KAAO0T,IACTqB,EAAU/U,GAAO8U,EAAS9U,IAGlC,IAAqB,IAAjB8U,EAASlB,IACT,OAAOmB,EAEX,MAAM,KAAExG,EAAO,IAAG,KAAExO,EAAI,SAAEgU,EAAQ,eAAEC,EAAkB,GAAEzF,eAAiB,iBAAE0F,EAAoB,GAAE1F,iBAAmB,aAAE2F,EAAgB,GAAE3F,aAAe,gBAAE4F,EAAkBH,EAAc,kBAAEI,EAAoBH,EAAgB,cAAEI,EAAgBH,EAAY,eAAEI,EAAkB,GAAE/F,eAAiB,iBAAEgG,EAAoB,GAAEhG,iBAAmB,aAAEiG,EAAgB,GAAEjG,cAAoBuG,EACjXE,EAAYC,EAAkBlB,GAC9BmB,EAAgBF,GAAaA,EAAU,GACvCG,EAAgBH,GAAaA,EAAU,IACvC,cAAEI,EAAa,QAAEC,EAAO,iBAAEC,EAAgB,QAAEC,EAAO,iBAAEC,EAAgB,eAAEC,EAAiBL,EAAa,SAAEM,EAAWL,EAAO,kBAAEM,EAAoBL,GAAqBP,EACpKa,EAAcA,CAACpK,EAAIqK,EAAUtP,KAC/BuP,EAAsBtK,EAAIqK,EAAWxB,EAAgBH,GACrD4B,EAAsBtK,EAAIqK,EAAWzB,EAAoBH,GACzD1N,GAAQA,GAAM,EAEZwP,EAAcA,CAACvK,EAAIjF,KACrBiF,EAAGwK,YAAa,EAChBF,EAAsBtK,EAAI8I,GAC1BwB,EAAsBtK,EAAIgJ,GAC1BsB,EAAsBtK,EAAI+I,GAC1BhO,GAAQA,GAAM,EAEZ0P,EAAiBJ,GACZ,CAACrK,EAAIjF,KACR,MAAMoO,EAAOkB,EAAWH,EAAWL,EAC7BxD,EAAUA,IAAM+D,EAAYpK,EAAIqK,EAAUtP,GAChDmO,EAASC,EAAM,CAACnJ,EAAIqG,IACpBqE,GAAU,KACNJ,EAAsBtK,EAAIqK,EAAW1B,EAAkBH,GACvDmC,EAAmB3K,EAAIqK,EAAWxB,EAAgBH,GAC7CU,EAAoBD,IACrByB,EAAmB5K,EAAIzL,EAAMmV,EAAerD,EAChD,GACF,EAGV,OAAOlN,EAAAA,EAAAA,IAAOoQ,EAAW,CACrBK,cAAc5J,GACVkJ,EAASU,EAAe,CAAC5J,IACzB2K,EAAmB3K,EAAIwI,GACvBmC,EAAmB3K,EAAIyI,EAC3B,EACAwB,eAAejK,GACXkJ,EAASe,EAAgB,CAACjK,IAC1B2K,EAAmB3K,EAAI2I,GACvBgC,EAAmB3K,EAAI4I,EAC3B,EACAiB,QAASY,GAAc,GACvBP,SAAUO,GAAc,GACxBV,QAAQ/J,EAAIjF,GACRiF,EAAGwK,YAAa,EAChB,MAAMnE,EAAUA,IAAMkE,EAAYvK,EAAIjF,GACtC4P,EAAmB3K,EAAI8I,GAEvB+B,IACAF,EAAmB3K,EAAI+I,GACvB2B,GAAU,KACD1K,EAAGwK,aAIRF,EAAsBtK,EAAI8I,GAC1B6B,EAAmB3K,EAAIgJ,GAClBI,EAAoBW,IACrBa,EAAmB5K,EAAIzL,EAAMoV,EAAetD,GAChD,IAEJ6C,EAASa,EAAS,CAAC/J,EAAIqG,GAC3B,EACAyD,iBAAiB9J,GACboK,EAAYpK,GAAI,GAChBkJ,EAASY,EAAkB,CAAC9J,GAChC,EACAmK,kBAAkBnK,GACdoK,EAAYpK,GAAI,GAChBkJ,EAASiB,EAAmB,CAACnK,GACjC,EACAgK,iBAAiBhK,GACbuK,EAAYvK,GACZkJ,EAASc,EAAkB,CAAChK,GAChC,GAER,CACA,SAASyJ,EAAkBlB,GACvB,GAAgB,MAAZA,EACA,OAAO,KAEN,IAAIpQ,EAAAA,EAAAA,IAASoQ,GACd,MAAO,CAACuC,EAASvC,EAASwC,OAAQD,EAASvC,EAASyC,QAEnD,CACD,MAAMtY,EAAIoY,EAASvC,GACnB,MAAO,CAAC7V,EAAGA,EACf,CACJ,CACA,SAASoY,EAAS9H,GACd,MAAM7L,GAAM8T,EAAAA,EAAAA,IAASjI,GAIrB,OAAO7L,CACX,CACA,SAASwT,EAAmB3K,EAAIkL,GAC5BA,EAAIC,MAAM,OAAOzV,SAAQ0V,GAAKA,GAAKpL,EAAGqL,UAAUpW,IAAImW,MACnDpL,EAAGiC,OACCjC,EAAGiC,KAAO,IAAIzP,MAAQyC,IAAIiW,EACnC,CACA,SAASZ,EAAsBtK,EAAIkL,GAC/BA,EAAIC,MAAM,OAAOzV,SAAQ0V,GAAKA,GAAKpL,EAAGqL,UAAU5L,OAAO2L,KACvD,MAAM,KAAEnJ,GAASjC,EACbiC,IACAA,EAAK/O,OAAOgY,GACPjJ,EAAKnI,OACNkG,EAAGiC,UAAOhQ,GAGtB,CACA,SAASyY,EAAUY,GACfC,uBAAsB,KAClBA,sBAAsBD,EAAG,GAEjC,CACA,IAAIE,EAAQ,EACZ,SAASZ,EAAmB5K,EAAIyL,EAAcC,EAAiBrF,GAC3D,MAAMpF,EAAMjB,EAAG2L,SAAWH,EACpBI,EAAoBA,KAClB3K,IAAOjB,EAAG2L,QACVtF,GACJ,EAEJ,GAAIqF,EACA,OAAOG,WAAWD,EAAmBF,GAEzC,MAAM,KAAEnX,EAAI,QAAEuX,EAAO,UAAEC,GAAcC,EAAkBhM,EAAIyL,GAC3D,IAAKlX,EACD,OAAO8R,IAEX,MAAM4F,EAAW1X,EAAO,MACxB,IAAI2X,EAAQ,EACZ,MAAM7K,EAAMA,KACRrB,EAAGoF,oBAAoB6G,EAAUE,GACjCP,GAAmB,EAEjBO,EAASpH,IACPA,EAAEzQ,SAAW0L,KAAQkM,GAASH,GAC9B1K,GACJ,EAEJwK,YAAW,KACHK,EAAQH,GACR1K,GACJ,GACDyK,EAAU,GACb9L,EAAGgF,iBAAiBiH,EAAUE,EAClC,CACA,SAASH,EAAkBhM,EAAIyL,GAC3B,MAAMW,EAASC,OAAOC,iBAAiBtM,GAEjCuM,EAAsB/X,IAAS4X,EAAO5X,IAAQ,IAAI2W,MAAM,MACxDqB,EAAmBD,EAAoB,GAAE7E,UACzC+E,EAAsBF,EAAoB,GAAE7E,aAC5CgF,EAAoBC,EAAWH,EAAkBC,GACjDG,EAAkBL,EAAoB,GAAE5E,UACxCkF,EAAqBN,EAAoB,GAAE5E,aAC3CmF,EAAmBH,EAAWC,EAAiBC,GACrD,IAAItY,EAAO,KACPuX,EAAU,EACVC,EAAY,EAEZN,IAAiB/D,EACbgF,EAAoB,IACpBnY,EAAOmT,EACPoE,EAAUY,EACVX,EAAYU,EAAoB3a,QAG/B2Z,IAAiB9D,EAClBmF,EAAmB,IACnBvY,EAAOoT,EACPmE,EAAUgB,EACVf,EAAYc,EAAmB/a,SAInCga,EAAUiB,KAAKC,IAAIN,EAAmBI,GACtCvY,EACIuX,EAAU,EACJY,EAAoBI,EAChBpF,EACAC,EACJ,KACVoE,EAAYxX,EACNA,IAASmT,EACL+E,EAAoB3a,OACpB+a,EAAmB/a,OACvB,GAEV,MAAMmb,EAAe1Y,IAASmT,GAC1B,yBAAyBrE,KAAKkJ,EAAoB,GAAE7E,aAAsBwF,YAC9E,MAAO,CACH3Y,OACAuX,UACAC,YACAkB,eAER,CACA,SAASN,EAAWQ,EAAQ3D,GACxB,MAAO2D,EAAOrb,OAAS0X,EAAU1X,OAC7Bqb,EAASA,EAAOC,OAAOD,GAE3B,OAAOJ,KAAKC,OAAOxD,EAAUjT,KAAI,CAAC8W,EAAGzb,IAAM0b,EAAKD,GAAKC,EAAKH,EAAOvb,MACrE,CAKA,SAAS0b,EAAKC,GACV,OAAkD,IAA3C9X,OAAO8X,EAAErJ,MAAM,GAAI,GAAGX,QAAQ,IAAK,KAC9C,CAEA,SAASsH,IACL,OAAO5L,SAASuO,KAAKC,YACzB,CAEA,MAAMC,EAAc,IAAIta,QAClBua,EAAiB,IAAIva,QACrBwa,GAAsB,CACxB7K,KAAM,kBACNhD,OAAqB5G,EAAAA,EAAAA,IAAO,CAAC,EAAG8P,EAA2B,CACvDrJ,IAAKuI,OACL0F,UAAW1F,SAEf2F,MAAM/N,GAAO,MAAE8H,IACX,MAAM7D,GAAW+J,EAAAA,EAAAA,MACXC,GAAQC,EAAAA,EAAAA,MACd,IAAIzJ,EACA0J,EAmCJ,OAlCAC,EAAAA,EAAAA,KAAU,KAEN,IAAK3J,EAAa1S,OACd,OAEJ,MAAM+b,EAAY9N,EAAM8N,WAAc,GAAE9N,EAAMgD,MAAQ,WACtD,IAAKqL,GAAgB5J,EAAa,GAAGxE,GAAIgE,EAASqK,MAAMrO,GAAI6N,GACxD,OAIJrJ,EAAa9O,QAAQ4Y,IACrB9J,EAAa9O,QAAQ6Y,IACrB,MAAMC,EAAgBhK,EAAalO,OAAOmY,IAE1C5D,IACA2D,EAAc9Y,SAAQ0V,IAClB,MAAMpL,EAAKoL,EAAEpL,GACPuC,EAAQvC,EAAGuC,MACjBoI,EAAmB3K,EAAI6N,GACvBtL,EAAMmM,UAAYnM,EAAMoM,gBAAkBpM,EAAMqM,mBAAqB,GACrE,MAAMtD,EAAMtL,EAAG6O,QAAW9J,IAClBA,GAAKA,EAAEzQ,SAAW0L,GAGjB+E,IAAK,aAAa1B,KAAK0B,EAAE+J,gBAC1B9O,EAAGoF,oBAAoB,gBAAiBkG,GACxCtL,EAAG6O,QAAU,KACbvE,EAAsBtK,EAAI6N,GAC9B,EAEJ7N,EAAGgF,iBAAiB,gBAAiBsG,EAAG,GAC1C,IAEC,KACH,MAAMhC,GAAWpS,EAAAA,EAAAA,IAAM6I,GACjBgP,EAAqB/G,EAAuBsB,GAClD,IAAI1J,EAAM0J,EAAS1J,KAAOoP,EAAAA,GAC1BxK,EAAe0J,EACfA,EAAWrG,EAAMS,SAAU2G,EAAAA,EAAAA,IAAyBpH,EAAMS,WAAa,GACvE,IAAK,IAAI1W,EAAI,EAAGA,EAAIsc,EAASpc,OAAQF,IAAK,CACtC,MAAM0N,EAAQ4O,EAAStc,GACN,MAAb0N,EAAM9K,MACN0a,EAAAA,EAAAA,IAAmB5P,GAAO6P,EAAAA,EAAAA,IAAuB7P,EAAOyP,EAAoBf,EAAOhK,GAK3F,CACA,GAAIQ,EACA,IAAK,IAAI5S,EAAI,EAAGA,EAAI4S,EAAa1S,OAAQF,IAAK,CAC1C,MAAM0N,EAAQkF,EAAa5S,IAC3Bsd,EAAAA,EAAAA,IAAmB5P,GAAO6P,EAAAA,EAAAA,IAAuB7P,EAAOyP,EAAoBf,EAAOhK,IACnF0J,EAAY/Y,IAAI2K,EAAOA,EAAMU,GAAGoP,wBACpC,CAEJ,OAAOC,EAAAA,EAAAA,IAAYzP,EAAK,KAAMsO,EAAS,CAE/C,GASqBN,GAAoB7N,MAE7C,SAASuO,GAAelD,GACpB,MAAMpL,EAAKoL,EAAEpL,GACTA,EAAG6O,SACH7O,EAAG6O,UAEH7O,EAAGsP,UACHtP,EAAGsP,UAEX,CACA,SAASf,GAAenD,GACpBuC,EAAehZ,IAAIyW,EAAGA,EAAEpL,GAAGoP,wBAC/B,CACA,SAASX,GAAiBrD,GACtB,MAAMmE,EAAS7B,EAAYhZ,IAAI0W,GACzBoE,EAAS7B,EAAejZ,IAAI0W,GAC5BqE,EAAKF,EAAOG,KAAOF,EAAOE,KAC1BC,EAAKJ,EAAOK,IAAMJ,EAAOI,IAC/B,GAAIH,GAAME,EAAI,CACV,MAAMpC,EAAInC,EAAEpL,GAAGuC,MAGf,OAFAgL,EAAEmB,UAAYnB,EAAEoB,gBAAmB,aAAYc,OAAQE,OACvDpC,EAAEqB,mBAAqB,KAChBxD,CACX,CACJ,CACA,SAASgD,GAAgBpO,EAAI6P,EAAMhC,GAM/B,MAAMiC,EAAQ9P,EAAGyB,YACbzB,EAAGiC,MACHjC,EAAGiC,KAAKvM,SAAQwV,IACZA,EAAIC,MAAM,OAAOzV,SAAQ0V,GAAKA,GAAK0E,EAAMzE,UAAU5L,OAAO2L,IAAG,IAGrEyC,EAAU1C,MAAM,OAAOzV,SAAQ0V,GAAKA,GAAK0E,EAAMzE,UAAUpW,IAAImW,KAC7D0E,EAAMvN,MAAMK,QAAU,OACtB,MAAMmN,EAA+B,IAAlBF,EAAKG,SAAiBH,EAAOA,EAAKnQ,WACrDqQ,EAAUjO,YAAYgO,GACtB,MAAM,aAAE7C,GAAiBjB,EAAkB8D,GAE3C,OADAC,EAAUpQ,YAAYmQ,GACf7C,CACX,CAEA,MAAMgD,GAAoB5B,IACtB,MAAMhd,EAAKgd,EAAMtO,MAAM,yBAClB,EACL,OAAOxK,EAAAA,EAAAA,IAAQlE,GAAM6G,IAASgY,EAAAA,EAAAA,IAAe7e,EAAI6G,GAAS7G,CAAE,EAEhE,SAAS8e,GAAmBpL,GACxBA,EAAEzQ,OAAO8b,WAAY,CACzB,CACA,SAASC,GAAiBtL,GACtB,MAAMzQ,EAASyQ,EAAEzQ,OACbA,EAAO8b,YACP9b,EAAO8b,WAAY,EACnB9b,EAAOgc,cAAc,IAAIC,MAAM,UAEvC,CAGA,MAAMC,GAAa,CACfC,QAAQzQ,GAAM0Q,WAAW,KAAEC,EAAI,KAAEC,EAAI,OAAEC,IAAYxC,GAC/CrO,EAAG8Q,QAAUb,GAAiB5B,GAC9B,MAAM0C,EAAeF,GAAWxC,EAAMtO,OAA8B,WAArBsO,EAAMtO,MAAMxL,KAC3DyQ,EAAiBhF,EAAI2Q,EAAO,SAAW,SAAS5L,IAC5C,GAAIA,EAAEzQ,OAAO8b,UACT,OACJ,IAAIY,EAAWhR,EAAG9H,MACd0Y,IACAI,EAAWA,EAASJ,QAEpBG,IACAC,GAAWC,EAAAA,EAAAA,IAAcD,IAE7BhR,EAAG8Q,QAAQE,EAAS,IAEpBJ,GACA5L,EAAiBhF,EAAI,UAAU,KAC3BA,EAAG9H,MAAQ8H,EAAG9H,MAAM0Y,MAAM,IAG7BD,IACD3L,EAAiBhF,EAAI,mBAAoBmQ,IACzCnL,EAAiBhF,EAAI,iBAAkBqQ,IAKvCrL,EAAiBhF,EAAI,SAAUqQ,IAEvC,EAEAa,QAAQlR,GAAI,MAAE9H,IACV8H,EAAG9H,MAAiB,MAATA,EAAgB,GAAKA,CACpC,EACAiZ,aAAanR,GAAI,MAAE9H,EAAOwY,WAAW,KAAEC,EAAI,KAAEC,EAAI,OAAEC,IAAYxC,GAG3D,GAFArO,EAAG8Q,QAAUb,GAAiB5B,GAE1BrO,EAAGoQ,UACH,OACJ,GAAInR,SAASmS,gBAAkBpR,GAAkB,UAAZA,EAAGzL,KAAkB,CACtD,GAAIoc,EACA,OAEJ,GAAIC,GAAQ5Q,EAAG9H,MAAM0Y,SAAW1Y,EAC5B,OAEJ,IAAK2Y,GAAsB,WAAZ7Q,EAAGzL,QACd0c,EAAAA,EAAAA,IAAcjR,EAAG9H,SAAWA,EAC5B,MAER,CACA,MAAM/C,EAAoB,MAAT+C,EAAgB,GAAKA,EAClC8H,EAAG9H,QAAU/C,IACb6K,EAAG9H,MAAQ/C,EAEnB,GAEEkc,GAAiB,CAEnBC,MAAM,EACNb,QAAQzQ,EAAIuR,EAAGlD,GACXrO,EAAG8Q,QAAUb,GAAiB5B,GAC9BrJ,EAAiBhF,EAAI,UAAU,KAC3B,MAAMwR,EAAaxR,EAAGyR,YAChBC,EAAeC,GAAS3R,GACxB4R,EAAU5R,EAAG4R,QACbC,EAAS7R,EAAG8Q,QAClB,IAAIvb,EAAAA,EAAAA,IAAQic,GAAa,CACrB,MAAMxgB,GAAQ8gB,EAAAA,EAAAA,IAAaN,EAAYE,GACjCK,GAAmB,IAAX/gB,EACd,GAAI4gB,IAAYG,EACZF,EAAOL,EAAWpE,OAAOsE,SAExB,IAAKE,GAAWG,EAAO,CACxB,MAAMC,EAAW,IAAIR,GACrBQ,EAASC,OAAOjhB,EAAO,GACvB6gB,EAAOG,EACX,CACJ,MACK,IAAIE,EAAAA,EAAAA,IAAMV,GAAa,CACxB,MAAMW,EAAS,IAAI3f,IAAIgf,GACnBI,EACAO,EAAOld,IAAIyc,GAGXS,EAAOjf,OAAOwe,GAElBG,EAAOM,EACX,MAEIN,EAAOO,GAAiBpS,EAAI4R,GAChC,GAER,EAEAV,QAASmB,GACTlB,aAAanR,EAAIsS,EAASjE,GACtBrO,EAAG8Q,QAAUb,GAAiB5B,GAC9BgE,GAAWrS,EAAIsS,EAASjE,EAC5B,GAEJ,SAASgE,GAAWrS,GAAI,MAAE9H,EAAK,SAAE9C,GAAYiZ,GACzCrO,EAAGyR,YAAcvZ,GACb3C,EAAAA,EAAAA,IAAQ2C,GACR8H,EAAG4R,SAAUE,EAAAA,EAAAA,IAAa5Z,EAAOmW,EAAMtO,MAAM7H,QAAU,GAElDga,EAAAA,EAAAA,IAAMha,GACX8H,EAAG4R,QAAU1Z,EAAMlD,IAAIqZ,EAAMtO,MAAM7H,OAE9BA,IAAU9C,IACf4K,EAAG4R,SAAUW,EAAAA,EAAAA,IAAWra,EAAOka,GAAiBpS,GAAI,IAE5D,CACA,MAeMwS,GAAe,CAEjBlB,MAAM,EACNb,QAAQzQ,GAAI,MAAE9H,EAAOwY,WAAW,OAAEG,IAAYxC,GAC1C,MAAMoE,GAAaP,EAAAA,EAAAA,IAAMha,GACzB8M,EAAiBhF,EAAI,UAAU,KAC3B,MAAM0S,EAAcC,MAAMC,UAAUtc,OAC/BuD,KAAKmG,EAAGmF,SAAU0N,GAAMA,EAAEC,WAC1Bvc,KAAKsc,GAAMhC,GAASI,EAAAA,EAAAA,IAAcU,GAASkB,IAAMlB,GAASkB,KAC/D7S,EAAG8Q,QAAQ9Q,EAAGE,SACRuS,EACI,IAAIjgB,IAAIkgB,GACRA,EACJA,EAAY,GAAG,IAEzB1S,EAAG8Q,QAAUb,GAAiB5B,EAClC,EAGA6C,QAAQlR,GAAI,MAAE9H,IACV6a,GAAY/S,EAAI9H,EACpB,EACAiZ,aAAanR,EAAIgT,EAAU3E,GACvBrO,EAAG8Q,QAAUb,GAAiB5B,EAClC,EACA4E,QAAQjT,GAAI,MAAE9H,IACV6a,GAAY/S,EAAI9H,EACpB,GAEJ,SAAS6a,GAAY/S,EAAI9H,GACrB,MAAMgb,EAAalT,EAAGE,SACtB,IAAIgT,IAAe3d,EAAAA,EAAAA,IAAQ2C,KAAWga,EAAAA,EAAAA,IAAMha,GAA5C,CAMA,IAAK,IAAItG,EAAI,EAAGC,EAAImO,EAAGmF,QAAQrT,OAAQF,EAAIC,EAAGD,IAAK,CAC/C,MAAMuhB,EAASnT,EAAGmF,QAAQvT,GACpBwhB,EAAczB,GAASwB,GAC7B,GAAID,GACI3d,EAAAA,EAAAA,IAAQ2C,GACRib,EAAOL,UAAWhB,EAAAA,EAAAA,IAAa5Z,EAAOkb,IAAgB,EAGtDD,EAAOL,SAAW5a,EAAMlD,IAAIoe,QAIhC,IAAIb,EAAAA,EAAAA,IAAWZ,GAASwB,GAASjb,GAG7B,YAFI8H,EAAGqT,gBAAkBzhB,IACrBoO,EAAGqT,cAAgBzhB,GAInC,CACKshB,IAAoC,IAAtBlT,EAAGqT,gBAClBrT,EAAGqT,eAAiB,EArBxB,CAuBJ,CAEA,SAAS1B,GAAS3R,GACd,MAAO,WAAYA,EAAKA,EAAGtC,OAASsC,EAAG9H,KAC3C,CAEA,SAASka,GAAiBpS,EAAI4R,GAC1B,MAAMpd,EAAMod,EAAU,aAAe,cACrC,OAAOpd,KAAOwL,EAAKA,EAAGxL,GAAOod,CACjC,CA0EA,MAAM0B,GAAkB,CAAC,OAAQ,QAAS,MAAO,QAC3CC,GAAiB,CACnB7hB,KAAMqT,GAAKA,EAAEyO,kBACbC,QAAS1O,GAAKA,EAAE2O,iBAChBnV,KAAMwG,GAAKA,EAAEzQ,SAAWyQ,EAAE4O,cAC1BC,KAAM7O,IAAMA,EAAE8O,QACdC,MAAO/O,IAAMA,EAAEgP,SACfC,IAAKjP,IAAMA,EAAEkP,OACbC,KAAMnP,IAAMA,EAAEoP,QACdzE,KAAM3K,GAAK,WAAYA,GAAkB,IAAbA,EAAEqP,OAC9BC,OAAQtP,GAAK,WAAYA,GAAkB,IAAbA,EAAEqP,OAChCE,MAAOvP,GAAK,WAAYA,GAAkB,IAAbA,EAAEqP,OAC/BG,MAAOA,CAACxP,EAAG2L,IAAc4C,GAAgBjK,MAAKtD,GAAKhB,EAAG,GAAEgB,UAAY2K,EAAU7L,SAASkB,MAKrFyO,GAAgBA,CAACnjB,EAAIqf,IAChB,CAACzL,KAAUjO,KACd,IAAK,IAAIpF,EAAI,EAAGA,EAAI8e,EAAU5e,OAAQF,IAAK,CACvC,MAAM6iB,EAAQlB,GAAe7C,EAAU9e,IACvC,GAAI6iB,GAASA,EAAMxP,EAAOyL,GACtB,MACR,CACA,OAAOrf,EAAG4T,KAAUjO,EAAK,EA6B3B0d,GAAQ,CACVC,YAAY3U,GAAI,MAAE9H,IAAS,WAAE0c,IACzB5U,EAAG6U,KAA4B,SAArB7U,EAAGuC,MAAMK,QAAqB,GAAK5C,EAAGuC,MAAMK,QAClDgS,GAAc1c,EACd0c,EAAWE,YAAY9U,GAGvB+U,GAAW/U,EAAI9H,EAEvB,EACAgZ,QAAQlR,GAAI,MAAE9H,IAAS,WAAE0c,IACjBA,GAAc1c,GACd0c,EAAW7J,MAAM/K,EAEzB,EACAiT,QAAQjT,GAAI,MAAE9H,EAAK,SAAE9C,IAAY,WAAEwf,KAC1B1c,KAAW9C,IAEZwf,EACI1c,GACA0c,EAAWE,YAAY9U,GACvB+U,GAAW/U,GAAI,GACf4U,EAAW7J,MAAM/K,IAGjB4U,EAAW5J,MAAMhL,GAAI,KACjB+U,GAAW/U,GAAI,EAAM,IAK7B+U,GAAW/U,EAAI9H,GAEvB,EACA8c,cAAchV,GAAI,MAAE9H,IAChB6c,GAAW/U,EAAI9H,EACnB,GAEJ,SAAS6c,GAAW/U,EAAI9H,GACpB8H,EAAGuC,MAAMK,QAAU1K,EAAQ8H,EAAG6U,KAAO,MACzC,CAWA,MAAMI,IAAgC9b,EAAAA,EAAAA,IAAO,CAAEgO,aAAa/H,GAG5D,IAAI8V,GAEJ,SAASC,KACL,OAAQD,KACHA,IAAWE,EAAAA,EAAAA,IAAeH,IACnC,CASA,MAMMI,GAAaA,IAAIre,KACnB,MAAMse,EAAMH,KAAiBE,aAAare,GAK1C,MAAM,MAAEue,GAAUD,EAsBlB,OArBAA,EAAIC,MAASC,IACT,MAAMzF,EAAY0F,GAAmBD,GACrC,IAAKzF,EACD,OACJ,MAAM2F,EAAYJ,EAAIK,YACjB/W,EAAAA,EAAAA,IAAW8W,IAAeA,EAAUE,QAAWF,EAAU/T,WAK1D+T,EAAU/T,SAAWoO,EAAUrO,WAGnCqO,EAAUrO,UAAY,GACtB,MAAMnF,EAAQgZ,EAAMxF,GAAW,EAAOA,aAAqB8F,YAK3D,OAJI9F,aAAqB+F,UACrB/F,EAAU5N,gBAAgB,WAC1B4N,EAAU5P,aAAa,aAAc,KAElC5D,CAAK,EAET+Y,CAAG,EAyDd,SAASG,GAAmB1F,GACxB,IAAItN,EAAAA,EAAAA,IAASsN,GAAY,CACrB,MAAM5Y,EAAM8H,SAAS6B,cAAciP,GAInC,OAAO5Y,CACX,CAOA,OAAO4Y,CACX,C,mhCC9oDA,SAAS7Z,EAAQ6f,EAAKC,GAClB,MAAMzf,EAAMH,OAAO6f,OAAO,MACpBC,EAAOH,EAAI5K,MAAM,KACvB,IAAK,IAAIvZ,EAAI,EAAGA,EAAIskB,EAAKpkB,OAAQF,IAC7B2E,EAAI2f,EAAKtkB,KAAM,EAEnB,OAAOokB,EAAmBhT,KAASzM,EAAIyM,EAAIiD,eAAiBjD,KAASzM,EAAIyM,EAC7E,CAKA,MA0BMmT,EAAuB,mMAGvBC,EAAsClgB,EAAQigB,GA8CpD,SAASE,EAAene,GACpB,GAAI3C,EAAQ2C,GAAQ,CAChB,MAAMf,EAAM,CAAC,EACb,IAAK,IAAIvF,EAAI,EAAGA,EAAIsG,EAAMpG,OAAQF,IAAK,CACnC,MAAM0kB,EAAOpe,EAAMtG,GACb2kB,EAAa9T,EAAS6T,GACtBE,EAAiBF,GACjBD,EAAeC,GACrB,GAAIC,EACA,IAAK,MAAM/hB,KAAO+hB,EACdpf,EAAI3C,GAAO+hB,EAAW/hB,EAGlC,CACA,OAAO2C,CACX,CACK,OAAIsL,EAASvK,IAGTC,EAASD,GAFPA,OAEN,CAGT,CACA,MAAMue,EAAkB,gBAClBC,EAAsB,UACtBC,EAAiB,gBACvB,SAASH,EAAiB3T,GACtB,MAAM+T,EAAM,CAAC,EAUb,OATA/T,EACKU,QAAQoT,EAAgB,IACxBxL,MAAMsL,GACN/gB,SAAQ4gB,IACT,GAAIA,EAAM,CACN,MAAMO,EAAMP,EAAKnL,MAAMuL,GACvBG,EAAI/kB,OAAS,IAAM8kB,EAAIC,EAAI,GAAGjG,QAAUiG,EAAI,GAAGjG,OACnD,KAEGgG,CACX,CAgBA,SAASE,EAAe5e,GACpB,IAAIf,EAAM,GACV,GAAIsL,EAASvK,GACTf,EAAMe,OAEL,GAAI3C,EAAQ2C,GACb,IAAK,IAAItG,EAAI,EAAGA,EAAIsG,EAAMpG,OAAQF,IAAK,CACnC,MAAM2kB,EAAaO,EAAe5e,EAAMtG,IACpC2kB,IACApf,GAAOof,EAAa,IAE5B,MAEC,GAAIpe,EAASD,GACd,IAAK,MAAM6K,KAAQ7K,EACXA,EAAM6K,KACN5L,GAAO4L,EAAO,KAI1B,OAAO5L,EAAIyZ,MACf,CAgBA,MAgDMmG,EAAuB,8EACvB1S,EAAqCnO,EAAQ6gB,GAYnD,SAASzS,EAAmBpM,GACxB,QAASA,GAAmB,KAAVA,CACtB,CAgIA,SAAS8e,EAAmBC,EAAGC,GAC3B,GAAID,EAAEnlB,SAAWolB,EAAEplB,OACf,OAAO,EACX,IAAIqlB,GAAQ,EACZ,IAAK,IAAIvlB,EAAI,EAAGulB,GAASvlB,EAAIqlB,EAAEnlB,OAAQF,IACnCulB,EAAQ5E,EAAW0E,EAAErlB,GAAIslB,EAAEtlB,IAE/B,OAAOulB,CACX,CACA,SAAS5E,EAAW0E,EAAGC,GACnB,GAAID,IAAMC,EACN,OAAO,EACX,IAAIE,EAAaC,EAAOJ,GACpBK,EAAaD,EAAOH,GACxB,GAAIE,GAAcE,EACd,SAAOF,IAAcE,IAAaL,EAAEM,YAAcL,EAAEK,UAIxD,GAFAH,EAAa5gB,EAASygB,GACtBK,EAAa9gB,EAAS0gB,GAClBE,GAAcE,EACd,OAAOL,IAAMC,EAIjB,GAFAE,EAAa7hB,EAAQ0hB,GACrBK,EAAa/hB,EAAQ2hB,GACjBE,GAAcE,EACd,SAAOF,IAAcE,IAAaN,EAAmBC,EAAGC,GAI5D,GAFAE,EAAajf,EAAS8e,GACtBK,EAAanf,EAAS+e,GAClBE,GAAcE,EAAY,CAE1B,IAAKF,IAAeE,EAChB,OAAO,EAEX,MAAME,EAAaphB,OAAOqhB,KAAKR,GAAGnlB,OAC5B4lB,EAAathB,OAAOqhB,KAAKP,GAAGplB,OAClC,GAAI0lB,IAAeE,EACf,OAAO,EAEX,IAAK,MAAMljB,KAAOyiB,EAAG,CACjB,MAAMU,EAAUV,EAAE5f,eAAe7C,GAC3BojB,EAAUV,EAAE7f,eAAe7C,GACjC,GAAKmjB,IAAYC,IACXD,GAAWC,IACZrF,EAAW0E,EAAEziB,GAAM0iB,EAAE1iB,IACtB,OAAO,CAEf,CACJ,CACA,OAAO2T,OAAO8O,KAAO9O,OAAO+O,EAChC,CACA,SAASpF,EAAa7a,EAAK+L,GACvB,OAAO/L,EAAI4gB,WAAUvB,GAAQ/D,EAAW+D,EAAMtT,IAClD,CAMA,MAAM8U,EAAmB9U,GACdP,EAASO,GACVA,EACO,MAAPA,EACI,GACAzN,EAAQyN,IACL7K,EAAS6K,KACLA,EAAIkK,WAAa6K,IAAmBnZ,EAAWoE,EAAIkK,WACtD8K,KAAKC,UAAUjV,EAAKkV,EAAU,GAC9B/P,OAAOnF,GAEnBkV,EAAWA,CAACC,EAAMnV,IAEhBA,GAAOA,EAAI7F,UACJ+a,EAASC,EAAMnV,EAAI9K,OAErBtC,EAAMoN,GACJ,CACH,CAAE,OAAMA,EAAIlJ,SAAU,IAAIkJ,EAAIoV,WAAWC,QAAO,CAACD,GAAU5jB,EAAKwO,MAC5DoV,EAAS,GAAE5jB,QAAYwO,EAChBoV,IACR,CAAC,IAGHlG,EAAMlP,GACJ,CACH,CAAE,OAAMA,EAAIlJ,SAAU,IAAIkJ,EAAI1N,YAG7B6C,EAAS6K,IAASzN,EAAQyN,IAASsV,EAActV,GAGnDA,EAFImF,OAAOnF,GAKhBuV,EAEA,CAAC,EACDC,EAA0E,GAC1E3Z,EAAOA,OAIP4Z,EAAKA,KAAM,EACXC,EAAO,YACPtR,EAAQ5S,GAAQkkB,EAAKrV,KAAK7O,GAC1B6S,EAAmB7S,GAAQA,EAAIyO,WAAW,aAC1C9J,EAAS/C,OAAOyb,OAChBpS,EAASA,CAACxI,EAAK+I,KACjB,MAAMpO,EAAIqF,EAAI0hB,QAAQ3Y,GAClBpO,GAAK,GACLqF,EAAIgb,OAAOrgB,EAAG,EAClB,EAEEyF,EAAiBjB,OAAOwc,UAAUvb,eAClCU,EAASA,CAACiL,EAAKxO,IAAQ6C,EAAewC,KAAKmJ,EAAKxO,GAChDe,EAAUod,MAAMpd,QAChBK,EAASoN,GAA8B,iBAAtB4V,EAAa5V,GAC9BkP,EAASlP,GAA8B,iBAAtB4V,EAAa5V,GAC9BqU,EAAUrU,GAA8B,kBAAtB4V,EAAa5V,GAC/B6V,EAAY7V,GAA8B,oBAAtB4V,EAAa5V,GACjCpE,EAAcoE,GAAuB,oBAARA,EAC7BP,EAAYO,GAAuB,kBAARA,EAC3BxM,EAAYwM,GAAuB,kBAARA,EAC3B7K,EAAY6K,GAAgB,OAARA,GAA+B,kBAARA,EAC3C8V,EAAa9V,GACR7K,EAAS6K,IAAQpE,EAAWoE,EAAIuD,OAAS3H,EAAWoE,EAAI+V,OAE7DhB,EAAiB3hB,OAAOwc,UAAU1F,SAClC0L,EAAgB1gB,GAAU6f,EAAele,KAAK3B,GAC9C6D,EAAa7D,GAER0gB,EAAa1gB,GAAOgM,MAAM,GAAI,GAEnCoU,EAAiBtV,GAA8B,oBAAtB4V,EAAa5V,GACtCrN,EAAgBnB,GAAQiO,EAASjO,IAC3B,QAARA,GACW,MAAXA,EAAI,IACJ,GAAKwkB,SAASxkB,EAAK,MAAQA,EACzBykB,EAA+B/iB,EAErC,uIAKMgjB,EAAuB7nB,IACzB,MAAM8nB,EAAQ/iB,OAAO6f,OAAO,MAC5B,OAASF,IACL,MAAMqD,EAAMD,EAAMpD,GAClB,OAAOqD,IAAQD,EAAMpD,GAAO1kB,EAAG0kB,GAAK,CACvC,EAECsD,EAAa,SAIbzV,EAAWsV,GAAqBnD,GAC3BA,EAAIxS,QAAQ8V,GAAY,CAAC9H,EAAGnG,IAAOA,EAAIA,EAAEkO,cAAgB,OAE9DC,EAAc,aAIdjW,EAAY4V,GAAqBnD,GAAQA,EAAIxS,QAAQgW,EAAa,OAAOtT,gBAIzEpC,EAAaqV,GAAqBnD,GAAQA,EAAIyD,OAAO,GAAGF,cAAgBvD,EAAI7R,MAAM,KAIlFuV,EAAeP,GAAqBnD,GAAQA,EAAO,KAAIlS,EAAWkS,KAAU,KAE5End,GAAaA,CAACV,EAAO9C,KAAcgB,OAAO0J,GAAG5H,EAAO9C,GACpD8a,GAAiBA,CAACwJ,EAAKC,KACzB,IAAK,IAAI/nB,EAAI,EAAGA,EAAI8nB,EAAI5nB,OAAQF,IAC5B8nB,EAAI9nB,GAAG+nB,EACX,EAEE9c,GAAMA,CAACvF,EAAK9C,EAAK0D,KACnB9B,OAAOwjB,eAAetiB,EAAK9C,EAAK,CAC5BqlB,cAAc,EACdC,YAAY,EACZ5hB,SACF,EAMA+Y,GAAiBjO,IACnB,MAAMtQ,EAAIqnB,WAAW/W,GACrB,OAAOgX,MAAMtnB,GAAKsQ,EAAMtQ,CAAC,EAMvBuY,GAAYjI,IACd,MAAMtQ,EAAI+P,EAASO,GAAOvN,OAAOuN,GAAOiX,IACxC,OAAOD,MAAMtnB,GAAKsQ,EAAMtQ,CAAC,EAE7B,IAAIwnB,GACJ,MAAMC,GAAgBA,IACVD,KACHA,GACyB,qBAAfE,WACDA,WACgB,qBAAT7b,KACHA,KACkB,qBAAX8N,OACHA,OACkB,qBAAXgO,EAAAA,EACHA,EAAAA,EACA,CAAC,E,gCC1kB/BC,EAAQ,EAAU,CAACC,EAAKxa,KACpB,MAAMzL,EAASimB,EAAIC,WAAaD,EAChC,IAAK,MAAO/lB,EAAKwO,KAAQjD,EACrBzL,EAAOE,GAAOwO,EAElB,OAAO1O,CAAM,C;;;;;;ACDjB,MAAMmmB,EAA8B,oBAAXhnB,QAAuD,kBAAvBA,OAAOinB,YAC1DC,EAAc5X,GAEpB0X,EACMhnB,OAA2EsP,GACb,OAAUA,EASxE6X,EAAgCD,EAAsF,QAOtHE,EAA6BF,EAA2E,OAOxGG,EAA0BH,EAAgE,KAO1FI,EAAiCJ,EAAwE,MAOzGK,EAAsCL,EAA8E,OAEpHM,EAA8B,qBAAX5O,OAEzB,SAAS6O,EAAW5jB,GAChB,OAAOA,EAAI6jB,YAAeV,GAAyC,WAA5BnjB,EAAI7D,OAAOinB,YACtD,CACA,MAAM7I,EAASzb,OAAOyb,OACtB,SAASuJ,EAAc/pB,EAAIgqB,GACvB,MAAMC,EAAY,CAAC,EACnB,IAAK,MAAM9mB,KAAO6mB,EAAQ,CACtB,MAAMnjB,EAAQmjB,EAAO7mB,GACrB8mB,EAAU9mB,GAAOme,MAAMpd,QAAQ2C,GAASA,EAAM3B,IAAIlF,GAAMA,EAAG6G,EAC/D,CACA,OAAOojB,CACX,CACA,MAAMC,EAAOA,OAQb,MAAMC,EAAoB,MACpBC,EAAuBC,GAASA,EAAKnY,QAAQiY,EAAmB,IAUtE,SAASG,EAASC,EAAYC,EAAUC,EAAkB,KACtD,IAAIJ,EAAMK,EAAQ,CAAC,EAAGC,EAAe,GAAIC,EAAO,GAEhD,MAAMC,EAAYL,EAASlD,QAAQ,KAC7BwD,EAAUN,EAASlD,QAAQ,IAAKuD,GAAa,EAAIA,EAAY,GAcnE,OAbIA,GAAa,IACbR,EAAOG,EAAS3X,MAAM,EAAGgY,GACzBF,EAAeH,EAAS3X,MAAMgY,EAAY,EAAGC,GAAW,EAAIA,EAAUN,EAAS/pB,QAC/EiqB,EAAQH,EAAWI,IAEnBG,GAAW,IACXT,EAAOA,GAAQG,EAAS3X,MAAM,EAAGiY,GAEjCF,EAAOJ,EAAS3X,MAAMiY,EAASN,EAAS/pB,SAG5C4pB,EAAOU,EAA4B,MAARV,EAAeA,EAAOG,EAAUC,GAEpD,CACHO,SAAUX,GAAQM,GAAgB,KAAOA,EAAeC,EACxDP,OACAK,QACAE,OAER,CAOA,SAASK,EAAaC,EAAgBV,GAClC,MAAME,EAAQF,EAASE,MAAQQ,EAAeV,EAASE,OAAS,GAChE,OAAOF,EAASH,MAAQK,GAAS,KAAOA,GAASF,EAASI,MAAQ,GACtE,CAQA,SAASO,EAAUC,EAAUC,GAEzB,OAAKA,GAASD,EAASxW,cAAchD,WAAWyZ,EAAKzW,eAE9CwW,EAASvY,MAAMwY,EAAK5qB,SAAW,IAD3B2qB,CAEf,CASA,SAASE,EAAoBJ,EAAgBtF,EAAGC,GAC5C,MAAM0F,EAAa3F,EAAE4F,QAAQ/qB,OAAS,EAChCgrB,EAAa5F,EAAE2F,QAAQ/qB,OAAS,EACtC,OAAQ8qB,GAAc,GAClBA,IAAeE,GACfC,EAAkB9F,EAAE4F,QAAQD,GAAa1F,EAAE2F,QAAQC,KACnDE,EAA0B/F,EAAEoE,OAAQnE,EAAEmE,SACtCkB,EAAetF,EAAE8E,SAAWQ,EAAerF,EAAE6E,QAC7C9E,EAAEgF,OAAS/E,EAAE+E,IACrB,CAQA,SAASc,EAAkB9F,EAAGC,GAI1B,OAAQD,EAAEgG,SAAWhG,MAAQC,EAAE+F,SAAW/F,EAC9C,CACA,SAAS8F,EAA0B/F,EAAGC,GAClC,GAAI9gB,OAAOqhB,KAAKR,GAAGnlB,SAAWsE,OAAOqhB,KAAKP,GAAGplB,OACzC,OAAO,EACX,IAAK,MAAM0C,KAAOyiB,EACd,IAAKiG,EAA+BjG,EAAEziB,GAAM0iB,EAAE1iB,IAC1C,OAAO,EAEf,OAAO,CACX,CACA,SAAS0oB,EAA+BjG,EAAGC,GACvC,OAAOvE,MAAMpd,QAAQ0hB,GACfkG,EAAkBlG,EAAGC,GACrBvE,MAAMpd,QAAQ2hB,GACViG,EAAkBjG,EAAGD,GACrBA,IAAMC,CACpB,CAQA,SAASiG,EAAkBlG,EAAGC,GAC1B,OAAOvE,MAAMpd,QAAQ2hB,GACfD,EAAEnlB,SAAWolB,EAAEplB,QAAUmlB,EAAEmG,OAAM,CAACllB,EAAOtG,IAAMsG,IAAUgf,EAAEtlB,KAC9C,IAAbqlB,EAAEnlB,QAAgBmlB,EAAE,KAAOC,CACrC,CAOA,SAASkF,EAAoBiB,EAAIC,GAC7B,GAAID,EAAGpa,WAAW,KACd,OAAOoa,EAKX,IAAKA,EACD,OAAOC,EACX,MAAMC,EAAeD,EAAKnS,MAAM,KAC1BqS,EAAaH,EAAGlS,MAAM,KAC5B,IACIsS,EACAC,EAFAC,EAAWJ,EAAazrB,OAAS,EAGrC,IAAK2rB,EAAa,EAAGA,EAAaD,EAAW1rB,OAAQ2rB,IAGjD,GAFAC,EAAUF,EAAWC,GAEJ,IAAbE,GAA8B,MAAZD,EAAtB,CAEA,GAAgB,OAAZA,EAIA,MAHAC,GAFQ,CAOhB,OAAQJ,EAAarZ,MAAM,EAAGyZ,GAAUzb,KAAK,KACzC,IACAsb,EACKtZ,MAAMuZ,GAAcA,IAAeD,EAAW1rB,OAAS,EAAI,IAC3DoQ,KAAK,IAClB,CAEA,IAAI0b,EAKAC,GAJJ,SAAWD,GACPA,EAAe,OAAS,MACxBA,EAAe,QAAU,MAC5B,EAHD,CAGGA,IAAmBA,EAAiB,CAAC,IAExC,SAAWC,GACPA,EAAoB,QAAU,OAC9BA,EAAoB,WAAa,UACjCA,EAAoB,WAAa,EACpC,CAJD,CAIGA,IAAwBA,EAAsB,CAAC,IAYlD,SAASC,EAAcpB,GACnB,IAAKA,EACD,GAAIzB,EAAW,CAEX,MAAM8C,EAAS9e,SAAS6B,cAAc,QACtC4b,EAAQqB,GAAUA,EAAOC,aAAa,SAAY,IAElDtB,EAAOA,EAAKnZ,QAAQ,kBAAmB,GAC3C,MAEImZ,EAAO,IAUf,MAJgB,MAAZA,EAAK,IAA0B,MAAZA,EAAK,KACxBA,EAAO,IAAMA,GAGVjB,EAAoBiB,EAC/B,CAEA,MAAMuB,EAAiB,UACvB,SAASC,EAAWxB,EAAMb,GACtB,OAAOa,EAAKnZ,QAAQ0a,EAAgB,KAAOpC,CAC/C,CAEA,SAASsC,EAAmBne,EAAIoe,GAC5B,MAAMC,EAAUpf,SAASqf,gBAAgBlP,wBACnCmP,EAASve,EAAGoP,wBAClB,MAAO,CACHoP,SAAUJ,EAAOI,SACjB9O,KAAM6O,EAAO7O,KAAO2O,EAAQ3O,MAAQ0O,EAAO1O,MAAQ,GACnDE,IAAK2O,EAAO3O,IAAMyO,EAAQzO,KAAOwO,EAAOxO,KAAO,GAEvD,CACA,MAAM6O,EAAwBA,KAAA,CAC1B/O,KAAMrD,OAAOqS,YACb9O,IAAKvD,OAAOsS,cAEhB,SAASC,EAAiBjB,GACtB,IAAIkB,EACJ,GAAI,OAAQlB,EAAU,CAClB,MAAMmB,EAAanB,EAAS3d,GACtB+e,EAAqC,kBAAfD,GAA2BA,EAAW7b,WAAW,KAsBxE1R,EAiBL,MAAMyO,EAA2B,kBAAf8e,EACZC,EACI9f,SAAS+f,eAAeF,EAAW5a,MAAM,IACzCjF,SAAS6B,cAAcge,GAC3BA,EACN,IAAK9e,EAGD,OAEJ6e,EAAkBV,EAAmBne,EAAI2d,EAC7C,MAEIkB,EAAkBlB,EAElB,mBAAoB1e,SAASqf,gBAAgB/b,MAC7C8J,OAAO4S,SAASJ,GAEhBxS,OAAO4S,SAAiC,MAAxBJ,EAAgBnP,KAAemP,EAAgBnP,KAAOrD,OAAOqS,YAAoC,MAAvBG,EAAgBjP,IAAciP,EAAgBjP,IAAMvD,OAAOsS,YAE7J,CACA,SAASO,EAAaxD,EAAMyD,GACxB,MAAMxB,EAAWyB,QAAQpR,MAAQoR,QAAQpR,MAAM2P,SAAWwB,GAAS,EACnE,OAAOxB,EAAWjC,CACtB,CACA,MAAM2D,EAAkB,IAAIzqB,IAC5B,SAAS0qB,EAAmB9qB,EAAK+qB,GAC7BF,EAAgB1qB,IAAIH,EAAK+qB,EAC7B,CACA,SAASC,EAAuBhrB,GAC5B,MAAMirB,EAASJ,EAAgB3qB,IAAIF,GAGnC,OADA6qB,EAAgBnsB,OAAOsB,GAChBirB,CACX,CAiBA,IAAIC,EAAqBA,IAAM7D,SAAS8D,SAAW,KAAO9D,SAAS+D,KAKnE,SAASC,EAAsBnD,EAAMb,GACjC,MAAM,SAAEY,EAAQ,OAAEqD,EAAM,KAAE7D,GAASJ,EAE7BM,EAAUO,EAAK/D,QAAQ,KAC7B,GAAIwD,GAAW,EAAG,CACd,IAAI4D,EAAW9D,EAAKpX,SAAS6X,EAAKxY,MAAMiY,IAClCO,EAAKxY,MAAMiY,GAASrqB,OACpB,EACFkuB,EAAe/D,EAAK/X,MAAM6b,GAI9B,MAFwB,MAApBC,EAAa,KACbA,EAAe,IAAMA,GAClBxD,EAAUwD,EAAc,GACnC,CACA,MAAMtE,EAAOc,EAAUC,EAAUC,GACjC,OAAOhB,EAAOoE,EAAS7D,CAC3B,CACA,SAASgE,EAAoBvD,EAAMwD,EAAcpE,EAAiBvY,GAC9D,IAAI4c,EAAY,GACZC,EAAY,GAGZC,EAAa,KACjB,MAAMC,EAAkBA,EAAGtS,YACvB,MAAMqP,EAAKwC,EAAsBnD,EAAMb,UACjCyB,EAAOxB,EAAgB5jB,MACvBqoB,EAAYL,EAAahoB,MAC/B,IAAIinB,EAAQ,EACZ,GAAInR,EAAO,CAIP,GAHA8N,EAAgB5jB,MAAQmlB,EACxB6C,EAAahoB,MAAQ8V,EAEjBqS,GAAcA,IAAe/C,EAE7B,YADA+C,EAAa,MAGjBlB,EAAQoB,EAAYvS,EAAM2P,SAAW4C,EAAU5C,SAAW,CAC9D,MAEIpa,EAAQ8Z,GAQZ8C,EAAUzqB,SAAQ8qB,IACdA,EAAS1E,EAAgB5jB,MAAOolB,EAAM,CAClC6B,QACA5qB,KAAMqpB,EAAe5rB,IACrByuB,UAAWtB,EACLA,EAAQ,EACJtB,EAAoB6C,QACpB7C,EAAoB8C,KACxB9C,EAAoB+C,SAC5B,GACJ,EAEN,SAASC,IACLR,EAAavE,EAAgB5jB,KACjC,CACA,SAAS4oB,EAAO1mB,GAEZ+lB,EAAUjvB,KAAKkJ,GACf,MAAM2mB,EAAWA,KACb,MAAM/vB,EAAQmvB,EAAUxH,QAAQve,GAC5BpJ,GAAS,GACTmvB,EAAUlO,OAAOjhB,EAAO,EAAE,EAGlC,OADAovB,EAAUlvB,KAAK6vB,GACRA,CACX,CACA,SAASC,IACL,MAAM,QAAE5B,GAAY/S,OACf+S,EAAQpR,OAEboR,EAAQ6B,aAAapP,EAAO,CAAC,EAAGuN,EAAQpR,MAAO,CAAEyR,OAAQhB,MAA4B,GACzF,CACA,SAASyC,IACL,IAAK,MAAMH,KAAYX,EACnBW,IACJX,EAAY,GACZ/T,OAAOjH,oBAAoB,WAAYkb,GACvCjU,OAAOjH,oBAAoB,eAAgB4b,EAC/C,CAIA,OAFA3U,OAAOrH,iBAAiB,WAAYsb,GACpCjU,OAAOrH,iBAAiB,eAAgBgc,GACjC,CACHH,iBACAC,SACAI,UAER,CAIA,SAASC,EAAWR,EAAMS,EAASV,EAASW,GAAW,EAAOC,GAAgB,GAC1E,MAAO,CACHX,OACAS,UACAV,UACAW,WACA1D,SAAUtR,OAAO+S,QAAQttB,OACzB2tB,OAAQ6B,EAAgB7C,IAA0B,KAE1D,CACA,SAAS8C,EAA0B7E,GAC/B,MAAM,QAAE0C,EAAO,SAAEvD,GAAaxP,OAExByP,EAAkB,CACpB5jB,MAAO2nB,EAAsBnD,EAAMb,IAEjCqE,EAAe,CAAEhoB,MAAOknB,EAAQpR,OAetC,SAASwT,EAAenE,EAAIrP,EAAOzK,GAU/B,MAAMke,EAAY/E,EAAK/D,QAAQ,KACzB+I,EAAMD,GAAa,GAClB5F,EAAS+D,MAAQ3gB,SAAS6B,cAAc,QACrC4b,EACAA,EAAKxY,MAAMud,IAAcpE,EAC7BqC,IAAuBhD,EAAOW,EACpC,IAGI+B,EAAQ7b,EAAU,eAAiB,aAAayK,EAAO,GAAI0T,GAC3DxB,EAAahoB,MAAQ8V,CACzB,CACA,MAAO2T,GAKCC,QAAQC,MAAMF,GAGlB9F,EAAStY,EAAU,UAAY,UAAUme,EAC7C,CACJ,CACA,SAASne,EAAQ8Z,EAAIyE,GACjB,MAAM9T,EAAQ6D,EAAO,CAAC,EAAGuN,EAAQpR,MAAOmT,EAAWjB,EAAahoB,MAAMyoB,KAEtEtD,EAAI6C,EAAahoB,MAAMwoB,SAAS,GAAOoB,EAAM,CAAEnE,SAAUuC,EAAahoB,MAAMylB,WAC5E6D,EAAenE,EAAIrP,GAAO,GAC1B8N,EAAgB5jB,MAAQmlB,CAC5B,CACA,SAASnsB,EAAKmsB,EAAIyE,GAGd,MAAMC,EAAelQ,EAAO,CAAC,EAI7BqO,EAAahoB,MAAOknB,EAAQpR,MAAO,CAC/B0S,QAASrD,EACToC,OAAQhB,MAOZ+C,EAAeO,EAAaX,QAASW,GAAc,GACnD,MAAM/T,EAAQ6D,EAAO,CAAC,EAAGsP,EAAWrF,EAAgB5jB,MAAOmlB,EAAI,MAAO,CAAEM,SAAUoE,EAAapE,SAAW,GAAKmE,GAC/GN,EAAenE,EAAIrP,GAAO,GAC1B8N,EAAgB5jB,MAAQmlB,CAC5B,CACA,OA1EK6C,EAAahoB,OACdspB,EAAe1F,EAAgB5jB,MAAO,CAClCyoB,KAAM,KACNS,QAAStF,EAAgB5jB,MACzBwoB,QAAS,KAET/C,SAAUyB,EAAQttB,OAAS,EAC3BuvB,UAAU,EAGV5B,OAAQ,OACT,GA+DA,CACH5D,SAAUC,EACV9N,MAAOkS,EACPhvB,OACAqS,UAER,CAMA,SAASye,EAAiBtF,GACtBA,EAAOoB,EAAcpB,GACrB,MAAMuF,EAAoBV,EAA0B7E,GAC9CwF,EAAmBjC,EAAoBvD,EAAMuF,EAAkBjU,MAAOiU,EAAkBpG,SAAUoG,EAAkB1e,SAC1H,SAAS4e,EAAGhD,EAAOiD,GAAmB,GAC7BA,GACDF,EAAiBrB,iBACrBzB,QAAQ+C,GAAGhD,EACf,CACA,MAAMkD,EAAgBxQ,EAAO,CAEzBgK,SAAU,GACVa,OACAyF,KACAjE,WAAYA,EAAWoE,KAAK,KAAM5F,IACnCuF,EAAmBC,GAStB,OARA9rB,OAAOwjB,eAAeyI,EAAe,WAAY,CAC7CvI,YAAY,EACZplB,IAAKA,IAAMutB,EAAkBpG,SAAS3jB,QAE1C9B,OAAOwjB,eAAeyI,EAAe,QAAS,CAC1CvI,YAAY,EACZplB,IAAKA,IAAMutB,EAAkBjU,MAAM9V,QAEhCmqB,CACX,CA+HA,SAASE,EAAgBC,GACrB,MAAwB,kBAAVA,GAAuBA,GAA0B,kBAAVA,CACzD,CACA,SAASC,EAAY1f,GACjB,MAAuB,kBAATA,GAAqC,kBAATA,CAC9C,CAiBA,MAAM2f,EAA4B,CAC9BhH,KAAM,IACN3Y,UAAM9Q,EACNopB,OAAQ,CAAC,EACTU,MAAO,CAAC,EACRE,KAAM,GACNI,SAAU,IACVQ,QAAS,GACT3I,KAAM,CAAC,EACPyO,oBAAgB1wB,GAGd2wB,EAAwCjI,EAA4E,MAK1H,IAAIkI,GACJ,SAAWA,GAKPA,EAAsBA,EAAsB,WAAa,GAAK,UAK9DA,EAAsBA,EAAsB,aAAe,GAAK,YAKhEA,EAAsBA,EAAsB,cAAgB,IAAM,YACrE,EAhBD,CAgBGA,IAA0BA,EAAwB,CAAC,IAqBtD,SAASC,EAAkBvuB,EAAM8mB,GASzB,OAAOxJ,EAAO,IAAIkR,MAAS,CACvBxuB,OACA,CAACquB,IAA0B,GAC5BvH,EAEX,CACA,SAAS2H,EAAoBnB,EAAOttB,GAChC,OAAQstB,aAAiBkB,OACrBH,KAA2Bf,IAClB,MAARttB,MAAmBstB,EAAMttB,KAAOA,GACzC,CAgBA,MAAM0uB,EAAqB,SACrBC,GAA2B,CAC7BC,WAAW,EACXC,QAAQ,EACRhiB,OAAO,EACPC,KAAK,GAGHgiB,GAAiB,sBAQvB,SAASC,GAAeC,EAAUC,GAC9B,MAAMre,EAAU0M,EAAO,CAAC,EAAGqR,GAA0BM,GAE/CC,EAAQ,GAEd,IAAIC,EAAUve,EAAQ/D,MAAQ,IAAM,GAEpC,MAAMqW,EAAO,GACb,IAAK,MAAMiG,KAAW6F,EAAU,CAE5B,MAAMI,EAAgBjG,EAAQ5rB,OAAS,GAAK,CAAC,IAEzCqT,EAAQie,SAAW1F,EAAQ5rB,SAC3B4xB,GAAW,KACf,IAAK,IAAIE,EAAa,EAAGA,EAAalG,EAAQ5rB,OAAQ8xB,IAAc,CAChE,MAAMC,EAAQnG,EAAQkG,GAEtB,IAAIE,EAAkB,IACjB3e,EAAQge,UAAY,IAAgC,GACzD,GAAmB,IAAfU,EAAMtvB,KAEDqvB,IACDF,GAAW,KACfA,GAAWG,EAAM3rB,MAAMqL,QAAQ8f,GAAgB,QAC/CS,GAAmB,QAElB,GAAmB,IAAfD,EAAMtvB,KAAwB,CACnC,MAAM,MAAE2D,EAAK,WAAE6rB,EAAU,SAAEC,EAAQ,OAAEC,GAAWJ,EAChDpM,EAAKvmB,KAAK,CACN6R,KAAM7K,EACN6rB,aACAC,aAEJ,MAAME,EAAKD,GAAkBhB,EAE7B,GAAIiB,IAAOjB,EAAoB,CAC3Ba,GAAmB,GAEnB,IACI,IAAIK,OAAQ,IAAGD,KACnB,CACA,MAAOvC,GACH,MAAM,IAAIoB,MAAO,oCAAmC7qB,OAAWgsB,OAC3DvC,EAAIyC,QACZ,CACJ,CAEA,IAAIC,EAAaN,EAAc,OAAMG,YAAaA,QAAY,IAAGA,KAE5DN,IACDS,EAGIL,GAAYtG,EAAQ5rB,OAAS,EACtB,OAAMuyB,KACP,IAAMA,GAChBL,IACAK,GAAc,KAClBX,GAAWW,EACXP,GAAmB,GACfE,IACAF,IAAoB,GACpBC,IACAD,IAAoB,IACb,OAAPI,IACAJ,IAAoB,GAC5B,CACAH,EAAczyB,KAAK4yB,EACvB,CAGAL,EAAMvyB,KAAKyyB,EACf,CAEA,GAAIxe,EAAQie,QAAUje,EAAQ9D,IAAK,CAC/B,MAAMzP,EAAI6xB,EAAM3xB,OAAS,EACzB2xB,EAAM7xB,GAAG6xB,EAAM7xB,GAAGE,OAAS,IAAM,iBACrC,CAEKqT,EAAQie,SACTM,GAAW,MACXve,EAAQ9D,IACRqiB,GAAW,IAENve,EAAQie,SACbM,GAAW,WACf,MAAMQ,EAAK,IAAIC,OAAOT,EAASve,EAAQge,UAAY,GAAK,KACxD,SAASmB,EAAM5I,GACX,MAAM1V,EAAQ0V,EAAK1V,MAAMke,GACnB7I,EAAS,CAAC,EAChB,IAAKrV,EACD,OAAO,KACX,IAAK,IAAIpU,EAAI,EAAGA,EAAIoU,EAAMlU,OAAQF,IAAK,CACnC,MAAMsG,EAAQ8N,EAAMpU,IAAM,GACpB4C,EAAMijB,EAAK7lB,EAAI,GACrBypB,EAAO7mB,EAAIuO,MAAQ7K,GAAS1D,EAAIuvB,WAAa7rB,EAAMiT,MAAM,KAAOjT,CACpE,CACA,OAAOmjB,CACX,CACA,SAASpD,EAAUoD,GACf,IAAIK,EAAO,GAEP6I,GAAuB,EAC3B,IAAK,MAAM7G,KAAW6F,EAAU,CACvBgB,GAAyB7I,EAAK8I,SAAS,OACxC9I,GAAQ,KACZ6I,GAAuB,EACvB,IAAK,MAAMV,KAASnG,EAChB,GAAmB,IAAfmG,EAAMtvB,KACNmnB,GAAQmI,EAAM3rB,WAEb,GAAmB,IAAf2rB,EAAMtvB,KAAwB,CACnC,MAAM,MAAE2D,EAAK,WAAE6rB,EAAU,SAAEC,GAAaH,EAClCY,EAAQvsB,KAASmjB,EAASA,EAAOnjB,GAAS,GAChD,GAAIya,MAAMpd,QAAQkvB,KAAWV,EACzB,MAAM,IAAIhB,MAAO,mBAAkB7qB,8DACvC,MAAMmI,EAAOsS,MAAMpd,QAAQkvB,GAASA,EAAMviB,KAAK,KAAOuiB,EACtD,IAAKpkB,EAAM,CACP,IAAI2jB,EAaA,MAAM,IAAIjB,MAAO,2BAA0B7qB,MAVvCwlB,EAAQ5rB,OAAS,IAEb4pB,EAAK8I,SAAS,KACd9I,EAAOA,EAAKxX,MAAM,GAAI,GAGtBqgB,GAAuB,EAKvC,CACA7I,GAAQrb,CACZ,CAER,CACA,OAAOqb,CACX,CACA,MAAO,CACHwI,KACAT,QACAhM,OACA6M,QACArM,YAER,CAUA,SAASyM,GAAkBzN,EAAGC,GAC1B,IAAItlB,EAAI,EACR,MAAOA,EAAIqlB,EAAEnlB,QAAUF,EAAIslB,EAAEplB,OAAQ,CACjC,MAAM6yB,EAAOzN,EAAEtlB,GAAKqlB,EAAErlB,GAEtB,GAAI+yB,EACA,OAAOA,EACX/yB,GACJ,CAGA,OAAIqlB,EAAEnlB,OAASolB,EAAEplB,OACO,IAAbmlB,EAAEnlB,QAAyB,KAATmlB,EAAE,IACpB,EACD,EAEDA,EAAEnlB,OAASolB,EAAEplB,OACE,IAAbolB,EAAEplB,QAAyB,KAATolB,EAAE,GACrB,GACC,EAEJ,CACX,CAQA,SAAS0N,GAAuB3N,EAAGC,GAC/B,IAAItlB,EAAI,EACR,MAAMizB,EAAS5N,EAAEwM,MACXqB,EAAS5N,EAAEuM,MACjB,MAAO7xB,EAAIizB,EAAO/yB,QAAUF,EAAIkzB,EAAOhzB,OAAQ,CAC3C,MAAMizB,EAAOL,GAAkBG,EAAOjzB,GAAIkzB,EAAOlzB,IAEjD,GAAImzB,EACA,OAAOA,EACXnzB,GACJ,CAEA,OAAOkzB,EAAOhzB,OAAS+yB,EAAO/yB,MAOlC,CAEA,MAAMkzB,GAAa,CACfzwB,KAAM,EACN2D,MAAO,IAEL+sB,GAAiB,eAIvB,SAASC,GAAaxJ,GAClB,IAAKA,EACD,MAAO,CAAC,IACZ,GAAa,MAATA,EACA,MAAO,CAAC,CAACsJ,KACb,IAAKtJ,EAAKzY,WAAW,KACjB,MAAM,IAAI8f,MAEH,iBAAgBrH,MAG3B,SAASyJ,EAAMf,GACX,MAAM,IAAIrB,MAAO,QAAO/U,OAAWoX,OAAYhB,IACnD,CACA,IAAIpW,EAAQ,EACRqX,EAAgBrX,EACpB,MAAMsX,EAAS,GAGf,IAAI5H,EACJ,SAAS6H,IACD7H,GACA4H,EAAOp0B,KAAKwsB,GAChBA,EAAU,EACd,CAEA,IAEI8H,EAFA5zB,EAAI,EAIJwzB,EAAS,GAETK,EAAW,GACf,SAASC,IACAN,IAES,IAAVpX,EACA0P,EAAQxsB,KAAK,CACTqD,KAAM,EACN2D,MAAOktB,IAGI,IAAVpX,GACK,IAAVA,GACU,IAAVA,GACI0P,EAAQ5rB,OAAS,IAAe,MAAT0zB,GAAyB,MAATA,IACvCL,EAAO,uBAAsBC,iDACjC1H,EAAQxsB,KAAK,CACTqD,KAAM,EACN2D,MAAOktB,EACPnB,OAAQwB,EACR1B,WAAqB,MAATyB,GAAyB,MAATA,EAC5BxB,SAAmB,MAATwB,GAAyB,MAATA,KAI9BL,EAAM,mCAEVC,EAAS,GACb,CACA,SAASO,IACLP,GAAUI,CACd,CACA,MAAO5zB,EAAI8pB,EAAK5pB,OAEZ,GADA0zB,EAAO9J,EAAK9pB,KACC,OAAT4zB,GAA2B,IAAVxX,EAKrB,OAAQA,GACJ,KAAK,EACY,MAATwX,GACIJ,GACAM,IAEJH,KAEc,MAATC,GACLE,IACA1X,EAAQ,GAGR2X,IAEJ,MACJ,KAAK,EACDA,IACA3X,EAAQqX,EACR,MACJ,KAAK,EACY,MAATG,EACAxX,EAAQ,EAEHiX,GAAe5hB,KAAKmiB,GACzBG,KAGAD,IACA1X,EAAQ,EAEK,MAATwX,GAAyB,MAATA,GAAyB,MAATA,GAChC5zB,KAER,MACJ,KAAK,EAMY,MAAT4zB,EAEqC,MAAjCC,EAASA,EAAS3zB,OAAS,GAC3B2zB,EAAWA,EAASvhB,MAAM,GAAI,GAAKshB,EAEnCxX,EAAQ,EAGZyX,GAAYD,EAEhB,MACJ,KAAK,EAEDE,IACA1X,EAAQ,EAEK,MAATwX,GAAyB,MAATA,GAAyB,MAATA,GAChC5zB,IACJ6zB,EAAW,GACX,MACJ,QACIN,EAAM,iBACN,WAnEJE,EAAgBrX,EAChBA,EAAQ,EA0EhB,OALc,IAAVA,GACAmX,EAAO,uCAAsCC,MACjDM,IACAH,IAEOD,CACX,CAEA,SAASM,GAAyBC,EAAQ90B,EAAQoU,GAC9C,MAAM2gB,EAASxC,GAAe4B,GAAaW,EAAOnK,MAAOvW,GAUzD,MAAM4gB,EAAUlU,EAAOiU,EAAQ,CAC3BD,SACA90B,SAEAmd,SAAU,GACV8X,MAAO,KASX,OAPIj1B,IAIKg1B,EAAQF,OAAO5I,WAAalsB,EAAO80B,OAAO5I,SAC3ClsB,EAAOmd,SAAShd,KAAK60B,GAEtBA,CACX,CASA,SAASE,GAAoBC,EAAQC,GAEjC,MAAMC,EAAW,GACXC,EAAa,IAAIzxB,IAEvB,SAAS0xB,EAAiBvjB,GACtB,OAAOsjB,EAAW3xB,IAAIqO,EAC1B,CACA,SAASwjB,EAASV,EAAQ90B,EAAQy1B,GAE9B,MAAMC,GAAaD,EACbE,EAAuBC,GAAqBd,GAElDa,EAAqBzJ,QAAUuJ,GAAkBA,EAAeX,OAChE,MAAM1gB,EAAUyhB,GAAaT,EAAeN,GAEtCgB,EAAoB,CACtBH,GAEJ,GAAI,UAAWb,EAAQ,CACnB,MAAMiB,EAAkC,kBAAjBjB,EAAOG,MAAqB,CAACH,EAAOG,OAASH,EAAOG,MAC3E,IAAK,MAAMA,KAASc,EAChBD,EAAkB31B,KAAK2gB,EAAO,CAAC,EAAG6U,EAAsB,CAGpDK,WAAYP,EACNA,EAAeX,OAAOkB,WACtBL,EAAqBK,WAC3BrL,KAAMsK,EAEN/I,QAASuJ,EACHA,EAAeX,OACfa,IAKlB,CACA,IAAIX,EACAiB,EACJ,IAAK,MAAMC,KAAoBJ,EAAmB,CAC9C,MAAM,KAAEnL,GAASuL,EAIjB,GAAIl2B,GAAsB,MAAZ2qB,EAAK,GAAY,CAC3B,MAAMwL,EAAan2B,EAAO80B,OAAOnK,KAC3ByL,EAAwD,MAAtCD,EAAWA,EAAWp1B,OAAS,GAAa,GAAK,IACzEm1B,EAAiBvL,KACb3qB,EAAO80B,OAAOnK,MAAQA,GAAQyL,EAAkBzL,EACxD,CA2BA,GArBAqK,EAAUH,GAAyBqB,EAAkBl2B,EAAQoU,GAKzDqhB,EACAA,EAAeR,MAAM90B,KAAK60B,IAO1BiB,EAAkBA,GAAmBjB,EACjCiB,IAAoBjB,GACpBiB,EAAgBhB,MAAM90B,KAAK60B,GAG3BU,GAAaZ,EAAO9iB,OAASqkB,GAAcrB,IAC3CsB,EAAYxB,EAAO9iB,OAEvB,aAAc2jB,EAAsB,CACpC,MAAMxY,EAAWwY,EAAqBxY,SACtC,IAAK,IAAItc,EAAI,EAAGA,EAAIsc,EAASpc,OAAQF,IACjC20B,EAASrY,EAAStc,GAAIm0B,EAASS,GAAkBA,EAAetY,SAAStc,GAEjF,CAGA40B,EAAiBA,GAAkBT,EAKnCuB,EAAcvB,EAClB,CACA,OAAOiB,EACD,KAEEK,EAAYL,EAAgB,EAE9BzL,CACV,CACA,SAAS8L,EAAYE,GACjB,GAAI9E,EAAY8E,GAAa,CACzB,MAAMxB,EAAUM,EAAW3xB,IAAI6yB,GAC3BxB,IACAM,EAAWnzB,OAAOq0B,GAClBnB,EAASnU,OAAOmU,EAASzN,QAAQoN,GAAU,GAC3CA,EAAQ7X,SAASxY,QAAQ2xB,GACzBtB,EAAQC,MAAMtwB,QAAQ2xB,GAE9B,KACK,CACD,MAAMr2B,EAAQo1B,EAASzN,QAAQ4O,GAC3Bv2B,GAAS,IACTo1B,EAASnU,OAAOjhB,EAAO,GACnBu2B,EAAW1B,OAAO9iB,MAClBsjB,EAAWnzB,OAAOq0B,EAAW1B,OAAO9iB,MACxCwkB,EAAWrZ,SAASxY,QAAQ2xB,GAC5BE,EAAWvB,MAAMtwB,QAAQ2xB,GAEjC,CACJ,CACA,SAASG,IACL,OAAOpB,CACX,CACA,SAASkB,EAAcvB,GACnB,IAAIn0B,EAAI,EACR,MAAOA,EAAIw0B,EAASt0B,QAChB8yB,GAAuBmB,EAASK,EAASx0B,KAAO,IAG/Cm0B,EAAQF,OAAOnK,OAAS0K,EAASx0B,GAAGi0B,OAAOnK,OACvC+L,GAAgB1B,EAASK,EAASx0B,KACvCA,IACJw0B,EAASnU,OAAOrgB,EAAG,EAAGm0B,GAElBA,EAAQF,OAAO9iB,OAASqkB,GAAcrB,IACtCM,EAAW1xB,IAAIoxB,EAAQF,OAAO9iB,KAAMgjB,EAC5C,CACA,SAAS1f,EAAQwV,EAAUC,GACvB,IAAIiK,EAEArK,EACA3Y,EAFAsY,EAAS,CAAC,EAGd,GAAI,SAAUQ,GAAYA,EAAS9Y,KAAM,CAErC,GADAgjB,EAAUM,EAAW3xB,IAAImnB,EAAS9Y,OAC7BgjB,EACD,MAAMjD,EAAkB,EAA2B,CAC/CjH,aAER9Y,EAAOgjB,EAAQF,OAAO9iB,KACtBsY,EAASxJ,EAET6V,GAAmB5L,EAAgBT,OAGnC0K,EAAQtO,KAAKnhB,QAAOqxB,IAAMA,EAAE3D,WAAUztB,KAAIoxB,GAAKA,EAAE5kB,QAAQ8Y,EAASR,QAElEK,EAAOqK,EAAQ9N,UAAUoD,EAC7B,MACK,GAAI,SAAUQ,EAGfH,EAAOG,EAASH,KAIhBqK,EAAUK,EAASwB,MAAK7hB,GAAKA,EAAEme,GAAG7gB,KAAKqY,KAEnCqK,IAGA1K,EAAS0K,EAAQzB,MAAM5I,GACvB3Y,EAAOgjB,EAAQF,OAAO9iB,UAIzB,CAKD,GAHAgjB,EAAUjK,EAAgB/Y,KACpBsjB,EAAW3xB,IAAIonB,EAAgB/Y,MAC/BqjB,EAASwB,MAAK7hB,GAAKA,EAAEme,GAAG7gB,KAAKyY,EAAgBJ,SAC9CqK,EACD,MAAMjD,EAAkB,EAA2B,CAC/CjH,WACAC,oBAER/Y,EAAOgjB,EAAQF,OAAO9iB,KAGtBsY,EAASxJ,EAAO,CAAC,EAAGiK,EAAgBT,OAAQQ,EAASR,QACrDK,EAAOqK,EAAQ9N,UAAUoD,EAC7B,CACA,MAAMwB,EAAU,GAChB,IAAIgL,EAAgB9B,EACpB,MAAO8B,EAEHhL,EAAQiL,QAAQD,EAAchC,QAC9BgC,EAAgBA,EAAc92B,OAElC,MAAO,CACHgS,OACA2Y,OACAL,SACAwB,UACA3I,KAAM6T,GAAgBlL,GAE9B,CAGA,OA5MAsJ,EAAgBS,GAAa,CAAExD,QAAQ,EAAO/hB,KAAK,EAAM8hB,WAAW,GAASgD,GA2M7ED,EAAOxwB,SAAQ8sB,GAAS+D,EAAS/D,KAC1B,CAAE+D,WAAUlgB,UAASghB,cAAaG,YAAWlB,mBACxD,CACA,SAASoB,GAAmBrM,EAAQ5D,GAChC,MAAM6D,EAAY,CAAC,EACnB,IAAK,MAAM9mB,KAAOijB,EACVjjB,KAAO6mB,IACPC,EAAU9mB,GAAO6mB,EAAO7mB,IAEhC,OAAO8mB,CACX,CAOA,SAASqL,GAAqBd,GAC1B,MAAO,CACHnK,KAAMmK,EAAOnK,KACbsM,SAAUnC,EAAOmC,SACjBjlB,KAAM8iB,EAAO9iB,KACbmR,KAAM2R,EAAO3R,MAAQ,CAAC,EACtB+I,aAAShrB,EACT6iB,YAAa+Q,EAAO/Q,YACpB/U,MAAOkoB,GAAqBpC,GAC5B3X,SAAU2X,EAAO3X,UAAY,GAC7Bga,UAAW,CAAC,EACZC,YAAa,IAAI31B,IACjB41B,aAAc,IAAI51B,IAClB61B,eAAgB,CAAC,EACjBtB,WAAY,eAAgBlB,EACtBA,EAAOkB,YAAc,CAAC,EACtB,CAAEze,QAASud,EAAOnQ,WAEhC,CAMA,SAASuS,GAAqBpC,GAC1B,MAAMyC,EAAc,CAAC,EAEfvoB,EAAQ8lB,EAAO9lB,QAAS,EAC9B,GAAI,cAAe8lB,EACfyC,EAAYhgB,QAAUvI,OAKtB,IAAK,MAAMgD,KAAQ8iB,EAAOkB,WACtBuB,EAAYvlB,GAAyB,mBAAVhD,EAAsBA,EAAQA,EAAMgD,GAEvE,OAAOulB,CACX,CAKA,SAASlB,GAAcvB,GACnB,MAAOA,EAAQ,CACX,GAAIA,EAAOA,OAAO5I,QACd,OAAO,EACX4I,EAASA,EAAO90B,MACpB,CACA,OAAO,CACX,CAMA,SAASg3B,GAAgBlL,GACrB,OAAOA,EAAQxE,QAAO,CAACnE,EAAM2R,IAAWhU,EAAOqC,EAAM2R,EAAO3R,OAAO,CAAC,EACxE,CACA,SAAS0S,GAAa2B,EAAUC,GAC5B,MAAMrjB,EAAU,CAAC,EACjB,IAAK,MAAM3Q,KAAO+zB,EACdpjB,EAAQ3Q,GAAOA,KAAOg0B,EAAiBA,EAAeh0B,GAAO+zB,EAAS/zB,GAE1E,OAAO2Q,CACX,CA4BA,SAASsiB,GAAgB5B,EAAQ90B,GAC7B,OAAOA,EAAOmd,SAAS7E,MAAK/J,GAASA,IAAUumB,GAAU4B,GAAgB5B,EAAQvmB,IACrF,CAmBA,MAAMmpB,GAAU,KACVC,GAAe,KACfC,GAAW,MACXC,GAAW,KACXC,GAAQ,MACRC,GAAU,MAeVC,GAAsB,OACtBC,GAAuB,OACvBC,GAAe,OACfC,GAAkB,OAClBC,GAAoB,OACpBC,GAAc,OACdC,GAAqB,OACrBC,GAAe,OASrB,SAASC,GAAalpB,GAClB,OAAOmpB,UAAU,GAAKnpB,GACjBkD,QAAQ6lB,GAAa,KACrB7lB,QAAQwlB,GAAqB,KAC7BxlB,QAAQylB,GAAsB,IACvC,CAOA,SAASS,GAAWppB,GAChB,OAAOkpB,GAAalpB,GACfkD,QAAQ4lB,GAAmB,KAC3B5lB,QAAQ8lB,GAAoB,KAC5B9lB,QAAQ0lB,GAAc,IAC/B,CAQA,SAASS,GAAiBrpB,GACtB,OAAQkpB,GAAalpB,GAEhBkD,QAAQulB,GAAS,OACjBvlB,QAAQ+lB,GAAc,KACtB/lB,QAAQklB,GAAS,OACjBllB,QAAQmlB,GAAc,OACtBnlB,QAAQ2lB,GAAiB,KACzB3lB,QAAQ4lB,GAAmB,KAC3B5lB,QAAQ8lB,GAAoB,KAC5B9lB,QAAQ0lB,GAAc,IAC/B,CAMA,SAASU,GAAetpB,GACpB,OAAOqpB,GAAiBrpB,GAAMkD,QAAQqlB,GAAU,MACpD,CAOA,SAASgB,GAAWvpB,GAChB,OAAOkpB,GAAalpB,GAAMkD,QAAQklB,GAAS,OAAOllB,QAAQslB,GAAO,MACrE,CAUA,SAASgB,GAAYxpB,GACjB,OAAe,MAARA,EAAe,GAAKupB,GAAWvpB,GAAMkD,QAAQolB,GAAU,MAClE,CAQA,SAASmB,GAAOzpB,GACZ,IACI,OAAO0pB,mBAAmB,GAAK1pB,EACnC,CACA,MAAOshB,GAEP,CACA,MAAO,GAAKthB,CAChB,CAWA,SAASub,GAAWkE,GAChB,MAAM/D,EAAQ,CAAC,EAGf,GAAe,KAAX+D,GAA4B,MAAXA,EACjB,OAAO/D,EACX,MAAMiO,EAA6B,MAAdlK,EAAO,GACtBmK,GAAgBD,EAAelK,EAAO5b,MAAM,GAAK4b,GAAQ3U,MAAM,KACrE,IAAK,IAAIvZ,EAAI,EAAGA,EAAIq4B,EAAan4B,SAAUF,EAAG,CAE1C,MAAMs4B,EAAcD,EAAar4B,GAAG2R,QAAQulB,GAAS,KAE/CqB,EAAQD,EAAYvR,QAAQ,KAC5BnkB,EAAMs1B,GAAOK,EAAQ,EAAID,EAAcA,EAAYhmB,MAAM,EAAGimB,IAC5DjyB,EAAQiyB,EAAQ,EAAI,KAAOL,GAAOI,EAAYhmB,MAAMimB,EAAQ,IAClE,GAAI31B,KAAOunB,EAAO,CAEd,IAAIqO,EAAerO,EAAMvnB,GACpBme,MAAMpd,QAAQ60B,KACfA,EAAerO,EAAMvnB,GAAO,CAAC41B,IAEjCA,EAAal5B,KAAKgH,EACtB,MAEI6jB,EAAMvnB,GAAO0D,CAErB,CACA,OAAO6jB,CACX,CAUA,SAASQ,GAAeR,GACpB,IAAI+D,EAAS,GACb,IAAK,IAAItrB,KAAOunB,EAAO,CACnB,MAAM7jB,EAAQ6jB,EAAMvnB,GAEpB,GADAA,EAAMm1B,GAAen1B,GACR,MAAT0D,EAAe,MAEDjG,IAAViG,IACA4nB,IAAWA,EAAOhuB,OAAS,IAAM,IAAM0C,GAE3C,QACJ,CAEA,MAAMc,EAASqd,MAAMpd,QAAQ2C,GACvBA,EAAM3B,KAAI+C,GAAKA,GAAKowB,GAAiBpwB,KACrC,CAACpB,GAASwxB,GAAiBxxB,IACjC5C,EAAOI,SAAQwC,SAGGjG,IAAViG,IAEA4nB,IAAWA,EAAOhuB,OAAS,IAAM,IAAM0C,EAC1B,MAAT0D,IACA4nB,GAAU,IAAM5nB,GACxB,GAER,CACA,OAAO4nB,CACX,CASA,SAASuK,GAAetO,GACpB,MAAMuO,EAAkB,CAAC,EACzB,IAAK,MAAM91B,KAAOunB,EAAO,CACrB,MAAM7jB,EAAQ6jB,EAAMvnB,QACNvC,IAAViG,IACAoyB,EAAgB91B,GAAOme,MAAMpd,QAAQ2C,GAC/BA,EAAM3B,KAAI+C,GAAW,MAALA,EAAY,KAAO,GAAKA,IAC/B,MAATpB,EACIA,EACA,GAAKA,EAEvB,CACA,OAAOoyB,CACX,CAKA,SAASC,KACL,IAAIC,EAAW,GACf,SAASv1B,EAAIiQ,GAET,OADAslB,EAASt5B,KAAKgU,GACP,KACH,MAAMtT,EAAI44B,EAAS7R,QAAQzT,GACvBtT,GAAK,GACL44B,EAASvY,OAAOrgB,EAAG,EAAE,CAEjC,CACA,SAAS64B,IACLD,EAAW,EACf,CACA,MAAO,CACHv1B,MACAihB,KAAMA,IAAMsU,EACZC,QAER,CAyDA,SAASC,GAAiBjW,EAAO4I,EAAIC,EAAMuI,EAAQ9iB,GAE/C,MAAM4nB,EAAqB9E,IAEtBA,EAAOwC,eAAetlB,GAAQ8iB,EAAOwC,eAAetlB,IAAS,IAClE,MAAO,IAAM,IAAIqD,SAAQ,CAACC,EAASukB,KAC/B,MAAM9vB,EAAQ+vB,KACI,IAAVA,EACAD,EAAO9H,EAAkB,EAA4B,CACjDxF,OACAD,QAECwN,aAAiB9H,MACtB6H,EAAOC,GAEFtI,EAAgBsI,GACrBD,EAAO9H,EAAkB,EAAmC,CACxDxF,KAAMD,EACNA,GAAIwN,MAIJF,GAEA9E,EAAOwC,eAAetlB,KAAU4nB,GACf,oBAAVE,GACPF,EAAmBz5B,KAAK25B,GAC5BxkB,IACJ,EAGEykB,EAAcrW,EAAM5a,KAAKgsB,GAAUA,EAAOqC,UAAUnlB,GAAOsa,EAAIC,EAAsFxiB,GAC3J,IAAIiwB,EAAY3kB,QAAQC,QAAQykB,GAC5BrW,EAAM3iB,OAAS,IACfi5B,EAAYA,EAAUxkB,KAAKzL,IAuB/BiwB,EAAUhS,OAAM4I,GAAOiJ,EAAOjJ,IAAK,GAE3C,CAYA,SAASqJ,GAAwBnO,EAASoO,EAAW5N,EAAIC,GACrD,MAAM4N,EAAS,GACf,IAAK,MAAMrF,KAAUhJ,EACjB,IAAK,MAAM9Z,KAAQ8iB,EAAOkB,WAAY,CAClC,IAAIoE,EAAetF,EAAOkB,WAAWhkB,GAiCrC,GAAkB,qBAAdkoB,GAAqCpF,EAAOqC,UAAUnlB,GAE1D,GAAIqoB,GAAiBD,GAAe,CAEhC,MAAMhmB,EAAUgmB,EAAa3Q,WAAa2Q,EACpC1W,EAAQtP,EAAQ8lB,GACtBxW,GAASyW,EAAOh6B,KAAKw5B,GAAiBjW,EAAO4I,EAAIC,EAAMuI,EAAQ9iB,GACnE,KACK,CAED,IAAIsoB,EAAmBF,IAClB55B,EAIL25B,EAAOh6B,MAAK,IAAMm6B,EAAiB9kB,MAAK+kB,IACpC,IAAKA,EACD,OAAOllB,QAAQwkB,OAAO,IAAI7H,MAAO,+BAA8BhgB,UAAa8iB,EAAOnK,UACvF,MAAM6P,EAAoBrQ,EAAWoQ,GAC/BA,EAAShjB,QACTgjB,EAENzF,EAAOkB,WAAWhkB,GAAQwoB,EAE1B,MAAMpmB,EAAUomB,EAAkB/Q,WAAa+Q,EACzC9W,EAAQtP,EAAQ8lB,GACtB,OAAOxW,GAASiW,GAAiBjW,EAAO4I,EAAIC,EAAMuI,EAAQ9iB,EAA1C2nB,EAAiD,KAEzE,CACJ,CAEJ,OAAOQ,CACX,CAMA,SAASE,GAAiB1V,GACtB,MAA6B,kBAAdA,GACX,gBAAiBA,GACjB,UAAWA,GACX,cAAeA,CACvB,CAIA,SAAS8V,GAAQzrB,GACb,MAAM0rB,GAASC,EAAAA,EAAAA,IAAO5Q,GAChB6Q,GAAeD,EAAAA,EAAAA,IAAO3Q,GACtByH,GAAQ1sB,EAAAA,EAAAA,KAAS,IAAM21B,EAAOplB,SAAQzI,EAAAA,EAAAA,IAAMmC,EAAMsd,OAClDuO,GAAoB91B,EAAAA,EAAAA,KAAS,KAC/B,MAAM,QAAE+mB,GAAY2F,EAAMtqB,OACpB,OAAEpG,GAAW+qB,EACbgP,EAAehP,EAAQ/qB,EAAS,GAChCg6B,EAAiBH,EAAa9O,QACpC,IAAKgP,IAAiBC,EAAeh6B,OACjC,OAAQ,EACZ,MAAMd,EAAQ86B,EAAejU,UAAUkF,EAAkBuF,KAAK,KAAMuJ,IACpE,GAAI76B,GAAS,EACT,OAAOA,EAEX,MAAM+6B,EAAmBC,GAAgBnP,EAAQ/qB,EAAS,IAC1D,OAEAA,EAAS,GAILk6B,GAAgBH,KAAkBE,GAElCD,EAAeA,EAAeh6B,OAAS,GAAG4pB,OAASqQ,EACjDD,EAAejU,UAAUkF,EAAkBuF,KAAK,KAAMzF,EAAQ/qB,EAAS,KACvEd,CAAM,IAEVi7B,GAAWn2B,EAAAA,EAAAA,KAAS,IAAM81B,EAAkB1zB,OAAS,GACvDg0B,GAAeP,EAAatQ,OAAQmH,EAAMtqB,MAAMmjB,UAC9C8Q,GAAgBr2B,EAAAA,EAAAA,KAAS,IAAM81B,EAAkB1zB,OAAS,GAC5D0zB,EAAkB1zB,QAAUyzB,EAAa9O,QAAQ/qB,OAAS,GAC1DkrB,EAA0B2O,EAAatQ,OAAQmH,EAAMtqB,MAAMmjB,UAC/D,SAAS+Q,EAASrnB,EAAI,CAAC,GACnB,OAAIsnB,GAAWtnB,GACJ0mB,GAAO7tB,EAAAA,EAAAA,IAAMmC,EAAMwD,SAAW,UAAY,SAAQ3F,EAAAA,EAAAA,IAAMmC,EAAMsd,KAEnEtE,MAAMwC,GAELnV,QAAQC,SACnB,CAqBA,MAAO,CACHmc,QACA8J,MAAMx2B,EAAAA,EAAAA,KAAS,IAAM0sB,EAAMtqB,MAAMo0B,OACjCL,WACAE,gBACAC,WAER,CACA,MAAMG,IAA+BC,EAAAA,EAAAA,IAAgB,CACjDzpB,KAAM,aACNhD,MAAO,CACHsd,GAAI,CACA9oB,KAAM,CAAC4T,OAAQ/R,QACfq2B,UAAU,GAEdlpB,QAAS8E,QACTqkB,YAAavkB,OAEbwkB,iBAAkBxkB,OAClBykB,OAAQvkB,QACRwkB,iBAAkB,CACdt4B,KAAM4T,OACNG,QAAS,SAGjBkjB,WACA1d,MAAM/N,GAAO,MAAE8H,IACX,MAAMilB,GAAOz0B,EAAAA,EAAAA,IAASmzB,GAAQzrB,KACxB,QAAEoF,IAAYumB,EAAAA,EAAAA,IAAO5Q,GACrBiS,GAAUj3B,EAAAA,EAAAA,KAAS,KAAM,CAC3B,CAACk3B,GAAajtB,EAAM2sB,YAAavnB,EAAQ8nB,gBAAiB,uBAAwBH,EAAKb,SAMvF,CAACe,GAAajtB,EAAM4sB,iBAAkBxnB,EAAQ+nB,qBAAsB,6BAA8BJ,EAAKX,kBAE3G,MAAO,KACH,MAAMje,EAAWrG,EAAMS,SAAWT,EAAMS,QAAQwkB,GAChD,OAAO/sB,EAAM6sB,OACP1e,GACApG,EAAAA,EAAAA,GAAE,IAAK,CACL,eAAgBglB,EAAKX,cACfpsB,EAAM8sB,iBACN,KACNP,KAAMQ,EAAKR,KAGXa,QAASL,EAAKV,SACdgB,MAAOL,EAAQ70B,OAChBgW,EAAS,CAExB,IAOEmf,GAAad,GACnB,SAASF,GAAWtnB,GAEhB,KAAIA,EAAEoP,SAAWpP,EAAEkP,QAAUlP,EAAE8O,SAAW9O,EAAEgP,YAGxChP,EAAEuoB,wBAGWr7B,IAAb8S,EAAEqP,QAAqC,IAAbrP,EAAEqP,QAAhC,CAIA,GAAIrP,EAAE4O,eAAiB5O,EAAE4O,cAAcqK,aAAc,CAEjD,MAAM1pB,EAASyQ,EAAE4O,cAAcqK,aAAa,UAC5C,GAAI,cAAc3a,KAAK/O,GACnB,MACR,CAIA,OAFIyQ,EAAE2O,gBACF3O,EAAE2O,kBACC,CAZG,CAad,CACA,SAASwY,GAAeqB,EAAOC,GAC3B,IAAK,MAAMh5B,KAAOg5B,EAAO,CACrB,MAAMC,EAAaD,EAAMh5B,GACnBk5B,EAAaH,EAAM/4B,GACzB,GAA0B,kBAAfi5B,GACP,GAAIA,IAAeC,EACf,OAAO,OAGX,IAAK/a,MAAMpd,QAAQm4B,IACfA,EAAW57B,SAAW27B,EAAW37B,QACjC27B,EAAWpkB,MAAK,CAACnR,EAAOtG,IAAMsG,IAAUw1B,EAAW97B,KACnD,OAAO,CAEnB,CACA,OAAO,CACX,CAKA,SAASo6B,GAAgBnG,GACrB,OAAOA,EAAUA,EAAO5I,QAAU4I,EAAO5I,QAAQvB,KAAOmK,EAAOnK,KAAQ,EAC3E,CAOA,MAAMsR,GAAeA,CAACW,EAAWC,EAAaC,IAA8B,MAAbF,EACzDA,EACe,MAAfC,EACIA,EACAC,EAEJC,IAA+BtB,EAAAA,EAAAA,IAAgB,CACjDzpB,KAAM,aAENgrB,cAAc,EACdhuB,MAAO,CACHgD,KAAM,CACFxO,KAAM4T,OACNG,QAAS,WAEbka,MAAOpsB,QAEX0X,MAAM/N,GAAO,MAAEiuB,EAAK,MAAEnmB,IAElB,MAAMomB,GAAgBvC,EAAAA,EAAAA,IAAO1Q,GACvBkT,GAAiBp4B,EAAAA,EAAAA,KAAS,IAAMiK,EAAMyiB,OAASyL,EAAc/1B,QAC7Di2B,GAAQzC,EAAAA,EAAAA,IAAO7Q,EAAc,GAC7BuT,GAAkBt4B,EAAAA,EAAAA,KAAS,IAAMo4B,EAAeh2B,MAAM2kB,QAAQsR,MACpEE,EAAAA,EAAAA,IAAQxT,EAAcsT,EAAQ,IAC9BE,EAAAA,EAAAA,IAAQzT,EAAiBwT,IACzBC,EAAAA,EAAAA,IAAQrT,EAAuBkT,GAC/B,MAAMI,GAAUvxB,EAAAA,EAAAA,MAiChB,OA9BAwxB,EAAAA,EAAAA,KAAM,IAAM,CAACD,EAAQp2B,MAAOk2B,EAAgBl2B,MAAO6H,EAAMgD,QAAO,EAAEiB,EAAUqZ,EAAIta,IAAQyrB,EAAalR,EAAMmR,MAEnGpR,IAGAA,EAAG6K,UAAUnlB,GAAQiB,EAOjBsZ,GAAQA,IAASD,GAAMrZ,GAAYA,IAAawqB,IAC3CnR,EAAG8K,YAAYruB,OAChBujB,EAAG8K,YAAc7K,EAAK6K,aAErB9K,EAAG+K,aAAatuB,OACjBujB,EAAG+K,aAAe9K,EAAK8K,iBAK/BpkB,IACAqZ,GAGEC,GAASP,EAAkBM,EAAIC,IAAUkR,IAC1CnR,EAAGgL,eAAetlB,IAAS,IAAIrN,SAAQ0E,GAAYA,EAAS4J,IACjE,GACD,CAAE0qB,MAAO,SACL,KACH,MAAMlM,EAAQ0L,EAAeh2B,MACvBy2B,EAAeP,EAAgBl2B,MAC/B02B,EAAgBD,GAAgBA,EAAa5H,WAAWhnB,EAAMgD,MAG9D8rB,EAAc9uB,EAAMgD,KAC1B,IAAK6rB,EACD,OAAOE,GAAcjnB,EAAMS,QAAS,CAAEymB,UAAWH,EAAepM,UAGpE,MAAMwM,EAAmBL,EAAa5uB,MAAMA,EAAMgD,MAC5CksB,EAAaD,GACQ,IAArBA,EACIxM,EAAMnH,OACsB,oBAArB2T,EACHA,EAAiBxM,GACjBwM,EACR,KACAE,EAAmB7gB,IAEjBA,EAAMqH,UAAUyZ,cAChBR,EAAazG,UAAU2G,GAAe,KAC1C,EAEEnZ,GAAY5N,EAAAA,EAAAA,GAAE8mB,EAAe/c,EAAO,CAAC,EAAGod,EAAYjB,EAAO,CAC7DkB,mBACAnyB,IAAKuxB,KAoBT,OAGAQ,GAAcjnB,EAAMS,QAAS,CAAEymB,UAAWrZ,EAAW8M,WACjD9M,CAAU,CAEtB,IAEJ,SAASoZ,GAAcM,EAAMtN,GACzB,IAAKsN,EACD,OAAO,KACX,MAAMC,EAAcD,EAAKtN,GACzB,OAA8B,IAAvBuN,EAAYv9B,OAAeu9B,EAAY,GAAKA,CACvD,CAMA,MAAMC,GAAaxB,GAkcnB,SAASyB,GAAapqB,GAClB,MAAM4gB,EAAUE,GAAoB9gB,EAAQ+gB,OAAQ/gB,GAC9CqqB,EAAerqB,EAAQyW,YAAcA,GACrC6T,EAAmBtqB,EAAQoX,gBAAkBA,GAC7C8F,EAAgBld,EAAQia,QAI9B,MAAMsQ,EAAenF,KACfoF,EAAsBpF,KACtBqF,EAAcrF,KACdoB,GAAetuB,EAAAA,EAAAA,IAAWqlB,GAChC,IAAImN,EAAkBnN,EAElBzH,GAAa9V,EAAQ2qB,gBAAkB,sBAAuB1Q,UAC9DA,QAAQ2Q,kBAAoB,UAEhC,MAAMC,EAAkB5U,EAAckH,KAAK,MAAM2N,GAAc,GAAKA,IAC9DC,EAAe9U,EAAckH,KAAK,KAAMuH,IACxCsG,EAEN/U,EAAckH,KAAK,KAAMwH,IACzB,SAASvD,EAAS6J,EAAe5N,GAC7B,IAAIzxB,EACA80B,EAQJ,OAPIpD,EAAY2N,IACZr/B,EAASg1B,EAAQO,iBAAiB8J,GAClCvK,EAASrD,GAGTqD,EAASuK,EAENrK,EAAQQ,SAASV,EAAQ90B,EACpC,CACA,SAASs2B,EAAYtkB,GACjB,MAAMstB,EAAgBtK,EAAQO,iBAAiBvjB,GAC3CstB,GACAtK,EAAQsB,YAAYgJ,EAK5B,CACA,SAAS7I,IACL,OAAOzB,EAAQyB,YAAYjxB,KAAI+5B,GAAgBA,EAAazK,QAChE,CACA,SAAS0K,EAASxtB,GACd,QAASgjB,EAAQO,iBAAiBvjB,EACtC,CACA,SAASsD,EAAQmqB,EAAa1U,GAI1B,GADAA,EAAkBjK,EAAO,CAAC,EAAGiK,GAAmB6P,EAAazzB,OAClC,kBAAhBs4B,EAA0B,CACjC,MAAMC,EAAqB9U,EAAS6T,EAAcgB,EAAa1U,EAAgBJ,MACzEiT,EAAe5I,EAAQ1f,QAAQ,CAAEqV,KAAM+U,EAAmB/U,MAAQI,GAClEwQ,EAAOjK,EAAcnE,WAAWuS,EAAmBpU,UASzD,OAAOxK,EAAO4e,EAAoB9B,EAAc,CAC5CtT,OAAQ8U,EAAaxB,EAAatT,QAClCY,KAAM6N,GAAO2G,EAAmBxU,MAChC0G,oBAAgB1wB,EAChBq6B,QAER,CACA,IAAIoE,EAEJ,GAAI,SAAUF,EAUVE,EAAkB7e,EAAO,CAAC,EAAG2e,EAAa,CACtC9U,KAAMC,EAAS6T,EAAcgB,EAAY9U,KAAMI,EAAgBJ,MAAMA,WAGxE,CAED,MAAMiV,EAAe9e,EAAO,CAAC,EAAG2e,EAAYnV,QAC5C,IAAK,MAAM7mB,KAAOm8B,EACW,MAArBA,EAAan8B,WACNm8B,EAAan8B,GAI5Bk8B,EAAkB7e,EAAO,CAAC,EAAG2e,EAAa,CACtCnV,OAAQ6U,EAAaM,EAAYnV,UAIrCS,EAAgBT,OAAS6U,EAAapU,EAAgBT,OAC1D,CACA,MAAMsT,EAAe5I,EAAQ1f,QAAQqqB,EAAiB5U,GAChDG,EAAOuU,EAAYvU,MAAQ,GAMjC0S,EAAatT,OAAS2U,EAAgBG,EAAaxB,EAAatT,SAChE,MAAMgB,EAAWC,EAAamT,EAAkB5d,EAAO,CAAC,EAAG2e,EAAa,CACpEvU,KAAMwN,GAAWxN,GACjBP,KAAMiT,EAAajT,QAEjB4Q,EAAOjK,EAAcnE,WAAW7B,GAStC,OAAOxK,EAAO,CACVwK,WAGAJ,OACAF,MAMA0T,IAAqBlT,GACf8N,GAAemG,EAAYzU,OAC1ByU,EAAYzU,OAAS,CAAC,GAC9B4S,EAAc,CACbhM,oBAAgB1wB,EAChBq6B,QAER,CACA,SAASsE,EAAiBvT,GACtB,MAAqB,kBAAPA,EACR1B,EAAS6T,EAAcnS,EAAIsO,EAAazzB,MAAMwjB,MAC9C7J,EAAO,CAAC,EAAGwL,EACrB,CACA,SAASwT,EAAwBxT,EAAIC,GACjC,GAAIuS,IAAoBxS,EACpB,OAAOyF,EAAkB,EAA8B,CACnDxF,OACAD,MAGZ,CACA,SAASnsB,EAAKmsB,GACV,OAAOyT,EAAiBzT,EAC5B,CACA,SAAS9Z,EAAQ8Z,GACb,OAAOnsB,EAAK2gB,EAAO+e,EAAiBvT,GAAK,CAAE9Z,SAAS,IACxD,CACA,SAASwtB,EAAqB1T,GAC1B,MAAM2T,EAAc3T,EAAGR,QAAQQ,EAAGR,QAAQ/qB,OAAS,GACnD,GAAIk/B,GAAeA,EAAYhJ,SAAU,CACrC,MAAM,SAAEA,GAAagJ,EACrB,IAAIC,EAAwC,oBAAbjJ,EAA0BA,EAAS3K,GAAM2K,EAiBxE,MAhBiC,kBAAtBiJ,IACPA,EACIA,EAAkBpsB,SAAS,MAAQosB,EAAkBpsB,SAAS,KACvDosB,EAAoBL,EAAiBK,GAEpC,CAAEvV,KAAMuV,GAGpBA,EAAkB5V,OAAS,CAAC,GAQzBxJ,EAAO,CACVkK,MAAOsB,EAAGtB,MACVE,KAAMoB,EAAGpB,KACTZ,OAAQgC,EAAGhC,QACZ4V,EACP,CACJ,CACA,SAASH,EAAiBzT,EAAIsF,GAC1B,MAAMuO,EAAkBrB,EAAkBxpB,EAAQgX,GAC5CC,EAAOqO,EAAazzB,MACpB4pB,EAAOzE,EAAGrP,MACVmjB,EAAQ9T,EAAG8T,MAEX5tB,GAAyB,IAAf8Z,EAAG9Z,QACb6tB,EAAiBL,EAAqBG,GAC5C,GAAIE,EACA,OAAON,EAAiBjf,EAAO+e,EAAiBQ,GAAiB,CAC7DpjB,MAAO8T,EACPqP,QACA5tB,YAGJof,GAAkBuO,GAEtB,MAAMG,EAAaH,EAEnB,IAAII,EAYJ,OAbAD,EAAW1O,eAAiBA,GAEvBwO,GAASxU,EAAoB8S,EAAkBnS,EAAM4T,KACtDI,EAAUxO,EAAkB,GAAgC,CAAEzF,GAAIgU,EAAY/T,SAE9EiU,GAAajU,EAAMA,GAGnB,GAGA,KAEIgU,EAAUlrB,QAAQC,QAAQirB,GAAWlF,EAASiF,EAAY/T,IAC7DvE,OAAO8I,GAAUmB,EAAoBnB,GAElCmB,EAAoBnB,EAAO,GACrBA,EACA2P,GAAY3P,GAElB4P,GAAa5P,EAAOwP,EAAY/T,KACnC/W,MAAM+qB,IACP,GAAIA,GACA,GAAItO,EAAoBsO,EAAS,GAc7B,OAAOR,EAEPjf,EAAO+e,EAAiBU,EAAQjU,IAAK,CACjCrP,MAAO8T,EACPqP,QACA5tB,YAGJof,GAAkB0O,QAKtBC,EAAUI,EAAmBL,EAAY/T,GAAM,EAAM/Z,EAASue,GAGlE,OADA6P,EAAiBN,EAAY/T,EAAMgU,GAC5BA,CAAO,GAEtB,CAMA,SAASM,EAAiCvU,EAAIC,GAC1C,MAAMuE,EAAQgP,EAAwBxT,EAAIC,GAC1C,OAAOuE,EAAQzb,QAAQwkB,OAAO/I,GAASzb,QAAQC,SACnD,CAEA,SAAS+lB,EAAS/O,EAAIC,GAClB,IAAI4N,EACJ,MAAO2G,EAAgBC,EAAiBC,GAAmBC,GAAuB3U,EAAIC,GAEtF4N,EAASF,GAAwB6G,EAAeI,UAAW,mBAAoB5U,EAAIC,GAEnF,IAAK,MAAMuI,KAAUgM,EACjBhM,EAAOsC,YAAYzyB,SAAQ+e,IACvByW,EAAOh6B,KAAKw5B,GAAiBjW,EAAO4I,EAAIC,GAAM,IAGtD,MAAM4U,EAA0BN,EAAiCtP,KAAK,KAAMjF,EAAIC,GAGhF,OAFA4N,EAAOh6B,KAAKghC,GAEJC,GAAcjH,GACjB3kB,MAAK,KAEN2kB,EAAS,GACT,IAAK,MAAMzW,KAASib,EAAaxZ,OAC7BgV,EAAOh6B,KAAKw5B,GAAiBjW,EAAO4I,EAAIC,IAG5C,OADA4N,EAAOh6B,KAAKghC,GACLC,GAAcjH,EAAO,IAE3B3kB,MAAK,KAEN2kB,EAASF,GAAwB8G,EAAiB,oBAAqBzU,EAAIC,GAC3E,IAAK,MAAMuI,KAAUiM,EACjBjM,EAAOuC,aAAa1yB,SAAQ+e,IACxByW,EAAOh6B,KAAKw5B,GAAiBjW,EAAO4I,EAAIC,GAAM,IAKtD,OAFA4N,EAAOh6B,KAAKghC,GAELC,GAAcjH,EAAO,IAE3B3kB,MAAK,KAEN2kB,EAAS,GACT,IAAK,MAAMrF,KAAUxI,EAAGR,QAEpB,GAAIgJ,EAAO/Q,cAAgBwI,EAAKT,QAAQhY,SAASghB,GAC7C,GAAIlT,MAAMpd,QAAQswB,EAAO/Q,aACrB,IAAK,MAAMA,KAAe+Q,EAAO/Q,YAC7BoW,EAAOh6B,KAAKw5B,GAAiB5V,EAAauI,EAAIC,SAGlD4N,EAAOh6B,KAAKw5B,GAAiB7E,EAAO/Q,YAAauI,EAAIC,IAMjE,OAFA4N,EAAOh6B,KAAKghC,GAELC,GAAcjH,EAAO,IAE3B3kB,MAAK,KAGN8W,EAAGR,QAAQnnB,SAAQmwB,GAAWA,EAAOwC,eAAiB,CAAC,IAEvD6C,EAASF,GAAwB+G,EAAiB,mBAAoB1U,EAAIC,GAC1E4N,EAAOh6B,KAAKghC,GAELC,GAAcjH,MAEpB3kB,MAAK,KAEN2kB,EAAS,GACT,IAAK,MAAMzW,KAASkb,EAAoBzZ,OACpCgV,EAAOh6B,KAAKw5B,GAAiBjW,EAAO4I,EAAIC,IAG5C,OADA4N,EAAOh6B,KAAKghC,GACLC,GAAcjH,EAAO,IAG3BnS,OAAM4I,GAAOqB,EAAoBrB,EAAK,GACrCA,EACAvb,QAAQwkB,OAAOjJ,IACzB,CACA,SAASgQ,EAAiBtU,EAAIC,EAAMgU,GAGhC,IAAK,MAAM7c,KAASmb,EAAY1Z,OAC5BzB,EAAM4I,EAAIC,EAAMgU,EACxB,CAMA,SAASI,EAAmBL,EAAY/T,EAAM8U,EAAQ7uB,EAASue,GAE3D,MAAMD,EAAQgP,EAAwBQ,EAAY/T,GAClD,GAAIuE,EACA,OAAOA,EAEX,MAAMwQ,EAAoB/U,IAASoF,EAC7B1U,EAASiN,EAAiBmE,QAAQpR,MAAb,CAAC,EAGxBokB,IAGI7uB,GAAW8uB,EACXhQ,EAAc9e,QAAQ8tB,EAAWhV,SAAUxK,EAAO,CAC9C4N,OAAQ4S,GAAqBrkB,GAASA,EAAMyR,QAC7CqC,IAEHO,EAAcnxB,KAAKmgC,EAAWhV,SAAUyF,IAGhD6J,EAAazzB,MAAQm5B,EACrBE,GAAaF,EAAY/T,EAAM8U,EAAQC,GACvCb,IACJ,CACA,IAAIc,EAEJ,SAASC,IACLD,EAAwBjQ,EAAcvB,QAAO,CAACzD,EAAImV,EAAOC,KAErD,MAAMpB,EAAahrB,EAAQgX,GAIrB+T,EAAiBL,EAAqBM,GAC5C,GAAID,EAEA,YADAN,EAAiBjf,EAAOuf,EAAgB,CAAE7tB,SAAS,IAAS8tB,GAAYtY,MAAMwC,GAGlFsU,EAAkBwB,EAClB,MAAM/T,EAAOqO,EAAazzB,MAEtB+iB,GACAqE,EAAmBJ,EAAa5B,EAAKjB,SAAUoW,EAAKtT,OAAQV,KAEhE2N,EAASiF,EAAY/T,GAChBvE,OAAO8I,GACJmB,EAAoBnB,EAAO,IACpBA,EAEPmB,EAAoBnB,EAAO,IAU3BiP,EAAiBjP,EAAMxE,GAAIgU,GAGtB9qB,MAAK+qB,IAIFtO,EAAoBsO,EAAS,MAE5BmB,EAAKtT,OACNsT,EAAKl+B,OAASqpB,EAAe5rB,KAC7BqwB,EAAcF,IAAI,GAAG,EACzB,IAECpJ,MAAMwC,GAEJnV,QAAQwkB,WAGf6H,EAAKtT,OACLkD,EAAcF,IAAIsQ,EAAKtT,OAAO,GAE3BsS,GAAa5P,EAAOwP,EAAY/T,MAEtC/W,MAAM+qB,IACPA,EACIA,GACII,EAEAL,EAAY/T,GAAM,GAEtBgU,IACImB,EAAKtT,MACLkD,EAAcF,IAAIsQ,EAAKtT,OAAO,GAEzBsT,EAAKl+B,OAASqpB,EAAe5rB,KAClCgxB,EAAoBsO,EAAS,KAG7BjP,EAAcF,IAAI,GAAG,IAG7BwP,EAAiBN,EAAY/T,EAAMgU,EAAQ,IAE1CvY,MAAMwC,EAAK,GAExB,CAEA,IAEImX,EAFAC,EAAgBpI,KAChBqI,GAAgBrI,KAUpB,SAASkH,GAAa5P,EAAOxE,EAAIC,GAC7BkU,GAAY3P,GACZ,MAAM3L,EAAO0c,GAAc1c,OAU3B,OATIA,EAAKpkB,OACLokB,EAAKxgB,SAAQwP,GAAWA,EAAQ2c,EAAOxE,EAAIC,KAM3CsE,QAAQC,MAAMA,GAEXzb,QAAQwkB,OAAO/I,EAC1B,CACA,SAASgR,KACL,OAAIH,GAAS/G,EAAazzB,QAAUwqB,EACzBtc,QAAQC,UACZ,IAAID,SAAQ,CAACC,EAASukB,KACzB+H,EAAc19B,IAAI,CAACoR,EAASukB,GAAQ,GAE5C,CACA,SAAS4G,GAAY7P,GAUjB,OATK+Q,IAEDA,GAAS/Q,EACT4Q,IACAI,EACKzc,OACAxgB,SAAQ,EAAE2Q,EAASukB,KAAajJ,EAAMiJ,EAAOjJ,GAAOtb,MACzDssB,EAAclI,SAEX9I,CACX,CAEA,SAAS4P,GAAalU,EAAIC,EAAM8U,EAAQC,GACpC,MAAM,eAAEvC,GAAmB3qB,EAC3B,IAAK8V,IAAc6U,EACf,OAAO1pB,QAAQC,UACnB,MAAMkZ,GAAmB6S,GAAU5S,EAAuBN,EAAa7B,EAAGhB,SAAU,MAC9EgW,IAAsBD,IACpBhT,QAAQpR,OACRoR,QAAQpR,MAAMyR,QAClB,KACJ,OAAOqT,EAAAA,EAAAA,MACFvsB,MAAK,IAAMupB,EAAezS,EAAIC,EAAMiC,KACpChZ,MAAKoX,GAAYA,GAAYiB,EAAiBjB,KAC9C5E,OAAM4I,GAAO8P,GAAa9P,EAAKtE,EAAIC,IAC5C,CACA,MAAM6E,GAAMhD,GAAUkD,EAAcF,GAAGhD,GACvC,IAAI4T,GACJ,MAAMC,GAAgB,IAAIxgC,IACpBi5B,GAAS,CACXE,eACApF,WACAc,cACAkJ,WACA/I,YACAnhB,UACAlB,UACAjU,OACAqS,UACA4e,MACAxB,KAAMA,IAAMwB,IAAI,GAChBzB,QAASA,IAAMyB,GAAG,GAClB8Q,WAAYvD,EAAaz6B,IACzBi+B,cAAevD,EAAoB16B,IACnCk+B,UAAWvD,EAAY36B,IACvBm+B,QAASR,GAAc39B,IACvB49B,WACAQ,QAAQ/d,GACJ,MAAMmW,EAAS96B,KACf2kB,EAAII,UAAU,aAAc2X,IAC5B/X,EAAII,UAAU,aAAc4Z,IAC5Bha,EAAIge,OAAOC,iBAAiBC,QAAU/H,EACtCr1B,OAAOwjB,eAAetE,EAAIge,OAAOC,iBAAkB,SAAU,CACzDzZ,YAAY,EACZplB,IAAKA,KAAMkJ,EAAAA,EAAAA,IAAM+tB,KAKjB1Q,IAGC8X,IACDpH,EAAazzB,QAAUwqB,IAEvBqQ,IAAU,EACV7hC,EAAKmxB,EAAcxG,UAAU9C,OAAM4I,IAC1BpwB,CACDkiC,KAGZ,MAAMC,EAAgB,CAAC,EACvB,IAAK,MAAMl/B,KAAOkuB,EAEdgR,EAAcl/B,IAAOsB,EAAAA,EAAAA,KAAS,IAAM61B,EAAazzB,MAAM1D,KAE3D8gB,EAAI+Y,QAAQvT,EAAW2Q,GACvBnW,EAAI+Y,QAAQtT,GAAkB1iB,EAAAA,EAAAA,IAASq7B,IACvCpe,EAAI+Y,QAAQrT,EAAuB2Q,GACnC,MAAMgI,EAAare,EAAIse,QACvBZ,GAAc/9B,IAAIqgB,GAClBA,EAAIse,QAAU,WACVZ,GAAc9/B,OAAOoiB,GAEjB0d,GAAcl5B,KAAO,IAErB+1B,EAAkBnN,EAClB4P,GAAyBA,IACzB3G,EAAazzB,MAAQwqB,EACrBqQ,IAAU,EACVL,GAAQ,GAEZiB,GACJ,CAIJ,GAEJ,OAAOlI,EACX,CACA,SAAS0G,GAAcjH,GACnB,OAAOA,EAAO7S,QAAO,CAACwb,EAASpf,IAAUof,EAAQttB,MAAK,IAAMkO,OAAUrO,QAAQC,UAClF,CACA,SAAS2rB,GAAuB3U,EAAIC,GAChC,MAAMuU,EAAiB,GACjBC,EAAkB,GAClBC,EAAkB,GAClB+B,EAAM/mB,KAAKC,IAAIsQ,EAAKT,QAAQ/qB,OAAQurB,EAAGR,QAAQ/qB,QACrD,IAAK,IAAIF,EAAI,EAAGA,EAAIkiC,EAAKliC,IAAK,CAC1B,MAAMmiC,EAAazW,EAAKT,QAAQjrB,GAC5BmiC,IACI1W,EAAGR,QAAQ+K,MAAK/B,GAAU9I,EAAkB8I,EAAQkO,KACpDjC,EAAgB5gC,KAAK6iC,GAErBlC,EAAe3gC,KAAK6iC,IAE5B,MAAMC,EAAW3W,EAAGR,QAAQjrB,GACxBoiC,IAEK1W,EAAKT,QAAQ+K,MAAK/B,GAAU9I,EAAkB8I,EAAQmO,MACvDjC,EAAgB7gC,KAAK8iC,GAGjC,CACA,MAAO,CAACnC,EAAgBC,EAAiBC,EAC7C,C,oBC/2GA,SAAUhtB,EAAEkvB,GAAqDC,EAAO5Z,QAAQ2Z,GAAwH,EAAxM,CAA0MtjC,GAAK,WAAW,OAAO,SAASoU,GAAG,SAASkvB,EAAE/2B,GAAG,GAAGxK,EAAEwK,GAAG,OAAOxK,EAAEwK,GAAGod,QAAQ,IAAIrD,EAAEvkB,EAAEwK,GAAG,CAACtL,EAAEsL,EAAErL,GAAE,EAAGyoB,QAAQ,CAAC,GAAG,OAAOvV,EAAE7H,GAAGrD,KAAKod,EAAEqD,QAAQrD,EAAEA,EAAEqD,QAAQ2Z,GAAGhd,EAAEplB,GAAE,EAAGolB,EAAEqD,OAAO,CAAC,IAAI5nB,EAAE,CAAC,EAAE,OAAOuhC,EAAEluB,EAAEhB,EAAEkvB,EAAE7oB,EAAE1Y,EAAEuhC,EAAEriC,EAAE,SAASmT,GAAG,OAAOA,CAAC,EAAEkvB,EAAE5mB,EAAE,SAAStI,EAAErS,EAAEwK,GAAG+2B,EAAEphB,EAAE9N,EAAErS,IAAI0D,OAAOwjB,eAAe7U,EAAErS,EAAE,CAACmnB,cAAa,EAAGC,YAAW,EAAGplB,IAAIwI,GAAG,EAAE+2B,EAAEvhC,EAAE,SAASqS,GAAG,IAAIrS,EAAEqS,GAAGA,EAAEoW,WAAW,WAAW,OAAOpW,EAAEuD,OAAO,EAAE,WAAW,OAAOvD,CAAC,EAAE,OAAOkvB,EAAE5mB,EAAE3a,EAAE,IAAIA,GAAGA,CAAC,EAAEuhC,EAAEphB,EAAE,SAAS9N,EAAEkvB,GAAG,OAAO79B,OAAOwc,UAAUvb,eAAewC,KAAKkL,EAAEkvB,EAAE,EAAEA,EAAE9tB,EAAE,IAAI8tB,EAAEA,EAAE1mB,EAAE,GAAG,CAA5e,CAA8e,CAAC,SAASxI,EAAEkvB,GAAGlvB,EAAEuV,QAAQ,CAAC,IAAI,CAACoJ,QAAQ,MAAMyQ,EAAE,CAACzQ,QAAQ,eAAe0Q,EAAE,CAAC1Q,QAAQ,YAAY2Q,EAAE,CAAC3Q,QAAQ,WAAWhV,UAAU,SAAS3J,GAAG,OAAOA,EAAEuvB,mBAAmB,GAAGrd,EAAE,CAACyM,QAAQ,WAAWhV,UAAU,SAAS3J,GAAG,OAAOA,EAAEwvB,mBAAmB,GAAG,IAAI,CAACC,QAAO,GAAI,EAAE,SAASzvB,EAAEkvB,EAAEvhC,GAAG,aAAa,SAASwK,EAAE6H,GAAG,IAAIkvB,EAAEh1B,SAASw1B,YAAY,SAAS,OAAOR,EAAES,UAAU3vB,GAAE,GAAG,GAAIkvB,CAAC,CAAC,IAAIhd,EAAEvkB,EAAE,GAAGmgB,EAAEngB,EAAE,GAAGd,EAAEc,EAAEA,EAAEmgB,GAAGohB,EAAEhd,EAAE,SAASlS,EAAEkvB,GAAG,IAAIphB,EAAEohB,EAAE/7B,MAAM,IAAIya,MAAMpd,QAAQsd,IAAI,iBAAiBA,KAAKA,EAAE,CAAC8hB,KAAK9hB,EAAEyS,OAAO1zB,EAAEqlB,IAAI,UAAUlS,EAAEH,QAAQ0vB,oBAAoB,CAAC,IAAIM,EAAE7vB,EAAE8vB,qBAAqB,SAAS,GAAG,IAAID,EAAE9iC,OAAO,MAAM,IAAIixB,MAAM,4CAA4C6R,EAAE9iC,QAAQiT,EAAE6vB,EAAE,EAAE,CAAC7vB,EAAE+vB,QAAQ,SAASb,GAAG,GAAGA,EAAEc,UAAU,CAAC,IAAInjC,EAAEmT,EAAEiwB,aAAaJ,EAAE7vB,EAAE7M,MAAMtG,EAAE,GAAG,IAAImT,EAAE7M,MAAMxF,EAAEd,EAAEqlB,EAAEA,EAANvkB,CAASqS,EAAE7M,MAAM2a,EAAE8hB,MAAK,EAAG9hB,EAAEyS,QAAQ1zB,EAAEmT,EAAE7M,MAAMpG,QAAQiT,EAAE7M,MAAMshB,OAAO5nB,EAAE,KAAKgjC,GAAGhjC,IAAImT,IAAI9F,SAASmS,gBAAgBrM,EAAEkwB,kBAAkBrjC,EAAEA,GAAGia,YAAW,WAAW9G,EAAEkwB,kBAAkBrjC,EAAEA,EAAE,GAAE,IAAImT,EAAEuL,cAAcpT,EAAE,SAAS,CAAC,EAAE,IAAIqQ,EAAE7a,EAAEd,EAAEqlB,EAAEA,EAANvkB,CAASqS,EAAE7M,MAAM2a,EAAE8hB,MAAK,EAAG9hB,EAAEyS,QAAQ/X,IAAIxI,EAAE7M,QAAQ6M,EAAE7M,MAAMqV,EAAExI,EAAEuL,cAAcpT,EAAE,UAAU,CAAC,EAAE,SAAS6H,EAAEkvB,EAAEvhC,GAAG,aAAa,IAAIwK,EAAExK,EAAE,GAAGukB,EAAEvkB,EAAE,GAAGuhC,EAAEhd,EAAE,SAASlS,EAAEkvB,GAAG,IAAIphB,IAAIqiB,UAAUpjC,OAAO,QAAG,IAASojC,UAAU,KAAKA,UAAU,GAAGtjC,EAAEsjC,UAAU,GAAG,OAAOviB,MAAMpd,QAAQ0+B,GAAGvhC,EAAEd,EAAEqlB,EAAEA,EAANvkB,CAASwK,EAAE+Z,EAAEgd,EAAEriC,EAAfc,CAAkBqS,EAAEkvB,EAAEphB,EAAEjhB,GAAGc,EAAEd,EAAEsL,EAAE+Z,EAANvkB,CAASqS,EAAEkvB,EAAEphB,EAAEjhB,EAAE,CAAC,EAAE,SAASmT,EAAEkvB,EAAEvhC,GAAG,aAAa,SAASwK,EAAE6H,GAAGA,EAAE2Q,UAAUnI,EAAE0J,EAAElU,KAAKwK,EAAE0J,GAAGlS,EAAEowB,UAAU,OAAOvjC,EAAEqlB,EAAE,CAAC7gB,OAAOwjB,eAAeqa,EAAE,aAAa,CAAC/7B,OAAM,IAAK,IAAI+e,EAAEvkB,EAAE,GAAGmgB,EAAEngB,EAAEA,EAAEukB,GAAGrlB,EAAEc,EAAE,GAAGkiC,EAAEliC,EAAE,GAAG6a,EAAE7a,EAAEA,EAAEkiC,GAAGliC,EAAE2a,EAAE4mB,EAAE,WAAU,WAAW,OAAO1mB,EAAE0J,CAAC,IAAGvkB,EAAE2a,EAAE4mB,EAAE,QAAO,WAAW,OAAOriC,EAAEqlB,CAAC,IAAGvkB,EAAE2a,EAAE4mB,EAAE,UAAS,WAAW,OAAOphB,EAAEoE,CAAC,IAAGvkB,EAAE2a,EAAE4mB,EAAE,WAAU,WAAW,OAAO7oB,CAAC,IAAG,IAAIA,EAAE,SAAS6oB,EAAE3rB,QAAQpL,EAAE,oBAAoBmP,QAAQA,OAAO+oB,KAAK/oB,OAAO+oB,IAAIC,IAAIn4B,EAAE,EAAE,SAAS6H,EAAEkvB,EAAEvhC,GAAG,aAAa0D,OAAOwjB,eAAeqa,EAAE,aAAa,CAAC/7B,OAAM,IAAK,IAAIgF,EAAExK,EAAE,GAAGukB,EAAEvkB,EAAE,GAAGmgB,EAAEngB,EAAEA,EAAEukB,GAAGrlB,EAAEc,EAAE,GAAGuhC,EAAE3rB,QAAQ,CAACvF,KAAK,UAAUhD,MAAM,CAAC7H,MAAM,CAACiQ,OAAO1S,QAAQk/B,KAAK,CAACpgC,KAAK,CAAC4T,OAAOwK,OAAO8Z,UAAS,GAAI6I,OAAO,CAAC/gC,KAAK8T,QAAQC,SAAQ,GAAIgd,OAAO,CAAC/wB,KAAK6B,OAAOkS,QAAQ,WAAW,OAAOuK,EAAEoE,CAAC,IAAIse,WAAW,CAACZ,KAAKz3B,EAAE+Z,GAAG6K,KAAK,WAAW,MAAM,CAAC0T,UAAU,KAAK5yB,QAAQjS,KAAKuH,MAAM,EAAEq2B,MAAM,CAACr2B,MAAM,SAAS6M,GAAGA,IAAIpU,KAAK6kC,YAAY7kC,KAAKiS,QAAQmC,EAAE,EAAEuwB,OAAO,WAAW3kC,KAAK8kC,QAAQ9kC,KAAKiS,QAAQ,GAAG9M,SAAS,CAACw9B,OAAO,WAAW,MAAM,CAACqB,KAAKhkC,KAAKgkC,KAAKrP,OAAO30B,KAAK20B,OAAOgQ,OAAO3kC,KAAK2kC,OAAO,GAAGI,QAAQ,CAACC,QAAQ,SAAS5wB,GAAGA,EAAEgwB,WAAWpkC,KAAK8kC,QAAQ1wB,EAAEzQ,OAAO4D,MAAM,EAAEu9B,QAAQ,SAAS1wB,GAAGpU,KAAKiS,QAAQmC,EAAMA,EAAErS,EAAEd,EAAEA,EAAEqlB,EAANvkB,CAASqS,EAAEpU,KAAKgkC,KAAKhkC,KAAK2kC,OAAO3kC,KAAK20B,QAAQvgB,IAAIpU,KAAK6kC,YAAY7kC,KAAK6kC,UAAUzwB,EAAEpU,KAAKilC,MAAM,QAAQ7wB,GAAG,GAAG,EAAE,SAASA,EAAEkvB,EAAEvhC,GAAG,aAAa,SAASwK,EAAE6H,EAAEkvB,EAAEvhC,GAAG,OAAOuhC,EAAEA,EAAE4B,MAAK,SAAS9wB,EAAEkvB,GAAG,OAAOlvB,EAAEjT,OAAOmiC,EAAEniC,MAAM,IAAG,SAASoL,EAAE+Z,GAAG,IAAI,IAAIpE,IAAIqiB,UAAUpjC,OAAO,QAAG,IAASojC,UAAU,KAAKA,UAAU,GAAGtjC,EAAE,EAAEA,EAAEqiC,EAAEniC,QAAQ,CAAC,IAAI8iC,EAAEX,EAAEriC,GAAGA,IAAI,IAAI2b,EAAE0mB,EAAEriC,GAAG,KAAK2b,GAAGxI,EAAE7H,EAAEqQ,GAAE,EAAG7a,GAAGZ,OAAO8iC,EAAE9iC,QAAQ,OAAOiT,EAAE7H,EAAE03B,EAAE/hB,EAAEngB,EAAE,CAAC,MAAM,EAAE,CAAC,CAACuhC,EAAEhd,EAAE/Z,CAAC,EAAE,SAAS6H,EAAEkvB,EAAEvhC,GAAG,aAAa,SAASwK,EAAE6H,EAAEkvB,GAAG,IAAIvhC,IAAIwiC,UAAUpjC,OAAO,QAAG,IAASojC,UAAU,KAAKA,UAAU,GAAGh4B,EAAEg4B,UAAU,GAAGnwB,EAAEA,GAAG,GAAGkvB,EAAEA,GAAG,GAAG,IAAI,IAAIhd,EAAE,EAAEpE,EAAE,EAAEjhB,EAAE,GAAGqlB,EAAEgd,EAAEniC,QAAQ+gB,EAAE9N,EAAEjT,QAAQ,CAAC,IAAI8iC,EAAEX,EAAEhd,GAAG1J,EAAErQ,EAAE03B,GAAGxpB,EAAErG,EAAE8N,GAAGtF,IAAIA,EAAEinB,QAAQjnB,EAAEmW,QAAQrgB,KAAK+H,KAAKxZ,GAAG2b,EAAEmB,UAAUnB,EAAEmB,UAAUtD,GAAGA,EAAE6L,KAAKpE,MAAMtF,GAAGA,EAAEinB,SAASvd,IAAI2d,EAAEX,EAAEhd,IAAIvkB,IAAId,GAAGgjC,GAAGxpB,IAAIwpB,GAAG/hB,IAAIoE,IAAI,CAAC,IAAI,IAAI6e,EAAE,GAAG7e,EAAEgd,EAAEniC,QAAQY,GAAG,CAAKkiC,EAAEX,EAAEhd,GAAG,GAAG/Z,EAAE03B,GAAG,CAACkB,EAAE,GAAG,KAAK,CAACA,GAAGlB,EAAE3d,GAAG,CAAC,OAAOrlB,EAAEkkC,CAAC,CAAC7B,EAAEhd,EAAE/Z,CAAC,EAAE,SAAS6H,EAAEkvB,EAAEvhC,GAAG,IAAIwK,EAAExK,EAAE,EAAFA,CAAKA,EAAE,GAAGA,EAAE,GAAG,KAAK,MAAMqS,EAAEuV,QAAQpd,EAAEod,OAAO,EAAE,SAASvV,EAAEkvB,GAAGlvB,EAAEuV,QAAQ,SAASvV,EAAEkvB,EAAEvhC,EAAEwK,GAAG,IAAI+Z,EAAEpE,EAAE9N,EAAEA,GAAG,CAAC,EAAEnT,SAASmT,EAAEuD,QAAQ,WAAW1W,GAAG,aAAaA,IAAIqlB,EAAElS,EAAE8N,EAAE9N,EAAEuD,SAAS,IAAIssB,EAAE,mBAAmB/hB,EAAEA,EAAE1N,QAAQ0N,EAAE,GAAGohB,IAAIW,EAAEhf,OAAOqe,EAAEre,OAAOgf,EAAEmB,gBAAgB9B,EAAE8B,iBAAiBrjC,IAAIkiC,EAAEoB,SAAStjC,GAAGwK,EAAE,CAAC,IAAIqQ,EAAEqnB,EAAE9+B,WAAW8+B,EAAE9+B,SAAS,CAAC,GAAGM,OAAOqhB,KAAKva,GAAGxH,SAAQ,SAASqP,GAAG,IAAIkvB,EAAE/2B,EAAE6H,GAAGwI,EAAExI,GAAG,WAAW,OAAOkvB,CAAC,CAAC,GAAE,CAAC,MAAM,CAACgC,SAAShf,EAAEqD,QAAQzH,EAAE1N,QAAQyvB,EAAE,CAAC,EAAE,SAAS7vB,EAAEkvB,GAAGlvB,EAAEuV,QAAQ,CAAC1E,OAAO,WAAW,IAAI7Q,EAAEpU,KAAKsjC,EAAElvB,EAAEmxB,eAAe,OAAOnxB,EAAEoxB,MAAMC,IAAInC,GAAG,QAAQ,CAACsB,WAAW,CAAC,CAACxyB,KAAK,OAAOW,QAAQ,SAASxL,MAAM6M,EAAEuuB,OAAO+C,WAAW,WAAWrI,MAAM,CAACz5B,KAAK,QAAQ+hC,SAAS,CAACp+B,MAAM6M,EAAEnC,SAASpR,GAAG,CAAC+kC,MAAMxxB,EAAE4wB,UAAU,EAAEI,gBAAgB,GAAG,EAAE,SAAShxB,EAAEkvB,EAAEvhC,GAAGqS,EAAEuV,QAAQ5nB,EAAE,EAAE,GAAG,G","sources":["webpack://hr-data/./node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","webpack://hr-data/./node_modules/@vue/runtime-dom/dist/runtime-dom.esm-bundler.js","webpack://hr-data/./node_modules/@vue/shared/dist/shared.esm-bundler.js","webpack://hr-data/./node_modules/vue-loader/dist/exportHelper.js","webpack://hr-data/./node_modules/vue-router/dist/vue-router.esm-bundler.js","webpack://hr-data/./node_modules/vue-the-mask/dist/vue-the-mask.js"],"sourcesContent":["import { extend, isArray, isMap, isIntegerKey, hasOwn, isSymbol, isObject, hasChanged, makeMap, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nfunction warn(msg, ...args) {\n    console.warn(`[Vue warn] ${msg}`, ...args);\n}\n\nlet activeEffectScope;\nclass EffectScope {\n    constructor(detached = false) {\n        this.detached = detached;\n        /**\n         * @internal\n         */\n        this._active = true;\n        /**\n         * @internal\n         */\n        this.effects = [];\n        /**\n         * @internal\n         */\n        this.cleanups = [];\n        this.parent = activeEffectScope;\n        if (!detached && activeEffectScope) {\n            this.index =\n                (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;\n        }\n    }\n    get active() {\n        return this._active;\n    }\n    run(fn) {\n        if (this._active) {\n            const currentEffectScope = activeEffectScope;\n            try {\n                activeEffectScope = this;\n                return fn();\n            }\n            finally {\n                activeEffectScope = currentEffectScope;\n            }\n        }\n        else if ((process.env.NODE_ENV !== 'production')) {\n            warn(`cannot run an inactive effect scope.`);\n        }\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    on() {\n        activeEffectScope = this;\n    }\n    /**\n     * This should only be called on non-detached scopes\n     * @internal\n     */\n    off() {\n        activeEffectScope = this.parent;\n    }\n    stop(fromParent) {\n        if (this._active) {\n            let i, l;\n            for (i = 0, l = this.effects.length; i < l; i++) {\n                this.effects[i].stop();\n            }\n            for (i = 0, l = this.cleanups.length; i < l; i++) {\n                this.cleanups[i]();\n            }\n            if (this.scopes) {\n                for (i = 0, l = this.scopes.length; i < l; i++) {\n                    this.scopes[i].stop(true);\n                }\n            }\n            // nested scope, dereference from parent to avoid memory leaks\n            if (!this.detached && this.parent && !fromParent) {\n                // optimized O(1) removal\n                const last = this.parent.scopes.pop();\n                if (last && last !== this) {\n                    this.parent.scopes[this.index] = last;\n                    last.index = this.index;\n                }\n            }\n            this.parent = undefined;\n            this._active = false;\n        }\n    }\n}\nfunction effectScope(detached) {\n    return new EffectScope(detached);\n}\nfunction recordEffectScope(effect, scope = activeEffectScope) {\n    if (scope && scope.active) {\n        scope.effects.push(effect);\n    }\n}\nfunction getCurrentScope() {\n    return activeEffectScope;\n}\nfunction onScopeDispose(fn) {\n    if (activeEffectScope) {\n        activeEffectScope.cleanups.push(fn);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        warn(`onScopeDispose() is called when there is no active effect scope` +\n            ` to be associated with.`);\n    }\n}\n\nconst createDep = (effects) => {\n    const dep = new Set(effects);\n    dep.w = 0;\n    dep.n = 0;\n    return dep;\n};\nconst wasTracked = (dep) => (dep.w & trackOpBit) > 0;\nconst newTracked = (dep) => (dep.n & trackOpBit) > 0;\nconst initDepMarkers = ({ deps }) => {\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].w |= trackOpBit; // set was tracked\n        }\n    }\n};\nconst finalizeDepMarkers = (effect) => {\n    const { deps } = effect;\n    if (deps.length) {\n        let ptr = 0;\n        for (let i = 0; i < deps.length; i++) {\n            const dep = deps[i];\n            if (wasTracked(dep) && !newTracked(dep)) {\n                dep.delete(effect);\n            }\n            else {\n                deps[ptr++] = dep;\n            }\n            // clear bits\n            dep.w &= ~trackOpBit;\n            dep.n &= ~trackOpBit;\n        }\n        deps.length = ptr;\n    }\n};\n\nconst targetMap = new WeakMap();\n// The number of effects currently being tracked recursively.\nlet effectTrackDepth = 0;\nlet trackOpBit = 1;\n/**\n * The bitwise track markers support at most 30 levels of recursion.\n * This value is chosen to enable modern JS engines to use a SMI on all platforms.\n * When recursion depth is greater, fall back to using a full cleanup.\n */\nconst maxMarkerBits = 30;\nlet activeEffect;\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\nclass ReactiveEffect {\n    constructor(fn, scheduler = null, scope) {\n        this.fn = fn;\n        this.scheduler = scheduler;\n        this.active = true;\n        this.deps = [];\n        this.parent = undefined;\n        recordEffectScope(this, scope);\n    }\n    run() {\n        if (!this.active) {\n            return this.fn();\n        }\n        let parent = activeEffect;\n        let lastShouldTrack = shouldTrack;\n        while (parent) {\n            if (parent === this) {\n                return;\n            }\n            parent = parent.parent;\n        }\n        try {\n            this.parent = activeEffect;\n            activeEffect = this;\n            shouldTrack = true;\n            trackOpBit = 1 << ++effectTrackDepth;\n            if (effectTrackDepth <= maxMarkerBits) {\n                initDepMarkers(this);\n            }\n            else {\n                cleanupEffect(this);\n            }\n            return this.fn();\n        }\n        finally {\n            if (effectTrackDepth <= maxMarkerBits) {\n                finalizeDepMarkers(this);\n            }\n            trackOpBit = 1 << --effectTrackDepth;\n            activeEffect = this.parent;\n            shouldTrack = lastShouldTrack;\n            this.parent = undefined;\n            if (this.deferStop) {\n                this.stop();\n            }\n        }\n    }\n    stop() {\n        // stopped while running itself - defer the cleanup\n        if (activeEffect === this) {\n            this.deferStop = true;\n        }\n        else if (this.active) {\n            cleanupEffect(this);\n            if (this.onStop) {\n                this.onStop();\n            }\n            this.active = false;\n        }\n    }\n}\nfunction cleanupEffect(effect) {\n    const { deps } = effect;\n    if (deps.length) {\n        for (let i = 0; i < deps.length; i++) {\n            deps[i].delete(effect);\n        }\n        deps.length = 0;\n    }\n}\nfunction effect(fn, options) {\n    if (fn.effect) {\n        fn = fn.effect.fn;\n    }\n    const _effect = new ReactiveEffect(fn);\n    if (options) {\n        extend(_effect, options);\n        if (options.scope)\n            recordEffectScope(_effect, options.scope);\n    }\n    if (!options || !options.lazy) {\n        _effect.run();\n    }\n    const runner = _effect.run.bind(_effect);\n    runner.effect = _effect;\n    return runner;\n}\nfunction stop(runner) {\n    runner.effect.stop();\n}\nlet shouldTrack = true;\nconst trackStack = [];\nfunction pauseTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = false;\n}\nfunction enableTracking() {\n    trackStack.push(shouldTrack);\n    shouldTrack = true;\n}\nfunction resetTracking() {\n    const last = trackStack.pop();\n    shouldTrack = last === undefined ? true : last;\n}\nfunction track(target, type, key) {\n    if (shouldTrack && activeEffect) {\n        let depsMap = targetMap.get(target);\n        if (!depsMap) {\n            targetMap.set(target, (depsMap = new Map()));\n        }\n        let dep = depsMap.get(key);\n        if (!dep) {\n            depsMap.set(key, (dep = createDep()));\n        }\n        const eventInfo = (process.env.NODE_ENV !== 'production')\n            ? { effect: activeEffect, target, type, key }\n            : undefined;\n        trackEffects(dep, eventInfo);\n    }\n}\nfunction trackEffects(dep, debuggerEventExtraInfo) {\n    let shouldTrack = false;\n    if (effectTrackDepth <= maxMarkerBits) {\n        if (!newTracked(dep)) {\n            dep.n |= trackOpBit; // set newly tracked\n            shouldTrack = !wasTracked(dep);\n        }\n    }\n    else {\n        // Full cleanup mode.\n        shouldTrack = !dep.has(activeEffect);\n    }\n    if (shouldTrack) {\n        dep.add(activeEffect);\n        activeEffect.deps.push(dep);\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.onTrack) {\n            activeEffect.onTrack(Object.assign({ effect: activeEffect }, debuggerEventExtraInfo));\n        }\n    }\n}\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\n    const depsMap = targetMap.get(target);\n    if (!depsMap) {\n        // never been tracked\n        return;\n    }\n    let deps = [];\n    if (type === \"clear\" /* TriggerOpTypes.CLEAR */) {\n        // collection being cleared\n        // trigger all effects for target\n        deps = [...depsMap.values()];\n    }\n    else if (key === 'length' && isArray(target)) {\n        const newLength = Number(newValue);\n        depsMap.forEach((dep, key) => {\n            if (key === 'length' || key >= newLength) {\n                deps.push(dep);\n            }\n        });\n    }\n    else {\n        // schedule runs for SET | ADD | DELETE\n        if (key !== void 0) {\n            deps.push(depsMap.get(key));\n        }\n        // also run for iteration key on ADD | DELETE | Map.SET\n        switch (type) {\n            case \"add\" /* TriggerOpTypes.ADD */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                else if (isIntegerKey(key)) {\n                    // new index added to array -> length changes\n                    deps.push(depsMap.get('length'));\n                }\n                break;\n            case \"delete\" /* TriggerOpTypes.DELETE */:\n                if (!isArray(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                    if (isMap(target)) {\n                        deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));\n                    }\n                }\n                break;\n            case \"set\" /* TriggerOpTypes.SET */:\n                if (isMap(target)) {\n                    deps.push(depsMap.get(ITERATE_KEY));\n                }\n                break;\n        }\n    }\n    const eventInfo = (process.env.NODE_ENV !== 'production')\n        ? { target, type, key, newValue, oldValue, oldTarget }\n        : undefined;\n    if (deps.length === 1) {\n        if (deps[0]) {\n            if ((process.env.NODE_ENV !== 'production')) {\n                triggerEffects(deps[0], eventInfo);\n            }\n            else {\n                triggerEffects(deps[0]);\n            }\n        }\n    }\n    else {\n        const effects = [];\n        for (const dep of deps) {\n            if (dep) {\n                effects.push(...dep);\n            }\n        }\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(createDep(effects), eventInfo);\n        }\n        else {\n            triggerEffects(createDep(effects));\n        }\n    }\n}\nfunction triggerEffects(dep, debuggerEventExtraInfo) {\n    // spread into array for stabilization\n    const effects = isArray(dep) ? dep : [...dep];\n    for (const effect of effects) {\n        if (effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n    for (const effect of effects) {\n        if (!effect.computed) {\n            triggerEffect(effect, debuggerEventExtraInfo);\n        }\n    }\n}\nfunction triggerEffect(effect, debuggerEventExtraInfo) {\n    if (effect !== activeEffect || effect.allowRecurse) {\n        if ((process.env.NODE_ENV !== 'production') && effect.onTrigger) {\n            effect.onTrigger(extend({ effect }, debuggerEventExtraInfo));\n        }\n        if (effect.scheduler) {\n            effect.scheduler();\n        }\n        else {\n            effect.run();\n        }\n    }\n}\nfunction getDepFromReactive(object, key) {\n    var _a;\n    return (_a = targetMap.get(object)) === null || _a === void 0 ? void 0 : _a.get(key);\n}\n\nconst isNonTrackableKeys = /*#__PURE__*/ makeMap(`__proto__,__v_isRef,__isVue`);\nconst builtInSymbols = new Set(\n/*#__PURE__*/\nObject.getOwnPropertyNames(Symbol)\n    // ios10.x Object.getOwnPropertyNames(Symbol) can enumerate 'arguments' and 'caller'\n    // but accessing them on Symbol leads to TypeError because Symbol is a strict mode\n    // function\n    .filter(key => key !== 'arguments' && key !== 'caller')\n    .map(key => Symbol[key])\n    .filter(isSymbol));\nconst get$1 = /*#__PURE__*/ createGetter();\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\nconst arrayInstrumentations = /*#__PURE__*/ createArrayInstrumentations();\nfunction createArrayInstrumentations() {\n    const instrumentations = {};\n    ['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            const arr = toRaw(this);\n            for (let i = 0, l = this.length; i < l; i++) {\n                track(arr, \"get\" /* TrackOpTypes.GET */, i + '');\n            }\n            // we run the method using the original args first (which may be reactive)\n            const res = arr[key](...args);\n            if (res === -1 || res === false) {\n                // if that didn't work, run it again using raw values.\n                return arr[key](...args.map(toRaw));\n            }\n            else {\n                return res;\n            }\n        };\n    });\n    ['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\n        instrumentations[key] = function (...args) {\n            pauseTracking();\n            const res = toRaw(this)[key].apply(this, args);\n            resetTracking();\n            return res;\n        };\n    });\n    return instrumentations;\n}\nfunction hasOwnProperty(key) {\n    const obj = toRaw(this);\n    track(obj, \"has\" /* TrackOpTypes.HAS */, key);\n    return obj.hasOwnProperty(key);\n}\nfunction createGetter(isReadonly = false, shallow = false) {\n    return function get(target, key, receiver) {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */) {\n            return shallow;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */ &&\n            receiver ===\n                (isReadonly\n                    ? shallow\n                        ? shallowReadonlyMap\n                        : readonlyMap\n                    : shallow\n                        ? shallowReactiveMap\n                        : reactiveMap).get(target)) {\n            return target;\n        }\n        const targetIsArray = isArray(target);\n        if (!isReadonly) {\n            if (targetIsArray && hasOwn(arrayInstrumentations, key)) {\n                return Reflect.get(arrayInstrumentations, key, receiver);\n            }\n            if (key === 'hasOwnProperty') {\n                return hasOwnProperty;\n            }\n        }\n        const res = Reflect.get(target, key, receiver);\n        if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {\n            return res;\n        }\n        if (!isReadonly) {\n            track(target, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        if (shallow) {\n            return res;\n        }\n        if (isRef(res)) {\n            // ref unwrapping - skip unwrap for Array + integer key.\n            return targetIsArray && isIntegerKey(key) ? res : res.value;\n        }\n        if (isObject(res)) {\n            // Convert returned value into a proxy as well. we do the isObject check\n            // here to avoid invalid value warning. Also need to lazy access readonly\n            // and reactive here to avoid circular dependency.\n            return isReadonly ? readonly(res) : reactive(res);\n        }\n        return res;\n    };\n}\nconst set$1 = /*#__PURE__*/ createSetter();\nconst shallowSet = /*#__PURE__*/ createSetter(true);\nfunction createSetter(shallow = false) {\n    return function set(target, key, value, receiver) {\n        let oldValue = target[key];\n        if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {\n            return false;\n        }\n        if (!shallow) {\n            if (!isShallow(value) && !isReadonly(value)) {\n                oldValue = toRaw(oldValue);\n                value = toRaw(value);\n            }\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\n                oldValue.value = value;\n                return true;\n            }\n        }\n        const hadKey = isArray(target) && isIntegerKey(key)\n            ? Number(key) < target.length\n            : hasOwn(target, key);\n        const result = Reflect.set(target, key, value, receiver);\n        // don't trigger if target is something up in the prototype chain of original\n        if (target === toRaw(receiver)) {\n            if (!hadKey) {\n                trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n            }\n            else if (hasChanged(value, oldValue)) {\n                trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n            }\n        }\n        return result;\n    };\n}\nfunction deleteProperty(target, key) {\n    const hadKey = hasOwn(target, key);\n    const oldValue = target[key];\n    const result = Reflect.deleteProperty(target, key);\n    if (result && hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction has$1(target, key) {\n    const result = Reflect.has(target, key);\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\n        track(target, \"has\" /* TrackOpTypes.HAS */, key);\n    }\n    return result;\n}\nfunction ownKeys(target) {\n    track(target, \"iterate\" /* TrackOpTypes.ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\n    return Reflect.ownKeys(target);\n}\nconst mutableHandlers = {\n    get: get$1,\n    set: set$1,\n    deleteProperty,\n    has: has$1,\n    ownKeys\n};\nconst readonlyHandlers = {\n    get: readonlyGet,\n    set(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    },\n    deleteProperty(target, key) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\n        }\n        return true;\n    }\n};\nconst shallowReactiveHandlers = /*#__PURE__*/ extend({}, mutableHandlers, {\n    get: shallowGet,\n    set: shallowSet\n});\n// Props handlers are special in the sense that it should not unwrap top-level\n// refs (in order to allow refs to be explicitly passed down), but should\n// retain the reactivity of the normal readonly object.\nconst shallowReadonlyHandlers = /*#__PURE__*/ extend({}, readonlyHandlers, {\n    get: shallowReadonlyGet\n});\n\nconst toShallow = (value) => value;\nconst getProto = (v) => Reflect.getPrototypeOf(v);\nfunction get(target, key, isReadonly = false, isShallow = false) {\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\n    // of the value\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"get\" /* TrackOpTypes.GET */, key);\n        }\n        track(rawTarget, \"get\" /* TrackOpTypes.GET */, rawKey);\n    }\n    const { has } = getProto(rawTarget);\n    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n    if (has.call(rawTarget, key)) {\n        return wrap(target.get(key));\n    }\n    else if (has.call(rawTarget, rawKey)) {\n        return wrap(target.get(rawKey));\n    }\n    else if (target !== rawTarget) {\n        // #3602 readonly(reactive(Map))\n        // ensure that the nested reactive `Map` can do tracking for itself\n        target.get(key);\n    }\n}\nfunction has(key, isReadonly = false) {\n    const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n    const rawTarget = toRaw(target);\n    const rawKey = toRaw(key);\n    if (!isReadonly) {\n        if (key !== rawKey) {\n            track(rawTarget, \"has\" /* TrackOpTypes.HAS */, key);\n        }\n        track(rawTarget, \"has\" /* TrackOpTypes.HAS */, rawKey);\n    }\n    return key === rawKey\n        ? target.has(key)\n        : target.has(key) || target.has(rawKey);\n}\nfunction size(target, isReadonly = false) {\n    target = target[\"__v_raw\" /* ReactiveFlags.RAW */];\n    !isReadonly && track(toRaw(target), \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n    return Reflect.get(target, 'size', target);\n}\nfunction add(value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const proto = getProto(target);\n    const hadKey = proto.has.call(target, value);\n    if (!hadKey) {\n        target.add(value);\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, value, value);\n    }\n    return this;\n}\nfunction set(key, value) {\n    value = toRaw(value);\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get.call(target, key);\n    target.set(key, value);\n    if (!hadKey) {\n        trigger(target, \"add\" /* TriggerOpTypes.ADD */, key, value);\n    }\n    else if (hasChanged(value, oldValue)) {\n        trigger(target, \"set\" /* TriggerOpTypes.SET */, key, value, oldValue);\n    }\n    return this;\n}\nfunction deleteEntry(key) {\n    const target = toRaw(this);\n    const { has, get } = getProto(target);\n    let hadKey = has.call(target, key);\n    if (!hadKey) {\n        key = toRaw(key);\n        hadKey = has.call(target, key);\n    }\n    else if ((process.env.NODE_ENV !== 'production')) {\n        checkIdentityKeys(target, has, key);\n    }\n    const oldValue = get ? get.call(target, key) : undefined;\n    // forward the operation before queueing reactions\n    const result = target.delete(key);\n    if (hadKey) {\n        trigger(target, \"delete\" /* TriggerOpTypes.DELETE */, key, undefined, oldValue);\n    }\n    return result;\n}\nfunction clear() {\n    const target = toRaw(this);\n    const hadItems = target.size !== 0;\n    const oldTarget = (process.env.NODE_ENV !== 'production')\n        ? isMap(target)\n            ? new Map(target)\n            : new Set(target)\n        : undefined;\n    // forward the operation before queueing reactions\n    const result = target.clear();\n    if (hadItems) {\n        trigger(target, \"clear\" /* TriggerOpTypes.CLEAR */, undefined, undefined, oldTarget);\n    }\n    return result;\n}\nfunction createForEach(isReadonly, isShallow) {\n    return function forEach(callback, thisArg) {\n        const observed = this;\n        const target = observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly && track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, ITERATE_KEY);\n        return target.forEach((value, key) => {\n            // important: make sure the callback is\n            // 1. invoked with the reactive map as `this` and 3rd arg\n            // 2. the value received should be a corresponding reactive/readonly.\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\n        });\n    };\n}\nfunction createIterableMethod(method, isReadonly, isShallow) {\n    return function (...args) {\n        const target = this[\"__v_raw\" /* ReactiveFlags.RAW */];\n        const rawTarget = toRaw(target);\n        const targetIsMap = isMap(rawTarget);\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\n        const isKeyOnly = method === 'keys' && targetIsMap;\n        const innerIterator = target[method](...args);\n        const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;\n        !isReadonly &&\n            track(rawTarget, \"iterate\" /* TrackOpTypes.ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\n        // return a wrapped iterator which returns observed versions of the\n        // values emitted from the real iterator\n        return {\n            // iterator protocol\n            next() {\n                const { value, done } = innerIterator.next();\n                return done\n                    ? { value, done }\n                    : {\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\n                        done\n                    };\n            },\n            // iterable protocol\n            [Symbol.iterator]() {\n                return this;\n            }\n        };\n    };\n}\nfunction createReadonlyMethod(type) {\n    return function (...args) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\n        }\n        return type === \"delete\" /* TriggerOpTypes.DELETE */ ? false : this;\n    };\n}\nfunction createInstrumentations() {\n    const mutableInstrumentations = {\n        get(key) {\n            return get(this, key);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, false)\n    };\n    const shallowInstrumentations = {\n        get(key) {\n            return get(this, key, false, true);\n        },\n        get size() {\n            return size(this);\n        },\n        has,\n        add,\n        set,\n        delete: deleteEntry,\n        clear,\n        forEach: createForEach(false, true)\n    };\n    const readonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, false)\n    };\n    const shallowReadonlyInstrumentations = {\n        get(key) {\n            return get(this, key, true, true);\n        },\n        get size() {\n            return size(this, true);\n        },\n        has(key) {\n            return has.call(this, key, true);\n        },\n        add: createReadonlyMethod(\"add\" /* TriggerOpTypes.ADD */),\n        set: createReadonlyMethod(\"set\" /* TriggerOpTypes.SET */),\n        delete: createReadonlyMethod(\"delete\" /* TriggerOpTypes.DELETE */),\n        clear: createReadonlyMethod(\"clear\" /* TriggerOpTypes.CLEAR */),\n        forEach: createForEach(true, true)\n    };\n    const iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\n    iteratorMethods.forEach(method => {\n        mutableInstrumentations[method] = createIterableMethod(method, false, false);\n        readonlyInstrumentations[method] = createIterableMethod(method, true, false);\n        shallowInstrumentations[method] = createIterableMethod(method, false, true);\n        shallowReadonlyInstrumentations[method] = createIterableMethod(method, true, true);\n    });\n    return [\n        mutableInstrumentations,\n        readonlyInstrumentations,\n        shallowInstrumentations,\n        shallowReadonlyInstrumentations\n    ];\n}\nconst [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* #__PURE__*/ createInstrumentations();\nfunction createInstrumentationGetter(isReadonly, shallow) {\n    const instrumentations = shallow\n        ? isReadonly\n            ? shallowReadonlyInstrumentations\n            : shallowInstrumentations\n        : isReadonly\n            ? readonlyInstrumentations\n            : mutableInstrumentations;\n    return (target, key, receiver) => {\n        if (key === \"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */) {\n            return !isReadonly;\n        }\n        else if (key === \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */) {\n            return isReadonly;\n        }\n        else if (key === \"__v_raw\" /* ReactiveFlags.RAW */) {\n            return target;\n        }\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\n            ? instrumentations\n            : target, key, receiver);\n    };\n}\nconst mutableCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, false)\n};\nconst shallowCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(false, true)\n};\nconst readonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, false)\n};\nconst shallowReadonlyCollectionHandlers = {\n    get: /*#__PURE__*/ createInstrumentationGetter(true, true)\n};\nfunction checkIdentityKeys(target, has, key) {\n    const rawKey = toRaw(key);\n    if (rawKey !== key && has.call(target, rawKey)) {\n        const type = toRawType(target);\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\n            `which can lead to inconsistencies. ` +\n            `Avoid differentiating between the raw and reactive versions ` +\n            `of an object and only use the reactive version if possible.`);\n    }\n}\n\nconst reactiveMap = new WeakMap();\nconst shallowReactiveMap = new WeakMap();\nconst readonlyMap = new WeakMap();\nconst shallowReadonlyMap = new WeakMap();\nfunction targetTypeMap(rawType) {\n    switch (rawType) {\n        case 'Object':\n        case 'Array':\n            return 1 /* TargetType.COMMON */;\n        case 'Map':\n        case 'Set':\n        case 'WeakMap':\n        case 'WeakSet':\n            return 2 /* TargetType.COLLECTION */;\n        default:\n            return 0 /* TargetType.INVALID */;\n    }\n}\nfunction getTargetType(value) {\n    return value[\"__v_skip\" /* ReactiveFlags.SKIP */] || !Object.isExtensible(value)\n        ? 0 /* TargetType.INVALID */\n        : targetTypeMap(toRawType(value));\n}\nfunction reactive(target) {\n    // if trying to observe a readonly proxy, return the readonly version.\n    if (isReadonly(target)) {\n        return target;\n    }\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);\n}\n/**\n * Return a shallowly-reactive copy of the original object, where only the root\n * level properties are reactive. It also does not auto-unwrap refs (even at the\n * root level).\n */\nfunction shallowReactive(target) {\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);\n}\n/**\n * Creates a readonly copy of the original object. Note the returned copy is not\n * made reactive, but `readonly` can be called on an already reactive object.\n */\nfunction readonly(target) {\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);\n}\n/**\n * Returns a reactive-copy of the original object, where only the root level\n * properties are readonly, and does NOT unwrap refs nor recursively convert\n * returned properties.\n * This is used for creating the props proxy object for stateful components.\n */\nfunction shallowReadonly(target) {\n    return createReactiveObject(target, true, shallowReadonlyHandlers, shallowReadonlyCollectionHandlers, shallowReadonlyMap);\n}\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {\n    if (!isObject(target)) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            console.warn(`value cannot be made reactive: ${String(target)}`);\n        }\n        return target;\n    }\n    // target is already a Proxy, return it.\n    // exception: calling readonly() on a reactive object\n    if (target[\"__v_raw\" /* ReactiveFlags.RAW */] &&\n        !(isReadonly && target[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */])) {\n        return target;\n    }\n    // target already has corresponding Proxy\n    const existingProxy = proxyMap.get(target);\n    if (existingProxy) {\n        return existingProxy;\n    }\n    // only specific value types can be observed.\n    const targetType = getTargetType(target);\n    if (targetType === 0 /* TargetType.INVALID */) {\n        return target;\n    }\n    const proxy = new Proxy(target, targetType === 2 /* TargetType.COLLECTION */ ? collectionHandlers : baseHandlers);\n    proxyMap.set(target, proxy);\n    return proxy;\n}\nfunction isReactive(value) {\n    if (isReadonly(value)) {\n        return isReactive(value[\"__v_raw\" /* ReactiveFlags.RAW */]);\n    }\n    return !!(value && value[\"__v_isReactive\" /* ReactiveFlags.IS_REACTIVE */]);\n}\nfunction isReadonly(value) {\n    return !!(value && value[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */]);\n}\nfunction isShallow(value) {\n    return !!(value && value[\"__v_isShallow\" /* ReactiveFlags.IS_SHALLOW */]);\n}\nfunction isProxy(value) {\n    return isReactive(value) || isReadonly(value);\n}\nfunction toRaw(observed) {\n    const raw = observed && observed[\"__v_raw\" /* ReactiveFlags.RAW */];\n    return raw ? toRaw(raw) : observed;\n}\nfunction markRaw(value) {\n    def(value, \"__v_skip\" /* ReactiveFlags.SKIP */, true);\n    return value;\n}\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\n\nfunction trackRefValue(ref) {\n    if (shouldTrack && activeEffect) {\n        ref = toRaw(ref);\n        if ((process.env.NODE_ENV !== 'production')) {\n            trackEffects(ref.dep || (ref.dep = createDep()), {\n                target: ref,\n                type: \"get\" /* TrackOpTypes.GET */,\n                key: 'value'\n            });\n        }\n        else {\n            trackEffects(ref.dep || (ref.dep = createDep()));\n        }\n    }\n}\nfunction triggerRefValue(ref, newVal) {\n    ref = toRaw(ref);\n    const dep = ref.dep;\n    if (dep) {\n        if ((process.env.NODE_ENV !== 'production')) {\n            triggerEffects(dep, {\n                target: ref,\n                type: \"set\" /* TriggerOpTypes.SET */,\n                key: 'value',\n                newValue: newVal\n            });\n        }\n        else {\n            triggerEffects(dep);\n        }\n    }\n}\nfunction isRef(r) {\n    return !!(r && r.__v_isRef === true);\n}\nfunction ref(value) {\n    return createRef(value, false);\n}\nfunction shallowRef(value) {\n    return createRef(value, true);\n}\nfunction createRef(rawValue, shallow) {\n    if (isRef(rawValue)) {\n        return rawValue;\n    }\n    return new RefImpl(rawValue, shallow);\n}\nclass RefImpl {\n    constructor(value, __v_isShallow) {\n        this.__v_isShallow = __v_isShallow;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this._rawValue = __v_isShallow ? value : toRaw(value);\n        this._value = __v_isShallow ? value : toReactive(value);\n    }\n    get value() {\n        trackRefValue(this);\n        return this._value;\n    }\n    set value(newVal) {\n        const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);\n        newVal = useDirectValue ? newVal : toRaw(newVal);\n        if (hasChanged(newVal, this._rawValue)) {\n            this._rawValue = newVal;\n            this._value = useDirectValue ? newVal : toReactive(newVal);\n            triggerRefValue(this, newVal);\n        }\n    }\n}\nfunction triggerRef(ref) {\n    triggerRefValue(ref, (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\n}\nfunction unref(ref) {\n    return isRef(ref) ? ref.value : ref;\n}\nconst shallowUnwrapHandlers = {\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\n    set: (target, key, value, receiver) => {\n        const oldValue = target[key];\n        if (isRef(oldValue) && !isRef(value)) {\n            oldValue.value = value;\n            return true;\n        }\n        else {\n            return Reflect.set(target, key, value, receiver);\n        }\n    }\n};\nfunction proxyRefs(objectWithRefs) {\n    return isReactive(objectWithRefs)\n        ? objectWithRefs\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\n}\nclass CustomRefImpl {\n    constructor(factory) {\n        this.dep = undefined;\n        this.__v_isRef = true;\n        const { get, set } = factory(() => trackRefValue(this), () => triggerRefValue(this));\n        this._get = get;\n        this._set = set;\n    }\n    get value() {\n        return this._get();\n    }\n    set value(newVal) {\n        this._set(newVal);\n    }\n}\nfunction customRef(factory) {\n    return new CustomRefImpl(factory);\n}\nfunction toRefs(object) {\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\n    }\n    const ret = isArray(object) ? new Array(object.length) : {};\n    for (const key in object) {\n        ret[key] = toRef(object, key);\n    }\n    return ret;\n}\nclass ObjectRefImpl {\n    constructor(_object, _key, _defaultValue) {\n        this._object = _object;\n        this._key = _key;\n        this._defaultValue = _defaultValue;\n        this.__v_isRef = true;\n    }\n    get value() {\n        const val = this._object[this._key];\n        return val === undefined ? this._defaultValue : val;\n    }\n    set value(newVal) {\n        this._object[this._key] = newVal;\n    }\n    get dep() {\n        return getDepFromReactive(toRaw(this._object), this._key);\n    }\n}\nfunction toRef(object, key, defaultValue) {\n    const val = object[key];\n    return isRef(val)\n        ? val\n        : new ObjectRefImpl(object, key, defaultValue);\n}\n\nvar _a$1;\nclass ComputedRefImpl {\n    constructor(getter, _setter, isReadonly, isSSR) {\n        this._setter = _setter;\n        this.dep = undefined;\n        this.__v_isRef = true;\n        this[_a$1] = false;\n        this._dirty = true;\n        this.effect = new ReactiveEffect(getter, () => {\n            if (!this._dirty) {\n                this._dirty = true;\n                triggerRefValue(this);\n            }\n        });\n        this.effect.computed = this;\n        this.effect.active = this._cacheable = !isSSR;\n        this[\"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */] = isReadonly;\n    }\n    get value() {\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        const self = toRaw(this);\n        trackRefValue(self);\n        if (self._dirty || !self._cacheable) {\n            self._dirty = false;\n            self._value = self.effect.run();\n        }\n        return self._value;\n    }\n    set value(newValue) {\n        this._setter(newValue);\n    }\n}\n_a$1 = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction computed(getterOrOptions, debugOptions, isSSR = false) {\n    let getter;\n    let setter;\n    const onlyGetter = isFunction(getterOrOptions);\n    if (onlyGetter) {\n        getter = getterOrOptions;\n        setter = (process.env.NODE_ENV !== 'production')\n            ? () => {\n                console.warn('Write operation failed: computed value is readonly');\n            }\n            : NOOP;\n    }\n    else {\n        getter = getterOrOptions.get;\n        setter = getterOrOptions.set;\n    }\n    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);\n    if ((process.env.NODE_ENV !== 'production') && debugOptions && !isSSR) {\n        cRef.effect.onTrack = debugOptions.onTrack;\n        cRef.effect.onTrigger = debugOptions.onTrigger;\n    }\n    return cRef;\n}\n\nvar _a;\nconst tick = /*#__PURE__*/ Promise.resolve();\nconst queue = [];\nlet queued = false;\nconst scheduler = (fn) => {\n    queue.push(fn);\n    if (!queued) {\n        queued = true;\n        tick.then(flush);\n    }\n};\nconst flush = () => {\n    for (let i = 0; i < queue.length; i++) {\n        queue[i]();\n    }\n    queue.length = 0;\n    queued = false;\n};\nclass DeferredComputedRefImpl {\n    constructor(getter) {\n        this.dep = undefined;\n        this._dirty = true;\n        this.__v_isRef = true;\n        this[_a] = true;\n        let compareTarget;\n        let hasCompareTarget = false;\n        let scheduled = false;\n        this.effect = new ReactiveEffect(getter, (computedTrigger) => {\n            if (this.dep) {\n                if (computedTrigger) {\n                    compareTarget = this._value;\n                    hasCompareTarget = true;\n                }\n                else if (!scheduled) {\n                    const valueToCompare = hasCompareTarget ? compareTarget : this._value;\n                    scheduled = true;\n                    hasCompareTarget = false;\n                    scheduler(() => {\n                        if (this.effect.active && this._get() !== valueToCompare) {\n                            triggerRefValue(this);\n                        }\n                        scheduled = false;\n                    });\n                }\n                // chained upstream computeds are notified synchronously to ensure\n                // value invalidation in case of sync access; normal effects are\n                // deferred to be triggered in scheduler.\n                for (const e of this.dep) {\n                    if (e.computed instanceof DeferredComputedRefImpl) {\n                        e.scheduler(true /* computedTrigger */);\n                    }\n                }\n            }\n            this._dirty = true;\n        });\n        this.effect.computed = this;\n    }\n    _get() {\n        if (this._dirty) {\n            this._dirty = false;\n            return (this._value = this.effect.run());\n        }\n        return this._value;\n    }\n    get value() {\n        trackRefValue(this);\n        // the computed ref may get wrapped by other proxies e.g. readonly() #3376\n        return toRaw(this)._get();\n    }\n}\n_a = \"__v_isReadonly\" /* ReactiveFlags.IS_READONLY */;\nfunction deferredComputed(getter) {\n    return new DeferredComputedRefImpl(getter);\n}\n\nexport { EffectScope, ITERATE_KEY, ReactiveEffect, computed, customRef, deferredComputed, effect, effectScope, enableTracking, getCurrentScope, isProxy, isReactive, isReadonly, isRef, isShallow, markRaw, onScopeDispose, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n","import { warn, camelize, callWithAsyncErrorHandling, defineComponent, nextTick, createVNode, getCurrentInstance, watchPostEffect, onMounted, onUnmounted, Fragment, Static, h, BaseTransition, assertNumber, useTransitionState, onUpdated, toRaw, getTransitionRawChildren, setTransitionHooks, resolveTransitionHooks, isRuntimeOnly, createRenderer, createHydrationRenderer } from '@vue/runtime-core';\nexport * from '@vue/runtime-core';\nimport { isString, isArray, hyphenate, capitalize, isSpecialBooleanAttr, includeBooleanAttr, isOn, isModelListener, isFunction, camelize as camelize$1, toNumber, extend, EMPTY_OBJ, isObject, looseToNumber, looseIndexOf, isSet, looseEqual, invokeArrayFns, isHTMLTag, isSVGTag } from '@vue/shared';\n\nconst svgNS = 'http://www.w3.org/2000/svg';\nconst doc = (typeof document !== 'undefined' ? document : null);\nconst templateContainer = doc && /*#__PURE__*/ doc.createElement('template');\nconst nodeOps = {\n    insert: (child, parent, anchor) => {\n        parent.insertBefore(child, anchor || null);\n    },\n    remove: child => {\n        const parent = child.parentNode;\n        if (parent) {\n            parent.removeChild(child);\n        }\n    },\n    createElement: (tag, isSVG, is, props) => {\n        const el = isSVG\n            ? doc.createElementNS(svgNS, tag)\n            : doc.createElement(tag, is ? { is } : undefined);\n        if (tag === 'select' && props && props.multiple != null) {\n            el.setAttribute('multiple', props.multiple);\n        }\n        return el;\n    },\n    createText: text => doc.createTextNode(text),\n    createComment: text => doc.createComment(text),\n    setText: (node, text) => {\n        node.nodeValue = text;\n    },\n    setElementText: (el, text) => {\n        el.textContent = text;\n    },\n    parentNode: node => node.parentNode,\n    nextSibling: node => node.nextSibling,\n    querySelector: selector => doc.querySelector(selector),\n    setScopeId(el, id) {\n        el.setAttribute(id, '');\n    },\n    // __UNSAFE__\n    // Reason: innerHTML.\n    // Static content here can only come from compiled templates.\n    // As long as the user only uses trusted templates, this is safe.\n    insertStaticContent(content, parent, anchor, isSVG, start, end) {\n        // <parent> before | first ... last | anchor </parent>\n        const before = anchor ? anchor.previousSibling : parent.lastChild;\n        // #5308 can only take cached path if:\n        // - has a single root node\n        // - nextSibling info is still available\n        if (start && (start === end || start.nextSibling)) {\n            // cached\n            while (true) {\n                parent.insertBefore(start.cloneNode(true), anchor);\n                if (start === end || !(start = start.nextSibling))\n                    break;\n            }\n        }\n        else {\n            // fresh insert\n            templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;\n            const template = templateContainer.content;\n            if (isSVG) {\n                // remove outer svg wrapper\n                const wrapper = template.firstChild;\n                while (wrapper.firstChild) {\n                    template.appendChild(wrapper.firstChild);\n                }\n                template.removeChild(wrapper);\n            }\n            parent.insertBefore(template, anchor);\n        }\n        return [\n            // first\n            before ? before.nextSibling : parent.firstChild,\n            // last\n            anchor ? anchor.previousSibling : parent.lastChild\n        ];\n    }\n};\n\n// compiler should normalize class + :class bindings on the same element\n// into a single binding ['staticClass', dynamic]\nfunction patchClass(el, value, isSVG) {\n    // directly setting className should be faster than setAttribute in theory\n    // if this is an element during a transition, take the temporary transition\n    // classes into account.\n    const transitionClasses = el._vtc;\n    if (transitionClasses) {\n        value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(' ');\n    }\n    if (value == null) {\n        el.removeAttribute('class');\n    }\n    else if (isSVG) {\n        el.setAttribute('class', value);\n    }\n    else {\n        el.className = value;\n    }\n}\n\nfunction patchStyle(el, prev, next) {\n    const style = el.style;\n    const isCssString = isString(next);\n    if (next && !isCssString) {\n        if (prev && !isString(prev)) {\n            for (const key in prev) {\n                if (next[key] == null) {\n                    setStyle(style, key, '');\n                }\n            }\n        }\n        for (const key in next) {\n            setStyle(style, key, next[key]);\n        }\n    }\n    else {\n        const currentDisplay = style.display;\n        if (isCssString) {\n            if (prev !== next) {\n                style.cssText = next;\n            }\n        }\n        else if (prev) {\n            el.removeAttribute('style');\n        }\n        // indicates that the `display` of the element is controlled by `v-show`,\n        // so we always keep the current `display` value regardless of the `style`\n        // value, thus handing over control to `v-show`.\n        if ('_vod' in el) {\n            style.display = currentDisplay;\n        }\n    }\n}\nconst semicolonRE = /[^\\\\];\\s*$/;\nconst importantRE = /\\s*!important$/;\nfunction setStyle(style, name, val) {\n    if (isArray(val)) {\n        val.forEach(v => setStyle(style, name, v));\n    }\n    else {\n        if (val == null)\n            val = '';\n        if ((process.env.NODE_ENV !== 'production')) {\n            if (semicolonRE.test(val)) {\n                warn(`Unexpected semicolon at the end of '${name}' style value: '${val}'`);\n            }\n        }\n        if (name.startsWith('--')) {\n            // custom property definition\n            style.setProperty(name, val);\n        }\n        else {\n            const prefixed = autoPrefix(style, name);\n            if (importantRE.test(val)) {\n                // !important\n                style.setProperty(hyphenate(prefixed), val.replace(importantRE, ''), 'important');\n            }\n            else {\n                style[prefixed] = val;\n            }\n        }\n    }\n}\nconst prefixes = ['Webkit', 'Moz', 'ms'];\nconst prefixCache = {};\nfunction autoPrefix(style, rawName) {\n    const cached = prefixCache[rawName];\n    if (cached) {\n        return cached;\n    }\n    let name = camelize(rawName);\n    if (name !== 'filter' && name in style) {\n        return (prefixCache[rawName] = name);\n    }\n    name = capitalize(name);\n    for (let i = 0; i < prefixes.length; i++) {\n        const prefixed = prefixes[i] + name;\n        if (prefixed in style) {\n            return (prefixCache[rawName] = prefixed);\n        }\n    }\n    return rawName;\n}\n\nconst xlinkNS = 'http://www.w3.org/1999/xlink';\nfunction patchAttr(el, key, value, isSVG, instance) {\n    if (isSVG && key.startsWith('xlink:')) {\n        if (value == null) {\n            el.removeAttributeNS(xlinkNS, key.slice(6, key.length));\n        }\n        else {\n            el.setAttributeNS(xlinkNS, key, value);\n        }\n    }\n    else {\n        // note we are only checking boolean attributes that don't have a\n        // corresponding dom prop of the same name here.\n        const isBoolean = isSpecialBooleanAttr(key);\n        if (value == null || (isBoolean && !includeBooleanAttr(value))) {\n            el.removeAttribute(key);\n        }\n        else {\n            el.setAttribute(key, isBoolean ? '' : value);\n        }\n    }\n}\n\n// __UNSAFE__\n// functions. The user is responsible for using them with only trusted content.\nfunction patchDOMProp(el, key, value, \n// the following args are passed only due to potential innerHTML/textContent\n// overriding existing VNodes, in which case the old tree must be properly\n// unmounted.\nprevChildren, parentComponent, parentSuspense, unmountChildren) {\n    if (key === 'innerHTML' || key === 'textContent') {\n        if (prevChildren) {\n            unmountChildren(prevChildren, parentComponent, parentSuspense);\n        }\n        el[key] = value == null ? '' : value;\n        return;\n    }\n    if (key === 'value' &&\n        el.tagName !== 'PROGRESS' &&\n        // custom elements may use _value internally\n        !el.tagName.includes('-')) {\n        // store value as _value as well since\n        // non-string values will be stringified.\n        el._value = value;\n        const newValue = value == null ? '' : value;\n        if (el.value !== newValue ||\n            // #4956: always set for OPTION elements because its value falls back to\n            // textContent if no value attribute is present. And setting .value for\n            // OPTION has no side effect\n            el.tagName === 'OPTION') {\n            el.value = newValue;\n        }\n        if (value == null) {\n            el.removeAttribute(key);\n        }\n        return;\n    }\n    let needRemove = false;\n    if (value === '' || value == null) {\n        const type = typeof el[key];\n        if (type === 'boolean') {\n            // e.g. <select multiple> compiles to { multiple: '' }\n            value = includeBooleanAttr(value);\n        }\n        else if (value == null && type === 'string') {\n            // e.g. <div :id=\"null\">\n            value = '';\n            needRemove = true;\n        }\n        else if (type === 'number') {\n            // e.g. <img :width=\"null\">\n            value = 0;\n            needRemove = true;\n        }\n    }\n    // some properties perform value validation and throw,\n    // some properties has getter, no setter, will error in 'use strict'\n    // eg. <select :type=\"null\"></select> <select :willValidate=\"null\"></select>\n    try {\n        el[key] = value;\n    }\n    catch (e) {\n        // do not warn if value is auto-coerced from nullish values\n        if ((process.env.NODE_ENV !== 'production') && !needRemove) {\n            warn(`Failed setting prop \"${key}\" on <${el.tagName.toLowerCase()}>: ` +\n                `value ${value} is invalid.`, e);\n        }\n    }\n    needRemove && el.removeAttribute(key);\n}\n\nfunction addEventListener(el, event, handler, options) {\n    el.addEventListener(event, handler, options);\n}\nfunction removeEventListener(el, event, handler, options) {\n    el.removeEventListener(event, handler, options);\n}\nfunction patchEvent(el, rawName, prevValue, nextValue, instance = null) {\n    // vei = vue event invokers\n    const invokers = el._vei || (el._vei = {});\n    const existingInvoker = invokers[rawName];\n    if (nextValue && existingInvoker) {\n        // patch\n        existingInvoker.value = nextValue;\n    }\n    else {\n        const [name, options] = parseName(rawName);\n        if (nextValue) {\n            // add\n            const invoker = (invokers[rawName] = createInvoker(nextValue, instance));\n            addEventListener(el, name, invoker, options);\n        }\n        else if (existingInvoker) {\n            // remove\n            removeEventListener(el, name, existingInvoker, options);\n            invokers[rawName] = undefined;\n        }\n    }\n}\nconst optionsModifierRE = /(?:Once|Passive|Capture)$/;\nfunction parseName(name) {\n    let options;\n    if (optionsModifierRE.test(name)) {\n        options = {};\n        let m;\n        while ((m = name.match(optionsModifierRE))) {\n            name = name.slice(0, name.length - m[0].length);\n            options[m[0].toLowerCase()] = true;\n        }\n    }\n    const event = name[2] === ':' ? name.slice(3) : hyphenate(name.slice(2));\n    return [event, options];\n}\n// To avoid the overhead of repeatedly calling Date.now(), we cache\n// and use the same timestamp for all event listeners attached in the same tick.\nlet cachedNow = 0;\nconst p = /*#__PURE__*/ Promise.resolve();\nconst getNow = () => cachedNow || (p.then(() => (cachedNow = 0)), (cachedNow = Date.now()));\nfunction createInvoker(initialValue, instance) {\n    const invoker = (e) => {\n        // async edge case vuejs/vue#6566\n        // inner click event triggers patch, event handler\n        // attached to outer element during patch, and triggered again. This\n        // happens because browsers fire microtask ticks between event propagation.\n        // this no longer happens for templates in Vue 3, but could still be\n        // theoretically possible for hand-written render functions.\n        // the solution: we save the timestamp when a handler is attached,\n        // and also attach the timestamp to any event that was handled by vue\n        // for the first time (to avoid inconsistent event timestamp implementations\n        // or events fired from iframes, e.g. #2513)\n        // The handler would only fire if the event passed to it was fired\n        // AFTER it was attached.\n        if (!e._vts) {\n            e._vts = Date.now();\n        }\n        else if (e._vts <= invoker.attached) {\n            return;\n        }\n        callWithAsyncErrorHandling(patchStopImmediatePropagation(e, invoker.value), instance, 5 /* ErrorCodes.NATIVE_EVENT_HANDLER */, [e]);\n    };\n    invoker.value = initialValue;\n    invoker.attached = getNow();\n    return invoker;\n}\nfunction patchStopImmediatePropagation(e, value) {\n    if (isArray(value)) {\n        const originalStop = e.stopImmediatePropagation;\n        e.stopImmediatePropagation = () => {\n            originalStop.call(e);\n            e._stopped = true;\n        };\n        return value.map(fn => (e) => !e._stopped && fn && fn(e));\n    }\n    else {\n        return value;\n    }\n}\n\nconst nativeOnRE = /^on[a-z]/;\nconst patchProp = (el, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {\n    if (key === 'class') {\n        patchClass(el, nextValue, isSVG);\n    }\n    else if (key === 'style') {\n        patchStyle(el, prevValue, nextValue);\n    }\n    else if (isOn(key)) {\n        // ignore v-model listeners\n        if (!isModelListener(key)) {\n            patchEvent(el, key, prevValue, nextValue, parentComponent);\n        }\n    }\n    else if (key[0] === '.'\n        ? ((key = key.slice(1)), true)\n        : key[0] === '^'\n            ? ((key = key.slice(1)), false)\n            : shouldSetAsProp(el, key, nextValue, isSVG)) {\n        patchDOMProp(el, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);\n    }\n    else {\n        // special case for <input v-model type=\"checkbox\"> with\n        // :true-value & :false-value\n        // store value as dom properties since non-string values will be\n        // stringified.\n        if (key === 'true-value') {\n            el._trueValue = nextValue;\n        }\n        else if (key === 'false-value') {\n            el._falseValue = nextValue;\n        }\n        patchAttr(el, key, nextValue, isSVG);\n    }\n};\nfunction shouldSetAsProp(el, key, value, isSVG) {\n    if (isSVG) {\n        // most keys must be set as attribute on svg elements to work\n        // ...except innerHTML & textContent\n        if (key === 'innerHTML' || key === 'textContent') {\n            return true;\n        }\n        // or native onclick with function values\n        if (key in el && nativeOnRE.test(key) && isFunction(value)) {\n            return true;\n        }\n        return false;\n    }\n    // these are enumerated attrs, however their corresponding DOM properties\n    // are actually booleans - this leads to setting it with a string \"false\"\n    // value leading it to be coerced to `true`, so we need to always treat\n    // them as attributes.\n    // Note that `contentEditable` doesn't have this problem: its DOM\n    // property is also enumerated string values.\n    if (key === 'spellcheck' || key === 'draggable' || key === 'translate') {\n        return false;\n    }\n    // #1787, #2840 form property on form elements is readonly and must be set as\n    // attribute.\n    if (key === 'form') {\n        return false;\n    }\n    // #1526 <input list> must be set as attribute\n    if (key === 'list' && el.tagName === 'INPUT') {\n        return false;\n    }\n    // #2766 <textarea type> must be set as attribute\n    if (key === 'type' && el.tagName === 'TEXTAREA') {\n        return false;\n    }\n    // native onclick with string value, must be set as attribute\n    if (nativeOnRE.test(key) && isString(value)) {\n        return false;\n    }\n    return key in el;\n}\n\nfunction defineCustomElement(options, hydrate) {\n    const Comp = defineComponent(options);\n    class VueCustomElement extends VueElement {\n        constructor(initialProps) {\n            super(Comp, initialProps, hydrate);\n        }\n    }\n    VueCustomElement.def = Comp;\n    return VueCustomElement;\n}\nconst defineSSRCustomElement = ((options) => {\n    // @ts-ignore\n    return defineCustomElement(options, hydrate);\n});\nconst BaseClass = (typeof HTMLElement !== 'undefined' ? HTMLElement : class {\n});\nclass VueElement extends BaseClass {\n    constructor(_def, _props = {}, hydrate) {\n        super();\n        this._def = _def;\n        this._props = _props;\n        /**\n         * @internal\n         */\n        this._instance = null;\n        this._connected = false;\n        this._resolved = false;\n        this._numberProps = null;\n        if (this.shadowRoot && hydrate) {\n            hydrate(this._createVNode(), this.shadowRoot);\n        }\n        else {\n            if ((process.env.NODE_ENV !== 'production') && this.shadowRoot) {\n                warn(`Custom element has pre-rendered declarative shadow root but is not ` +\n                    `defined as hydratable. Use \\`defineSSRCustomElement\\`.`);\n            }\n            this.attachShadow({ mode: 'open' });\n            if (!this._def.__asyncLoader) {\n                // for sync component defs we can immediately resolve props\n                this._resolveProps(this._def);\n            }\n        }\n    }\n    connectedCallback() {\n        this._connected = true;\n        if (!this._instance) {\n            if (this._resolved) {\n                this._update();\n            }\n            else {\n                this._resolveDef();\n            }\n        }\n    }\n    disconnectedCallback() {\n        this._connected = false;\n        nextTick(() => {\n            if (!this._connected) {\n                render(null, this.shadowRoot);\n                this._instance = null;\n            }\n        });\n    }\n    /**\n     * resolve inner component definition (handle possible async component)\n     */\n    _resolveDef() {\n        this._resolved = true;\n        // set initial attrs\n        for (let i = 0; i < this.attributes.length; i++) {\n            this._setAttr(this.attributes[i].name);\n        }\n        // watch future attr changes\n        new MutationObserver(mutations => {\n            for (const m of mutations) {\n                this._setAttr(m.attributeName);\n            }\n        }).observe(this, { attributes: true });\n        const resolve = (def, isAsync = false) => {\n            const { props, styles } = def;\n            // cast Number-type props set before resolve\n            let numberProps;\n            if (props && !isArray(props)) {\n                for (const key in props) {\n                    const opt = props[key];\n                    if (opt === Number || (opt && opt.type === Number)) {\n                        if (key in this._props) {\n                            this._props[key] = toNumber(this._props[key]);\n                        }\n                        (numberProps || (numberProps = Object.create(null)))[camelize$1(key)] = true;\n                    }\n                }\n            }\n            this._numberProps = numberProps;\n            if (isAsync) {\n                // defining getter/setters on prototype\n                // for sync defs, this already happened in the constructor\n                this._resolveProps(def);\n            }\n            // apply CSS\n            this._applyStyles(styles);\n            // initial render\n            this._update();\n        };\n        const asyncDef = this._def.__asyncLoader;\n        if (asyncDef) {\n            asyncDef().then(def => resolve(def, true));\n        }\n        else {\n            resolve(this._def);\n        }\n    }\n    _resolveProps(def) {\n        const { props } = def;\n        const declaredPropKeys = isArray(props) ? props : Object.keys(props || {});\n        // check if there are props set pre-upgrade or connect\n        for (const key of Object.keys(this)) {\n            if (key[0] !== '_' && declaredPropKeys.includes(key)) {\n                this._setProp(key, this[key], true, false);\n            }\n        }\n        // defining getter/setters on prototype\n        for (const key of declaredPropKeys.map(camelize$1)) {\n            Object.defineProperty(this, key, {\n                get() {\n                    return this._getProp(key);\n                },\n                set(val) {\n                    this._setProp(key, val);\n                }\n            });\n        }\n    }\n    _setAttr(key) {\n        let value = this.getAttribute(key);\n        const camelKey = camelize$1(key);\n        if (this._numberProps && this._numberProps[camelKey]) {\n            value = toNumber(value);\n        }\n        this._setProp(camelKey, value, false);\n    }\n    /**\n     * @internal\n     */\n    _getProp(key) {\n        return this._props[key];\n    }\n    /**\n     * @internal\n     */\n    _setProp(key, val, shouldReflect = true, shouldUpdate = true) {\n        if (val !== this._props[key]) {\n            this._props[key] = val;\n            if (shouldUpdate && this._instance) {\n                this._update();\n            }\n            // reflect\n            if (shouldReflect) {\n                if (val === true) {\n                    this.setAttribute(hyphenate(key), '');\n                }\n                else if (typeof val === 'string' || typeof val === 'number') {\n                    this.setAttribute(hyphenate(key), val + '');\n                }\n                else if (!val) {\n                    this.removeAttribute(hyphenate(key));\n                }\n            }\n        }\n    }\n    _update() {\n        render(this._createVNode(), this.shadowRoot);\n    }\n    _createVNode() {\n        const vnode = createVNode(this._def, extend({}, this._props));\n        if (!this._instance) {\n            vnode.ce = instance => {\n                this._instance = instance;\n                instance.isCE = true;\n                // HMR\n                if ((process.env.NODE_ENV !== 'production')) {\n                    instance.ceReload = newStyles => {\n                        // always reset styles\n                        if (this._styles) {\n                            this._styles.forEach(s => this.shadowRoot.removeChild(s));\n                            this._styles.length = 0;\n                        }\n                        this._applyStyles(newStyles);\n                        this._instance = null;\n                        this._update();\n                    };\n                }\n                const dispatch = (event, args) => {\n                    this.dispatchEvent(new CustomEvent(event, {\n                        detail: args\n                    }));\n                };\n                // intercept emit\n                instance.emit = (event, ...args) => {\n                    // dispatch both the raw and hyphenated versions of an event\n                    // to match Vue behavior\n                    dispatch(event, args);\n                    if (hyphenate(event) !== event) {\n                        dispatch(hyphenate(event), args);\n                    }\n                };\n                // locate nearest Vue custom element parent for provide/inject\n                let parent = this;\n                while ((parent =\n                    parent && (parent.parentNode || parent.host))) {\n                    if (parent instanceof VueElement) {\n                        instance.parent = parent._instance;\n                        instance.provides = parent._instance.provides;\n                        break;\n                    }\n                }\n            };\n        }\n        return vnode;\n    }\n    _applyStyles(styles) {\n        if (styles) {\n            styles.forEach(css => {\n                const s = document.createElement('style');\n                s.textContent = css;\n                this.shadowRoot.appendChild(s);\n                // record for HMR\n                if ((process.env.NODE_ENV !== 'production')) {\n                    (this._styles || (this._styles = [])).push(s);\n                }\n            });\n        }\n    }\n}\n\nfunction useCssModule(name = '$style') {\n    /* istanbul ignore else */\n    {\n        const instance = getCurrentInstance();\n        if (!instance) {\n            (process.env.NODE_ENV !== 'production') && warn(`useCssModule must be called inside setup()`);\n            return EMPTY_OBJ;\n        }\n        const modules = instance.type.__cssModules;\n        if (!modules) {\n            (process.env.NODE_ENV !== 'production') && warn(`Current instance does not have CSS modules injected.`);\n            return EMPTY_OBJ;\n        }\n        const mod = modules[name];\n        if (!mod) {\n            (process.env.NODE_ENV !== 'production') &&\n                warn(`Current instance does not have CSS module named \"${name}\".`);\n            return EMPTY_OBJ;\n        }\n        return mod;\n    }\n}\n\n/**\n * Runtime helper for SFC's CSS variable injection feature.\n * @private\n */\nfunction useCssVars(getter) {\n    const instance = getCurrentInstance();\n    /* istanbul ignore next */\n    if (!instance) {\n        (process.env.NODE_ENV !== 'production') &&\n            warn(`useCssVars is called without current active component instance.`);\n        return;\n    }\n    const updateTeleports = (instance.ut = (vars = getter(instance.proxy)) => {\n        Array.from(document.querySelectorAll(`[data-v-owner=\"${instance.uid}\"]`)).forEach(node => setVarsOnNode(node, vars));\n    });\n    const setVars = () => {\n        const vars = getter(instance.proxy);\n        setVarsOnVNode(instance.subTree, vars);\n        updateTeleports(vars);\n    };\n    watchPostEffect(setVars);\n    onMounted(() => {\n        const ob = new MutationObserver(setVars);\n        ob.observe(instance.subTree.el.parentNode, { childList: true });\n        onUnmounted(() => ob.disconnect());\n    });\n}\nfunction setVarsOnVNode(vnode, vars) {\n    if (vnode.shapeFlag & 128 /* ShapeFlags.SUSPENSE */) {\n        const suspense = vnode.suspense;\n        vnode = suspense.activeBranch;\n        if (suspense.pendingBranch && !suspense.isHydrating) {\n            suspense.effects.push(() => {\n                setVarsOnVNode(suspense.activeBranch, vars);\n            });\n        }\n    }\n    // drill down HOCs until it's a non-component vnode\n    while (vnode.component) {\n        vnode = vnode.component.subTree;\n    }\n    if (vnode.shapeFlag & 1 /* ShapeFlags.ELEMENT */ && vnode.el) {\n        setVarsOnNode(vnode.el, vars);\n    }\n    else if (vnode.type === Fragment) {\n        vnode.children.forEach(c => setVarsOnVNode(c, vars));\n    }\n    else if (vnode.type === Static) {\n        let { el, anchor } = vnode;\n        while (el) {\n            setVarsOnNode(el, vars);\n            if (el === anchor)\n                break;\n            el = el.nextSibling;\n        }\n    }\n}\nfunction setVarsOnNode(el, vars) {\n    if (el.nodeType === 1) {\n        const style = el.style;\n        for (const key in vars) {\n            style.setProperty(`--${key}`, vars[key]);\n        }\n    }\n}\n\nconst TRANSITION = 'transition';\nconst ANIMATION = 'animation';\n// DOM Transition is a higher-order-component based on the platform-agnostic\n// base Transition component, with DOM-specific logic.\nconst Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);\nTransition.displayName = 'Transition';\nconst DOMTransitionPropsValidators = {\n    name: String,\n    type: String,\n    css: {\n        type: Boolean,\n        default: true\n    },\n    duration: [String, Number, Object],\n    enterFromClass: String,\n    enterActiveClass: String,\n    enterToClass: String,\n    appearFromClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    leaveFromClass: String,\n    leaveActiveClass: String,\n    leaveToClass: String\n};\nconst TransitionPropsValidators = (Transition.props =\n    /*#__PURE__*/ extend({}, BaseTransition.props, DOMTransitionPropsValidators));\n/**\n * #3227 Incoming hooks may be merged into arrays when wrapping Transition\n * with custom HOCs.\n */\nconst callHook = (hook, args = []) => {\n    if (isArray(hook)) {\n        hook.forEach(h => h(...args));\n    }\n    else if (hook) {\n        hook(...args);\n    }\n};\n/**\n * Check if a hook expects a callback (2nd arg), which means the user\n * intends to explicitly control the end of the transition.\n */\nconst hasExplicitCallback = (hook) => {\n    return hook\n        ? isArray(hook)\n            ? hook.some(h => h.length > 1)\n            : hook.length > 1\n        : false;\n};\nfunction resolveTransitionProps(rawProps) {\n    const baseProps = {};\n    for (const key in rawProps) {\n        if (!(key in DOMTransitionPropsValidators)) {\n            baseProps[key] = rawProps[key];\n        }\n    }\n    if (rawProps.css === false) {\n        return baseProps;\n    }\n    const { name = 'v', type, duration, enterFromClass = `${name}-enter-from`, enterActiveClass = `${name}-enter-active`, enterToClass = `${name}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name}-leave-from`, leaveActiveClass = `${name}-leave-active`, leaveToClass = `${name}-leave-to` } = rawProps;\n    const durations = normalizeDuration(duration);\n    const enterDuration = durations && durations[0];\n    const leaveDuration = durations && durations[1];\n    const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;\n    const finishEnter = (el, isAppear, done) => {\n        removeTransitionClass(el, isAppear ? appearToClass : enterToClass);\n        removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);\n        done && done();\n    };\n    const finishLeave = (el, done) => {\n        el._isLeaving = false;\n        removeTransitionClass(el, leaveFromClass);\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n        done && done();\n    };\n    const makeEnterHook = (isAppear) => {\n        return (el, done) => {\n            const hook = isAppear ? onAppear : onEnter;\n            const resolve = () => finishEnter(el, isAppear, done);\n            callHook(hook, [el, resolve]);\n            nextFrame(() => {\n                removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);\n                addTransitionClass(el, isAppear ? appearToClass : enterToClass);\n                if (!hasExplicitCallback(hook)) {\n                    whenTransitionEnds(el, type, enterDuration, resolve);\n                }\n            });\n        };\n    };\n    return extend(baseProps, {\n        onBeforeEnter(el) {\n            callHook(onBeforeEnter, [el]);\n            addTransitionClass(el, enterFromClass);\n            addTransitionClass(el, enterActiveClass);\n        },\n        onBeforeAppear(el) {\n            callHook(onBeforeAppear, [el]);\n            addTransitionClass(el, appearFromClass);\n            addTransitionClass(el, appearActiveClass);\n        },\n        onEnter: makeEnterHook(false),\n        onAppear: makeEnterHook(true),\n        onLeave(el, done) {\n            el._isLeaving = true;\n            const resolve = () => finishLeave(el, done);\n            addTransitionClass(el, leaveFromClass);\n            // force reflow so *-leave-from classes immediately take effect (#2593)\n            forceReflow();\n            addTransitionClass(el, leaveActiveClass);\n            nextFrame(() => {\n                if (!el._isLeaving) {\n                    // cancelled\n                    return;\n                }\n                removeTransitionClass(el, leaveFromClass);\n                addTransitionClass(el, leaveToClass);\n                if (!hasExplicitCallback(onLeave)) {\n                    whenTransitionEnds(el, type, leaveDuration, resolve);\n                }\n            });\n            callHook(onLeave, [el, resolve]);\n        },\n        onEnterCancelled(el) {\n            finishEnter(el, false);\n            callHook(onEnterCancelled, [el]);\n        },\n        onAppearCancelled(el) {\n            finishEnter(el, true);\n            callHook(onAppearCancelled, [el]);\n        },\n        onLeaveCancelled(el) {\n            finishLeave(el);\n            callHook(onLeaveCancelled, [el]);\n        }\n    });\n}\nfunction normalizeDuration(duration) {\n    if (duration == null) {\n        return null;\n    }\n    else if (isObject(duration)) {\n        return [NumberOf(duration.enter), NumberOf(duration.leave)];\n    }\n    else {\n        const n = NumberOf(duration);\n        return [n, n];\n    }\n}\nfunction NumberOf(val) {\n    const res = toNumber(val);\n    if ((process.env.NODE_ENV !== 'production')) {\n        assertNumber(res, '<transition> explicit duration');\n    }\n    return res;\n}\nfunction addTransitionClass(el, cls) {\n    cls.split(/\\s+/).forEach(c => c && el.classList.add(c));\n    (el._vtc ||\n        (el._vtc = new Set())).add(cls);\n}\nfunction removeTransitionClass(el, cls) {\n    cls.split(/\\s+/).forEach(c => c && el.classList.remove(c));\n    const { _vtc } = el;\n    if (_vtc) {\n        _vtc.delete(cls);\n        if (!_vtc.size) {\n            el._vtc = undefined;\n        }\n    }\n}\nfunction nextFrame(cb) {\n    requestAnimationFrame(() => {\n        requestAnimationFrame(cb);\n    });\n}\nlet endId = 0;\nfunction whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {\n    const id = (el._endId = ++endId);\n    const resolveIfNotStale = () => {\n        if (id === el._endId) {\n            resolve();\n        }\n    };\n    if (explicitTimeout) {\n        return setTimeout(resolveIfNotStale, explicitTimeout);\n    }\n    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);\n    if (!type) {\n        return resolve();\n    }\n    const endEvent = type + 'end';\n    let ended = 0;\n    const end = () => {\n        el.removeEventListener(endEvent, onEnd);\n        resolveIfNotStale();\n    };\n    const onEnd = (e) => {\n        if (e.target === el && ++ended >= propCount) {\n            end();\n        }\n    };\n    setTimeout(() => {\n        if (ended < propCount) {\n            end();\n        }\n    }, timeout + 1);\n    el.addEventListener(endEvent, onEnd);\n}\nfunction getTransitionInfo(el, expectedType) {\n    const styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    const getStyleProperties = (key) => (styles[key] || '').split(', ');\n    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);\n    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);\n    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);\n    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);\n    const animationTimeout = getTimeout(animationDelays, animationDurations);\n    let type = null;\n    let timeout = 0;\n    let propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n        if (transitionTimeout > 0) {\n            type = TRANSITION;\n            timeout = transitionTimeout;\n            propCount = transitionDurations.length;\n        }\n    }\n    else if (expectedType === ANIMATION) {\n        if (animationTimeout > 0) {\n            type = ANIMATION;\n            timeout = animationTimeout;\n            propCount = animationDurations.length;\n        }\n    }\n    else {\n        timeout = Math.max(transitionTimeout, animationTimeout);\n        type =\n            timeout > 0\n                ? transitionTimeout > animationTimeout\n                    ? TRANSITION\n                    : ANIMATION\n                : null;\n        propCount = type\n            ? type === TRANSITION\n                ? transitionDurations.length\n                : animationDurations.length\n            : 0;\n    }\n    const hasTransform = type === TRANSITION &&\n        /\\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());\n    return {\n        type,\n        timeout,\n        propCount,\n        hasTransform\n    };\n}\nfunction getTimeout(delays, durations) {\n    while (delays.length < durations.length) {\n        delays = delays.concat(delays);\n    }\n    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));\n}\n// Old versions of Chromium (below 61.0.3163.100) formats floating pointer\n// numbers in a locale-dependent way, using a comma instead of a dot.\n// If comma is not replaced with a dot, the input will be rounded down\n// (i.e. acting as a floor function) causing unexpected behaviors\nfunction toMs(s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000;\n}\n// synchronously force layout to put elements into a certain state\nfunction forceReflow() {\n    return document.body.offsetHeight;\n}\n\nconst positionMap = new WeakMap();\nconst newPositionMap = new WeakMap();\nconst TransitionGroupImpl = {\n    name: 'TransitionGroup',\n    props: /*#__PURE__*/ extend({}, TransitionPropsValidators, {\n        tag: String,\n        moveClass: String\n    }),\n    setup(props, { slots }) {\n        const instance = getCurrentInstance();\n        const state = useTransitionState();\n        let prevChildren;\n        let children;\n        onUpdated(() => {\n            // children is guaranteed to exist after initial render\n            if (!prevChildren.length) {\n                return;\n            }\n            const moveClass = props.moveClass || `${props.name || 'v'}-move`;\n            if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {\n                return;\n            }\n            // we divide the work into three loops to avoid mixing DOM reads and writes\n            // in each iteration - which helps prevent layout thrashing.\n            prevChildren.forEach(callPendingCbs);\n            prevChildren.forEach(recordPosition);\n            const movedChildren = prevChildren.filter(applyTranslation);\n            // force reflow to put everything in position\n            forceReflow();\n            movedChildren.forEach(c => {\n                const el = c.el;\n                const style = el.style;\n                addTransitionClass(el, moveClass);\n                style.transform = style.webkitTransform = style.transitionDuration = '';\n                const cb = (el._moveCb = (e) => {\n                    if (e && e.target !== el) {\n                        return;\n                    }\n                    if (!e || /transform$/.test(e.propertyName)) {\n                        el.removeEventListener('transitionend', cb);\n                        el._moveCb = null;\n                        removeTransitionClass(el, moveClass);\n                    }\n                });\n                el.addEventListener('transitionend', cb);\n            });\n        });\n        return () => {\n            const rawProps = toRaw(props);\n            const cssTransitionProps = resolveTransitionProps(rawProps);\n            let tag = rawProps.tag || Fragment;\n            prevChildren = children;\n            children = slots.default ? getTransitionRawChildren(slots.default()) : [];\n            for (let i = 0; i < children.length; i++) {\n                const child = children[i];\n                if (child.key != null) {\n                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\n                }\n                else if ((process.env.NODE_ENV !== 'production')) {\n                    warn(`<TransitionGroup> children must be keyed.`);\n                }\n            }\n            if (prevChildren) {\n                for (let i = 0; i < prevChildren.length; i++) {\n                    const child = prevChildren[i];\n                    setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));\n                    positionMap.set(child, child.el.getBoundingClientRect());\n                }\n            }\n            return createVNode(tag, null, children);\n        };\n    }\n};\n/**\n * TransitionGroup does not support \"mode\" so we need to remove it from the\n * props declarations, but direct delete operation is considered a side effect\n * and will make the entire transition feature non-tree-shakeable, so we do it\n * in a function and mark the function's invocation as pure.\n */\nconst removeMode = (props) => delete props.mode;\n/*#__PURE__*/ removeMode(TransitionGroupImpl.props);\nconst TransitionGroup = TransitionGroupImpl;\nfunction callPendingCbs(c) {\n    const el = c.el;\n    if (el._moveCb) {\n        el._moveCb();\n    }\n    if (el._enterCb) {\n        el._enterCb();\n    }\n}\nfunction recordPosition(c) {\n    newPositionMap.set(c, c.el.getBoundingClientRect());\n}\nfunction applyTranslation(c) {\n    const oldPos = positionMap.get(c);\n    const newPos = newPositionMap.get(c);\n    const dx = oldPos.left - newPos.left;\n    const dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n        const s = c.el.style;\n        s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;\n        s.transitionDuration = '0s';\n        return c;\n    }\n}\nfunction hasCSSTransform(el, root, moveClass) {\n    // Detect whether an element with the move class applied has\n    // CSS transitions. Since the element may be inside an entering\n    // transition at this very moment, we make a clone of it and remove\n    // all other transition classes applied to ensure only the move class\n    // is applied.\n    const clone = el.cloneNode();\n    if (el._vtc) {\n        el._vtc.forEach(cls => {\n            cls.split(/\\s+/).forEach(c => c && clone.classList.remove(c));\n        });\n    }\n    moveClass.split(/\\s+/).forEach(c => c && clone.classList.add(c));\n    clone.style.display = 'none';\n    const container = (root.nodeType === 1 ? root : root.parentNode);\n    container.appendChild(clone);\n    const { hasTransform } = getTransitionInfo(clone);\n    container.removeChild(clone);\n    return hasTransform;\n}\n\nconst getModelAssigner = (vnode) => {\n    const fn = vnode.props['onUpdate:modelValue'] ||\n        (false );\n    return isArray(fn) ? value => invokeArrayFns(fn, value) : fn;\n};\nfunction onCompositionStart(e) {\n    e.target.composing = true;\n}\nfunction onCompositionEnd(e) {\n    const target = e.target;\n    if (target.composing) {\n        target.composing = false;\n        target.dispatchEvent(new Event('input'));\n    }\n}\n// We are exporting the v-model runtime directly as vnode hooks so that it can\n// be tree-shaken in case v-model is never used.\nconst vModelText = {\n    created(el, { modifiers: { lazy, trim, number } }, vnode) {\n        el._assign = getModelAssigner(vnode);\n        const castToNumber = number || (vnode.props && vnode.props.type === 'number');\n        addEventListener(el, lazy ? 'change' : 'input', e => {\n            if (e.target.composing)\n                return;\n            let domValue = el.value;\n            if (trim) {\n                domValue = domValue.trim();\n            }\n            if (castToNumber) {\n                domValue = looseToNumber(domValue);\n            }\n            el._assign(domValue);\n        });\n        if (trim) {\n            addEventListener(el, 'change', () => {\n                el.value = el.value.trim();\n            });\n        }\n        if (!lazy) {\n            addEventListener(el, 'compositionstart', onCompositionStart);\n            addEventListener(el, 'compositionend', onCompositionEnd);\n            // Safari < 10.2 & UIWebView doesn't fire compositionend when\n            // switching focus before confirming composition choice\n            // this also fixes the issue where some browsers e.g. iOS Chrome\n            // fires \"change\" instead of \"input\" on autocomplete.\n            addEventListener(el, 'change', onCompositionEnd);\n        }\n    },\n    // set value on mounted so it's after min/max for type=\"range\"\n    mounted(el, { value }) {\n        el.value = value == null ? '' : value;\n    },\n    beforeUpdate(el, { value, modifiers: { lazy, trim, number } }, vnode) {\n        el._assign = getModelAssigner(vnode);\n        // avoid clearing unresolved text. #2302\n        if (el.composing)\n            return;\n        if (document.activeElement === el && el.type !== 'range') {\n            if (lazy) {\n                return;\n            }\n            if (trim && el.value.trim() === value) {\n                return;\n            }\n            if ((number || el.type === 'number') &&\n                looseToNumber(el.value) === value) {\n                return;\n            }\n        }\n        const newValue = value == null ? '' : value;\n        if (el.value !== newValue) {\n            el.value = newValue;\n        }\n    }\n};\nconst vModelCheckbox = {\n    // #4096 array checkboxes need to be deep traversed\n    deep: true,\n    created(el, _, vnode) {\n        el._assign = getModelAssigner(vnode);\n        addEventListener(el, 'change', () => {\n            const modelValue = el._modelValue;\n            const elementValue = getValue(el);\n            const checked = el.checked;\n            const assign = el._assign;\n            if (isArray(modelValue)) {\n                const index = looseIndexOf(modelValue, elementValue);\n                const found = index !== -1;\n                if (checked && !found) {\n                    assign(modelValue.concat(elementValue));\n                }\n                else if (!checked && found) {\n                    const filtered = [...modelValue];\n                    filtered.splice(index, 1);\n                    assign(filtered);\n                }\n            }\n            else if (isSet(modelValue)) {\n                const cloned = new Set(modelValue);\n                if (checked) {\n                    cloned.add(elementValue);\n                }\n                else {\n                    cloned.delete(elementValue);\n                }\n                assign(cloned);\n            }\n            else {\n                assign(getCheckboxValue(el, checked));\n            }\n        });\n    },\n    // set initial checked on mount to wait for true-value/false-value\n    mounted: setChecked,\n    beforeUpdate(el, binding, vnode) {\n        el._assign = getModelAssigner(vnode);\n        setChecked(el, binding, vnode);\n    }\n};\nfunction setChecked(el, { value, oldValue }, vnode) {\n    el._modelValue = value;\n    if (isArray(value)) {\n        el.checked = looseIndexOf(value, vnode.props.value) > -1;\n    }\n    else if (isSet(value)) {\n        el.checked = value.has(vnode.props.value);\n    }\n    else if (value !== oldValue) {\n        el.checked = looseEqual(value, getCheckboxValue(el, true));\n    }\n}\nconst vModelRadio = {\n    created(el, { value }, vnode) {\n        el.checked = looseEqual(value, vnode.props.value);\n        el._assign = getModelAssigner(vnode);\n        addEventListener(el, 'change', () => {\n            el._assign(getValue(el));\n        });\n    },\n    beforeUpdate(el, { value, oldValue }, vnode) {\n        el._assign = getModelAssigner(vnode);\n        if (value !== oldValue) {\n            el.checked = looseEqual(value, vnode.props.value);\n        }\n    }\n};\nconst vModelSelect = {\n    // <select multiple> value need to be deep traversed\n    deep: true,\n    created(el, { value, modifiers: { number } }, vnode) {\n        const isSetModel = isSet(value);\n        addEventListener(el, 'change', () => {\n            const selectedVal = Array.prototype.filter\n                .call(el.options, (o) => o.selected)\n                .map((o) => number ? looseToNumber(getValue(o)) : getValue(o));\n            el._assign(el.multiple\n                ? isSetModel\n                    ? new Set(selectedVal)\n                    : selectedVal\n                : selectedVal[0]);\n        });\n        el._assign = getModelAssigner(vnode);\n    },\n    // set value in mounted & updated because <select> relies on its children\n    // <option>s.\n    mounted(el, { value }) {\n        setSelected(el, value);\n    },\n    beforeUpdate(el, _binding, vnode) {\n        el._assign = getModelAssigner(vnode);\n    },\n    updated(el, { value }) {\n        setSelected(el, value);\n    }\n};\nfunction setSelected(el, value) {\n    const isMultiple = el.multiple;\n    if (isMultiple && !isArray(value) && !isSet(value)) {\n        (process.env.NODE_ENV !== 'production') &&\n            warn(`<select multiple v-model> expects an Array or Set value for its binding, ` +\n                `but got ${Object.prototype.toString.call(value).slice(8, -1)}.`);\n        return;\n    }\n    for (let i = 0, l = el.options.length; i < l; i++) {\n        const option = el.options[i];\n        const optionValue = getValue(option);\n        if (isMultiple) {\n            if (isArray(value)) {\n                option.selected = looseIndexOf(value, optionValue) > -1;\n            }\n            else {\n                option.selected = value.has(optionValue);\n            }\n        }\n        else {\n            if (looseEqual(getValue(option), value)) {\n                if (el.selectedIndex !== i)\n                    el.selectedIndex = i;\n                return;\n            }\n        }\n    }\n    if (!isMultiple && el.selectedIndex !== -1) {\n        el.selectedIndex = -1;\n    }\n}\n// retrieve raw value set via :value bindings\nfunction getValue(el) {\n    return '_value' in el ? el._value : el.value;\n}\n// retrieve raw value for true-value and false-value set via :true-value or :false-value bindings\nfunction getCheckboxValue(el, checked) {\n    const key = checked ? '_trueValue' : '_falseValue';\n    return key in el ? el[key] : checked;\n}\nconst vModelDynamic = {\n    created(el, binding, vnode) {\n        callModelHook(el, binding, vnode, null, 'created');\n    },\n    mounted(el, binding, vnode) {\n        callModelHook(el, binding, vnode, null, 'mounted');\n    },\n    beforeUpdate(el, binding, vnode, prevVNode) {\n        callModelHook(el, binding, vnode, prevVNode, 'beforeUpdate');\n    },\n    updated(el, binding, vnode, prevVNode) {\n        callModelHook(el, binding, vnode, prevVNode, 'updated');\n    }\n};\nfunction resolveDynamicModel(tagName, type) {\n    switch (tagName) {\n        case 'SELECT':\n            return vModelSelect;\n        case 'TEXTAREA':\n            return vModelText;\n        default:\n            switch (type) {\n                case 'checkbox':\n                    return vModelCheckbox;\n                case 'radio':\n                    return vModelRadio;\n                default:\n                    return vModelText;\n            }\n    }\n}\nfunction callModelHook(el, binding, vnode, prevVNode, hook) {\n    const modelToUse = resolveDynamicModel(el.tagName, vnode.props && vnode.props.type);\n    const fn = modelToUse[hook];\n    fn && fn(el, binding, vnode, prevVNode);\n}\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nfunction initVModelForSSR() {\n    vModelText.getSSRProps = ({ value }) => ({ value });\n    vModelRadio.getSSRProps = ({ value }, vnode) => {\n        if (vnode.props && looseEqual(vnode.props.value, value)) {\n            return { checked: true };\n        }\n    };\n    vModelCheckbox.getSSRProps = ({ value }, vnode) => {\n        if (isArray(value)) {\n            if (vnode.props && looseIndexOf(value, vnode.props.value) > -1) {\n                return { checked: true };\n            }\n        }\n        else if (isSet(value)) {\n            if (vnode.props && value.has(vnode.props.value)) {\n                return { checked: true };\n            }\n        }\n        else if (value) {\n            return { checked: true };\n        }\n    };\n    vModelDynamic.getSSRProps = (binding, vnode) => {\n        if (typeof vnode.type !== 'string') {\n            return;\n        }\n        const modelToUse = resolveDynamicModel(\n        // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase\n        vnode.type.toUpperCase(), vnode.props && vnode.props.type);\n        if (modelToUse.getSSRProps) {\n            return modelToUse.getSSRProps(binding, vnode);\n        }\n    };\n}\n\nconst systemModifiers = ['ctrl', 'shift', 'alt', 'meta'];\nconst modifierGuards = {\n    stop: e => e.stopPropagation(),\n    prevent: e => e.preventDefault(),\n    self: e => e.target !== e.currentTarget,\n    ctrl: e => !e.ctrlKey,\n    shift: e => !e.shiftKey,\n    alt: e => !e.altKey,\n    meta: e => !e.metaKey,\n    left: e => 'button' in e && e.button !== 0,\n    middle: e => 'button' in e && e.button !== 1,\n    right: e => 'button' in e && e.button !== 2,\n    exact: (e, modifiers) => systemModifiers.some(m => e[`${m}Key`] && !modifiers.includes(m))\n};\n/**\n * @private\n */\nconst withModifiers = (fn, modifiers) => {\n    return (event, ...args) => {\n        for (let i = 0; i < modifiers.length; i++) {\n            const guard = modifierGuards[modifiers[i]];\n            if (guard && guard(event, modifiers))\n                return;\n        }\n        return fn(event, ...args);\n    };\n};\n// Kept for 2.x compat.\n// Note: IE11 compat for `spacebar` and `del` is removed for now.\nconst keyNames = {\n    esc: 'escape',\n    space: ' ',\n    up: 'arrow-up',\n    left: 'arrow-left',\n    right: 'arrow-right',\n    down: 'arrow-down',\n    delete: 'backspace'\n};\n/**\n * @private\n */\nconst withKeys = (fn, modifiers) => {\n    return (event) => {\n        if (!('key' in event)) {\n            return;\n        }\n        const eventKey = hyphenate(event.key);\n        if (modifiers.some(k => k === eventKey || keyNames[k] === eventKey)) {\n            return fn(event);\n        }\n    };\n};\n\nconst vShow = {\n    beforeMount(el, { value }, { transition }) {\n        el._vod = el.style.display === 'none' ? '' : el.style.display;\n        if (transition && value) {\n            transition.beforeEnter(el);\n        }\n        else {\n            setDisplay(el, value);\n        }\n    },\n    mounted(el, { value }, { transition }) {\n        if (transition && value) {\n            transition.enter(el);\n        }\n    },\n    updated(el, { value, oldValue }, { transition }) {\n        if (!value === !oldValue)\n            return;\n        if (transition) {\n            if (value) {\n                transition.beforeEnter(el);\n                setDisplay(el, true);\n                transition.enter(el);\n            }\n            else {\n                transition.leave(el, () => {\n                    setDisplay(el, false);\n                });\n            }\n        }\n        else {\n            setDisplay(el, value);\n        }\n    },\n    beforeUnmount(el, { value }) {\n        setDisplay(el, value);\n    }\n};\nfunction setDisplay(el, value) {\n    el.style.display = value ? el._vod : 'none';\n}\n// SSR vnode transforms, only used when user includes client-oriented render\n// function in SSR\nfunction initVShowForSSR() {\n    vShow.getSSRProps = ({ value }) => {\n        if (!value) {\n            return { style: { display: 'none' } };\n        }\n    };\n}\n\nconst rendererOptions = /*#__PURE__*/ extend({ patchProp }, nodeOps);\n// lazy create the renderer - this makes core renderer logic tree-shakable\n// in case the user only imports reactivity utilities from Vue.\nlet renderer;\nlet enabledHydration = false;\nfunction ensureRenderer() {\n    return (renderer ||\n        (renderer = createRenderer(rendererOptions)));\n}\nfunction ensureHydrationRenderer() {\n    renderer = enabledHydration\n        ? renderer\n        : createHydrationRenderer(rendererOptions);\n    enabledHydration = true;\n    return renderer;\n}\n// use explicit type casts here to avoid import() calls in rolled-up d.ts\nconst render = ((...args) => {\n    ensureRenderer().render(...args);\n});\nconst hydrate = ((...args) => {\n    ensureHydrationRenderer().hydrate(...args);\n});\nconst createApp = ((...args) => {\n    const app = ensureRenderer().createApp(...args);\n    if ((process.env.NODE_ENV !== 'production')) {\n        injectNativeTagCheck(app);\n        injectCompilerOptionsCheck(app);\n    }\n    const { mount } = app;\n    app.mount = (containerOrSelector) => {\n        const container = normalizeContainer(containerOrSelector);\n        if (!container)\n            return;\n        const component = app._component;\n        if (!isFunction(component) && !component.render && !component.template) {\n            // __UNSAFE__\n            // Reason: potential execution of JS expressions in in-DOM template.\n            // The user must make sure the in-DOM template is trusted. If it's\n            // rendered by the server, the template should not contain any user data.\n            component.template = container.innerHTML;\n        }\n        // clear content before mounting\n        container.innerHTML = '';\n        const proxy = mount(container, false, container instanceof SVGElement);\n        if (container instanceof Element) {\n            container.removeAttribute('v-cloak');\n            container.setAttribute('data-v-app', '');\n        }\n        return proxy;\n    };\n    return app;\n});\nconst createSSRApp = ((...args) => {\n    const app = ensureHydrationRenderer().createApp(...args);\n    if ((process.env.NODE_ENV !== 'production')) {\n        injectNativeTagCheck(app);\n        injectCompilerOptionsCheck(app);\n    }\n    const { mount } = app;\n    app.mount = (containerOrSelector) => {\n        const container = normalizeContainer(containerOrSelector);\n        if (container) {\n            return mount(container, true, container instanceof SVGElement);\n        }\n    };\n    return app;\n});\nfunction injectNativeTagCheck(app) {\n    // Inject `isNativeTag`\n    // this is used for component name validation (dev only)\n    Object.defineProperty(app.config, 'isNativeTag', {\n        value: (tag) => isHTMLTag(tag) || isSVGTag(tag),\n        writable: false\n    });\n}\n// dev only\nfunction injectCompilerOptionsCheck(app) {\n    if (isRuntimeOnly()) {\n        const isCustomElement = app.config.isCustomElement;\n        Object.defineProperty(app.config, 'isCustomElement', {\n            get() {\n                return isCustomElement;\n            },\n            set() {\n                warn(`The \\`isCustomElement\\` config option is deprecated. Use ` +\n                    `\\`compilerOptions.isCustomElement\\` instead.`);\n            }\n        });\n        const compilerOptions = app.config.compilerOptions;\n        const msg = `The \\`compilerOptions\\` config option is only respected when using ` +\n            `a build of Vue.js that includes the runtime compiler (aka \"full build\"). ` +\n            `Since you are using the runtime-only build, \\`compilerOptions\\` ` +\n            `must be passed to \\`@vue/compiler-dom\\` in the build setup instead.\\n` +\n            `- For vue-loader: pass it via vue-loader's \\`compilerOptions\\` loader option.\\n` +\n            `- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\\n` +\n            `- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-dom`;\n        Object.defineProperty(app.config, 'compilerOptions', {\n            get() {\n                warn(msg);\n                return compilerOptions;\n            },\n            set() {\n                warn(msg);\n            }\n        });\n    }\n}\nfunction normalizeContainer(container) {\n    if (isString(container)) {\n        const res = document.querySelector(container);\n        if ((process.env.NODE_ENV !== 'production') && !res) {\n            warn(`Failed to mount app: mount target selector \"${container}\" returned null.`);\n        }\n        return res;\n    }\n    if ((process.env.NODE_ENV !== 'production') &&\n        window.ShadowRoot &&\n        container instanceof window.ShadowRoot &&\n        container.mode === 'closed') {\n        warn(`mounting on a ShadowRoot with \\`{mode: \"closed\"}\\` may lead to unpredictable bugs`);\n    }\n    return container;\n}\nlet ssrDirectiveInitialized = false;\n/**\n * @internal\n */\nconst initDirectivesForSSR = () => {\n        if (!ssrDirectiveInitialized) {\n            ssrDirectiveInitialized = true;\n            initVModelForSSR();\n            initVShowForSSR();\n        }\n    }\n    ;\n\nexport { Transition, TransitionGroup, VueElement, createApp, createSSRApp, defineCustomElement, defineSSRCustomElement, hydrate, initDirectivesForSSR, render, useCssModule, useCssVars, vModelCheckbox, vModelDynamic, vModelRadio, vModelSelect, vModelText, vShow, withKeys, withModifiers };\n","/**\n * Make a map and return a function for checking if a key\n * is in that map.\n * IMPORTANT: all calls of this function must be prefixed with\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\n * So that rollup can tree-shake them if necessary.\n */\nfunction makeMap(str, expectsLowerCase) {\n    const map = Object.create(null);\n    const list = str.split(',');\n    for (let i = 0; i < list.length; i++) {\n        map[list[i]] = true;\n    }\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\n}\n\n/**\n * dev only flag -> name mapping\n */\nconst PatchFlagNames = {\n    [1 /* PatchFlags.TEXT */]: `TEXT`,\n    [2 /* PatchFlags.CLASS */]: `CLASS`,\n    [4 /* PatchFlags.STYLE */]: `STYLE`,\n    [8 /* PatchFlags.PROPS */]: `PROPS`,\n    [16 /* PatchFlags.FULL_PROPS */]: `FULL_PROPS`,\n    [32 /* PatchFlags.HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\n    [64 /* PatchFlags.STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\n    [128 /* PatchFlags.KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\n    [256 /* PatchFlags.UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\n    [512 /* PatchFlags.NEED_PATCH */]: `NEED_PATCH`,\n    [1024 /* PatchFlags.DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\n    [2048 /* PatchFlags.DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\n    [-1 /* PatchFlags.HOISTED */]: `HOISTED`,\n    [-2 /* PatchFlags.BAIL */]: `BAIL`\n};\n\n/**\n * Dev only\n */\nconst slotFlagsText = {\n    [1 /* SlotFlags.STABLE */]: 'STABLE',\n    [2 /* SlotFlags.DYNAMIC */]: 'DYNAMIC',\n    [3 /* SlotFlags.FORWARDED */]: 'FORWARDED'\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt';\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\nfunction generateCodeFrame(source, start = 0, end = source.length) {\n    // Split the content into individual lines but capture the newline sequence\n    // that separated each line. This is important because the actual sequence is\n    // needed to properly take into account the full line length for offset\n    // comparison\n    let lines = source.split(/(\\r?\\n)/);\n    // Separate the lines and newline sequences into separate arrays for easier referencing\n    const newlineSequences = lines.filter((_, idx) => idx % 2 === 1);\n    lines = lines.filter((_, idx) => idx % 2 === 0);\n    let count = 0;\n    const res = [];\n    for (let i = 0; i < lines.length; i++) {\n        count +=\n            lines[i].length +\n                ((newlineSequences[i] && newlineSequences[i].length) || 0);\n        if (count >= start) {\n            for (let j = i - range; j <= i + range || end > count; j++) {\n                if (j < 0 || j >= lines.length)\n                    continue;\n                const line = j + 1;\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\n                const lineLength = lines[j].length;\n                const newLineSeqLength = (newlineSequences[j] && newlineSequences[j].length) || 0;\n                if (j === i) {\n                    // push underline\n                    const pad = start - (count - (lineLength + newLineSeqLength));\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\n                }\n                else if (j > i) {\n                    if (end > count) {\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\n                        res.push(`   |  ` + '^'.repeat(length));\n                    }\n                    count += lineLength + newLineSeqLength;\n                }\n            }\n            break;\n        }\n    }\n    return res.join('\\n');\n}\n\nfunction normalizeStyle(value) {\n    if (isArray(value)) {\n        const res = {};\n        for (let i = 0; i < value.length; i++) {\n            const item = value[i];\n            const normalized = isString(item)\n                ? parseStringStyle(item)\n                : normalizeStyle(item);\n            if (normalized) {\n                for (const key in normalized) {\n                    res[key] = normalized[key];\n                }\n            }\n        }\n        return res;\n    }\n    else if (isString(value)) {\n        return value;\n    }\n    else if (isObject(value)) {\n        return value;\n    }\n}\nconst listDelimiterRE = /;(?![^(]*\\))/g;\nconst propertyDelimiterRE = /:([^]+)/;\nconst styleCommentRE = /\\/\\*.*?\\*\\//gs;\nfunction parseStringStyle(cssText) {\n    const ret = {};\n    cssText\n        .replace(styleCommentRE, '')\n        .split(listDelimiterRE)\n        .forEach(item => {\n        if (item) {\n            const tmp = item.split(propertyDelimiterRE);\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\n        }\n    });\n    return ret;\n}\nfunction stringifyStyle(styles) {\n    let ret = '';\n    if (!styles || isString(styles)) {\n        return ret;\n    }\n    for (const key in styles) {\n        const value = styles[key];\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\n        if (isString(value) || typeof value === 'number') {\n            // only render valid values\n            ret += `${normalizedKey}:${value};`;\n        }\n    }\n    return ret;\n}\nfunction normalizeClass(value) {\n    let res = '';\n    if (isString(value)) {\n        res = value;\n    }\n    else if (isArray(value)) {\n        for (let i = 0; i < value.length; i++) {\n            const normalized = normalizeClass(value[i]);\n            if (normalized) {\n                res += normalized + ' ';\n            }\n        }\n    }\n    else if (isObject(value)) {\n        for (const name in value) {\n            if (value[name]) {\n                res += name + ' ';\n            }\n        }\n    }\n    return res.trim();\n}\nfunction normalizeProps(props) {\n    if (!props)\n        return null;\n    let { class: klass, style } = props;\n    if (klass && !isString(klass)) {\n        props.class = normalizeClass(klass);\n    }\n    if (style) {\n        props.style = normalizeStyle(style);\n    }\n    return props;\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\n    'header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,' +\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\n    'data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,' +\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\n    'option,output,progress,select,textarea,details,dialog,menu,' +\n    'summary,template,blockquote,iframe,tfoot';\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\n    'feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\n    'text,textPath,title,tspan,unknown,use,view';\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\n/**\n * Compiler only.\n * Do NOT use in runtime code paths unless behind `(process.env.NODE_ENV !== 'production')` flag.\n */\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\n/**\n * On the client we only need to offer special cases for boolean attributes that\n * have different names from their corresponding dom properties:\n * - itemscope -> N/A\n * - allowfullscreen -> allowFullscreen\n * - formnovalidate -> formNoValidate\n * - ismap -> isMap\n * - nomodule -> noModule\n * - novalidate -> noValidate\n * - readonly -> readOnly\n */\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\n/**\n * The full list is needed during SSR to produce the correct initial markup.\n */\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\n    `loop,open,required,reversed,scoped,seamless,` +\n    `checked,muted,multiple,selected`);\n/**\n * Boolean attributes should be included if the value is truthy or ''.\n * e.g. `<select multiple>` compiles to `{ multiple: '' }`\n */\nfunction includeBooleanAttr(value) {\n    return !!value || value === '';\n}\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\nconst attrValidationCache = {};\nfunction isSSRSafeAttrName(name) {\n    if (attrValidationCache.hasOwnProperty(name)) {\n        return attrValidationCache[name];\n    }\n    const isUnsafe = unsafeAttrCharRE.test(name);\n    if (isUnsafe) {\n        console.error(`unsafe attribute name: ${name}`);\n    }\n    return (attrValidationCache[name] = !isUnsafe);\n}\nconst propsToAttrMap = {\n    acceptCharset: 'accept-charset',\n    className: 'class',\n    htmlFor: 'for',\n    httpEquiv: 'http-equiv'\n};\n/**\n * Known attributes, this is used for stringification of runtime static nodes\n * so that we don't stringify bindings that cannot be set from HTML.\n * Don't also forget to allow `data-*` and `aria-*`!\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n */\nconst isKnownHtmlAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\n    `value,width,wrap`);\n/**\n * Generated from https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute\n */\nconst isKnownSvgAttr = /*#__PURE__*/ makeMap(`xmlns,accent-height,accumulate,additive,alignment-baseline,alphabetic,amplitude,` +\n    `arabic-form,ascent,attributeName,attributeType,azimuth,baseFrequency,` +\n    `baseline-shift,baseProfile,bbox,begin,bias,by,calcMode,cap-height,class,` +\n    `clip,clipPathUnits,clip-path,clip-rule,color,color-interpolation,` +\n    `color-interpolation-filters,color-profile,color-rendering,` +\n    `contentScriptType,contentStyleType,crossorigin,cursor,cx,cy,d,decelerate,` +\n    `descent,diffuseConstant,direction,display,divisor,dominant-baseline,dur,dx,` +\n    `dy,edgeMode,elevation,enable-background,end,exponent,fill,fill-opacity,` +\n    `fill-rule,filter,filterRes,filterUnits,flood-color,flood-opacity,` +\n    `font-family,font-size,font-size-adjust,font-stretch,font-style,` +\n    `font-variant,font-weight,format,from,fr,fx,fy,g1,g2,glyph-name,` +\n    `glyph-orientation-horizontal,glyph-orientation-vertical,glyphRef,` +\n    `gradientTransform,gradientUnits,hanging,height,href,hreflang,horiz-adv-x,` +\n    `horiz-origin-x,id,ideographic,image-rendering,in,in2,intercept,k,k1,k2,k3,` +\n    `k4,kernelMatrix,kernelUnitLength,kerning,keyPoints,keySplines,keyTimes,` +\n    `lang,lengthAdjust,letter-spacing,lighting-color,limitingConeAngle,local,` +\n    `marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,` +\n    `mask,maskContentUnits,maskUnits,mathematical,max,media,method,min,mode,` +\n    `name,numOctaves,offset,opacity,operator,order,orient,orientation,origin,` +\n    `overflow,overline-position,overline-thickness,panose-1,paint-order,path,` +\n    `pathLength,patternContentUnits,patternTransform,patternUnits,ping,` +\n    `pointer-events,points,pointsAtX,pointsAtY,pointsAtZ,preserveAlpha,` +\n    `preserveAspectRatio,primitiveUnits,r,radius,referrerPolicy,refX,refY,rel,` +\n    `rendering-intent,repeatCount,repeatDur,requiredExtensions,requiredFeatures,` +\n    `restart,result,rotate,rx,ry,scale,seed,shape-rendering,slope,spacing,` +\n    `specularConstant,specularExponent,speed,spreadMethod,startOffset,` +\n    `stdDeviation,stemh,stemv,stitchTiles,stop-color,stop-opacity,` +\n    `strikethrough-position,strikethrough-thickness,string,stroke,` +\n    `stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,` +\n    `stroke-miterlimit,stroke-opacity,stroke-width,style,surfaceScale,` +\n    `systemLanguage,tabindex,tableValues,target,targetX,targetY,text-anchor,` +\n    `text-decoration,text-rendering,textLength,to,transform,transform-origin,` +\n    `type,u1,u2,underline-position,underline-thickness,unicode,unicode-bidi,` +\n    `unicode-range,units-per-em,v-alphabetic,v-hanging,v-ideographic,` +\n    `v-mathematical,values,vector-effect,version,vert-adv-y,vert-origin-x,` +\n    `vert-origin-y,viewBox,viewTarget,visibility,width,widths,word-spacing,` +\n    `writing-mode,x,x-height,x1,x2,xChannelSelector,xlink:actuate,xlink:arcrole,` +\n    `xlink:href,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,` +\n    `xml:space,y,y1,y2,yChannelSelector,z,zoomAndPan`);\n\nconst escapeRE = /[\"'&<>]/;\nfunction escapeHtml(string) {\n    const str = '' + string;\n    const match = escapeRE.exec(str);\n    if (!match) {\n        return str;\n    }\n    let html = '';\n    let escaped;\n    let index;\n    let lastIndex = 0;\n    for (index = match.index; index < str.length; index++) {\n        switch (str.charCodeAt(index)) {\n            case 34: // \"\n                escaped = '&quot;';\n                break;\n            case 38: // &\n                escaped = '&amp;';\n                break;\n            case 39: // '\n                escaped = '&#39;';\n                break;\n            case 60: // <\n                escaped = '&lt;';\n                break;\n            case 62: // >\n                escaped = '&gt;';\n                break;\n            default:\n                continue;\n        }\n        if (lastIndex !== index) {\n            html += str.slice(lastIndex, index);\n        }\n        lastIndex = index + 1;\n        html += escaped;\n    }\n    return lastIndex !== index ? html + str.slice(lastIndex, index) : html;\n}\n// https://www.w3.org/TR/html52/syntax.html#comments\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\nfunction escapeHtmlComment(src) {\n    return src.replace(commentStripRE, '');\n}\n\nfunction looseCompareArrays(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let equal = true;\n    for (let i = 0; equal && i < a.length; i++) {\n        equal = looseEqual(a[i], b[i]);\n    }\n    return equal;\n}\nfunction looseEqual(a, b) {\n    if (a === b)\n        return true;\n    let aValidType = isDate(a);\n    let bValidType = isDate(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\n    }\n    aValidType = isSymbol(a);\n    bValidType = isSymbol(b);\n    if (aValidType || bValidType) {\n        return a === b;\n    }\n    aValidType = isArray(a);\n    bValidType = isArray(b);\n    if (aValidType || bValidType) {\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\n    }\n    aValidType = isObject(a);\n    bValidType = isObject(b);\n    if (aValidType || bValidType) {\n        /* istanbul ignore if: this if will probably never be called */\n        if (!aValidType || !bValidType) {\n            return false;\n        }\n        const aKeysCount = Object.keys(a).length;\n        const bKeysCount = Object.keys(b).length;\n        if (aKeysCount !== bKeysCount) {\n            return false;\n        }\n        for (const key in a) {\n            const aHasKey = a.hasOwnProperty(key);\n            const bHasKey = b.hasOwnProperty(key);\n            if ((aHasKey && !bHasKey) ||\n                (!aHasKey && bHasKey) ||\n                !looseEqual(a[key], b[key])) {\n                return false;\n            }\n        }\n    }\n    return String(a) === String(b);\n}\nfunction looseIndexOf(arr, val) {\n    return arr.findIndex(item => looseEqual(item, val));\n}\n\n/**\n * For converting {{ interpolation }} values to displayed strings.\n * @private\n */\nconst toDisplayString = (val) => {\n    return isString(val)\n        ? val\n        : val == null\n            ? ''\n            : isArray(val) ||\n                (isObject(val) &&\n                    (val.toString === objectToString || !isFunction(val.toString)))\n                ? JSON.stringify(val, replacer, 2)\n                : String(val);\n};\nconst replacer = (_key, val) => {\n    // can't use isRef here since @vue/shared has no deps\n    if (val && val.__v_isRef) {\n        return replacer(_key, val.value);\n    }\n    else if (isMap(val)) {\n        return {\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\n                entries[`${key} =>`] = val;\n                return entries;\n            }, {})\n        };\n    }\n    else if (isSet(val)) {\n        return {\n            [`Set(${val.size})`]: [...val.values()]\n        };\n    }\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\n        return String(val);\n    }\n    return val;\n};\n\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\n    ? Object.freeze({})\n    : {};\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\nconst NOOP = () => { };\n/**\n * Always return false.\n */\nconst NO = () => false;\nconst onRE = /^on[^a-z]/;\nconst isOn = (key) => onRE.test(key);\nconst isModelListener = (key) => key.startsWith('onUpdate:');\nconst extend = Object.assign;\nconst remove = (arr, el) => {\n    const i = arr.indexOf(el);\n    if (i > -1) {\n        arr.splice(i, 1);\n    }\n};\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\nconst isArray = Array.isArray;\nconst isMap = (val) => toTypeString(val) === '[object Map]';\nconst isSet = (val) => toTypeString(val) === '[object Set]';\nconst isDate = (val) => toTypeString(val) === '[object Date]';\nconst isRegExp = (val) => toTypeString(val) === '[object RegExp]';\nconst isFunction = (val) => typeof val === 'function';\nconst isString = (val) => typeof val === 'string';\nconst isSymbol = (val) => typeof val === 'symbol';\nconst isObject = (val) => val !== null && typeof val === 'object';\nconst isPromise = (val) => {\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\n};\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nconst toRawType = (value) => {\n    // extract \"RawType\" from strings like \"[object RawType]\"\n    return toTypeString(value).slice(8, -1);\n};\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\nconst isIntegerKey = (key) => isString(key) &&\n    key !== 'NaN' &&\n    key[0] !== '-' &&\n    '' + parseInt(key, 10) === key;\nconst isReservedProp = /*#__PURE__*/ makeMap(\n// the leading comma is intentional so empty string \"\" is also included\n',key,ref,ref_for,ref_key,' +\n    'onVnodeBeforeMount,onVnodeMounted,' +\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\nconst isBuiltInDirective = /*#__PURE__*/ makeMap('bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo');\nconst cacheStringFunction = (fn) => {\n    const cache = Object.create(null);\n    return ((str) => {\n        const hit = cache[str];\n        return hit || (cache[str] = fn(str));\n    });\n};\nconst camelizeRE = /-(\\w)/g;\n/**\n * @private\n */\nconst camelize = cacheStringFunction((str) => {\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\n});\nconst hyphenateRE = /\\B([A-Z])/g;\n/**\n * @private\n */\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\n/**\n * @private\n */\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\n/**\n * @private\n */\nconst toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);\n// compare whether a value has changed, accounting for NaN.\nconst hasChanged = (value, oldValue) => !Object.is(value, oldValue);\nconst invokeArrayFns = (fns, arg) => {\n    for (let i = 0; i < fns.length; i++) {\n        fns[i](arg);\n    }\n};\nconst def = (obj, key, value) => {\n    Object.defineProperty(obj, key, {\n        configurable: true,\n        enumerable: false,\n        value\n    });\n};\n/**\n * \"123-foo\" will be parsed to 123\n * This is used for the .number modifier in v-model\n */\nconst looseToNumber = (val) => {\n    const n = parseFloat(val);\n    return isNaN(n) ? val : n;\n};\n/**\n * Only conerces number-like strings\n * \"123-foo\" will be returned as-is\n */\nconst toNumber = (val) => {\n    const n = isString(val) ? Number(val) : NaN;\n    return isNaN(n) ? val : n;\n};\nlet _globalThis;\nconst getGlobalThis = () => {\n    return (_globalThis ||\n        (_globalThis =\n            typeof globalThis !== 'undefined'\n                ? globalThis\n                : typeof self !== 'undefined'\n                    ? self\n                    : typeof window !== 'undefined'\n                        ? window\n                        : typeof global !== 'undefined'\n                            ? global\n                            : {}));\n};\nconst identRE = /^[_$a-zA-Z\\xA0-\\uFFFF][_$a-zA-Z0-9\\xA0-\\uFFFF]*$/;\nfunction genPropsAccessExp(name) {\n    return identRE.test(name)\n        ? `__props.${name}`\n        : `__props[${JSON.stringify(name)}]`;\n}\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, genPropsAccessExp, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, includeBooleanAttr, invokeArrayFns, isArray, isBooleanAttr, isBuiltInDirective, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownHtmlAttr, isKnownSvgAttr, isMap, isModelListener, isObject, isOn, isPlainObject, isPromise, isRegExp, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, looseToNumber, makeMap, normalizeClass, normalizeProps, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// runtime helper for setting properties on components\n// in a tree-shakable way\nexports.default = (sfc, props) => {\n    const target = sfc.__vccOpts || sfc;\n    for (const [key, val] of props) {\n        target[key] = val;\n    }\n    return target;\n};\n","/*!\n  * vue-router v4.0.13\n  * (c) 2022 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, onUnmounted, onDeactivated, onActivated, computed, unref, watchEffect, defineComponent, reactive, h, provide, ref, watch, shallowRef, nextTick } from 'vue';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\nconst hasSymbol = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol';\r\nconst PolySymbol = (name) => \r\n// vr = vue router\r\nhasSymbol\r\n    ? Symbol((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' + name : name)\r\n    : ((process.env.NODE_ENV !== 'production') ? '[vue-router]: ' : '_vr_') + name;\r\n// rvlm = Router View Location Matched\r\n/**\r\n * RouteRecord being rendered by the closest ancestor Router View. Used for\r\n * `onBeforeRouteUpdate` and `onBeforeRouteLeave`. rvlm stands for Router View\r\n * Location Matched\r\n *\r\n * @internal\r\n */\r\nconst matchedRouteKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location matched' : 'rvlm');\r\n/**\r\n * Allows overriding the router view depth to control which component in\r\n * `matched` is rendered. rvd stands for Router View Depth\r\n *\r\n * @internal\r\n */\r\nconst viewDepthKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view depth' : 'rvd');\r\n/**\r\n * Allows overriding the router instance returned by `useRouter` in tests. r\r\n * stands for router\r\n *\r\n * @internal\r\n */\r\nconst routerKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router' : 'r');\r\n/**\r\n * Allows overriding the current route returned by `useRoute` in tests. rl\r\n * stands for route location\r\n *\r\n * @internal\r\n */\r\nconst routeLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'route location' : 'rl');\r\n/**\r\n * Allows overriding the current route used by router-view. Internally this is\r\n * used when the `route` prop is passed.\r\n *\r\n * @internal\r\n */\r\nconst routerViewLocationKey = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'router view location' : 'rvl');\n\nconst isBrowser = typeof window !== 'undefined';\n\nfunction isESModule(obj) {\r\n    return obj.__esModule || (hasSymbol && obj[Symbol.toStringTag] === 'Module');\r\n}\r\nconst assign = Object.assign;\r\nfunction applyToParams(fn, params) {\r\n    const newParams = {};\r\n    for (const key in params) {\r\n        const value = params[key];\r\n        newParams[key] = Array.isArray(value) ? value.map(fn) : fn(value);\r\n    }\r\n    return newParams;\r\n}\r\nconst noop = () => { };\n\nfunction warn(msg) {\r\n    // avoid using ...args as it breaks in older Edge builds\r\n    const args = Array.from(arguments).slice(1);\r\n    console.warn.apply(console, ['[Vue Router warn]: ' + msg].concat(args));\r\n}\n\nconst TRAILING_SLASH_RE = /\\/$/;\r\nconst removeTrailingSlash = (path) => path.replace(TRAILING_SLASH_RE, '');\r\n/**\r\n * Transforms an URI into a normalized history location\r\n *\r\n * @param parseQuery\r\n * @param location - URI to normalize\r\n * @param currentLocation - current absolute location. Allows resolving relative\r\n * paths. Must start with `/`. Defaults to `/`\r\n * @returns a normalized history location\r\n */\r\nfunction parseURL(parseQuery, location, currentLocation = '/') {\r\n    let path, query = {}, searchString = '', hash = '';\r\n    // Could use URL and URLSearchParams but IE 11 doesn't support it\r\n    const searchPos = location.indexOf('?');\r\n    const hashPos = location.indexOf('#', searchPos > -1 ? searchPos : 0);\r\n    if (searchPos > -1) {\r\n        path = location.slice(0, searchPos);\r\n        searchString = location.slice(searchPos + 1, hashPos > -1 ? hashPos : location.length);\r\n        query = parseQuery(searchString);\r\n    }\r\n    if (hashPos > -1) {\r\n        path = path || location.slice(0, hashPos);\r\n        // keep the # character\r\n        hash = location.slice(hashPos, location.length);\r\n    }\r\n    // no search and no query\r\n    path = resolveRelativePath(path != null ? path : location, currentLocation);\r\n    // empty path means a relative query or hash `?foo=f`, `#thing`\r\n    return {\r\n        fullPath: path + (searchString && '?') + searchString + hash,\r\n        path,\r\n        query,\r\n        hash,\r\n    };\r\n}\r\n/**\r\n * Stringifies a URL object\r\n *\r\n * @param stringifyQuery\r\n * @param location\r\n */\r\nfunction stringifyURL(stringifyQuery, location) {\r\n    const query = location.query ? stringifyQuery(location.query) : '';\r\n    return location.path + (query && '?') + query + (location.hash || '');\r\n}\r\n/**\r\n * Strips off the base from the beginning of a location.pathname in a non\r\n * case-sensitive way.\r\n *\r\n * @param pathname - location.pathname\r\n * @param base - base to strip off\r\n */\r\nfunction stripBase(pathname, base) {\r\n    // no base or base is not found at the beginning\r\n    if (!base || !pathname.toLowerCase().startsWith(base.toLowerCase()))\r\n        return pathname;\r\n    return pathname.slice(base.length) || '/';\r\n}\r\n/**\r\n * Checks if two RouteLocation are equal. This means that both locations are\r\n * pointing towards the same {@link RouteRecord} and that all `params`, `query`\r\n * parameters and `hash` are the same\r\n *\r\n * @param a - first {@link RouteLocation}\r\n * @param b - second {@link RouteLocation}\r\n */\r\nfunction isSameRouteLocation(stringifyQuery, a, b) {\r\n    const aLastIndex = a.matched.length - 1;\r\n    const bLastIndex = b.matched.length - 1;\r\n    return (aLastIndex > -1 &&\r\n        aLastIndex === bLastIndex &&\r\n        isSameRouteRecord(a.matched[aLastIndex], b.matched[bLastIndex]) &&\r\n        isSameRouteLocationParams(a.params, b.params) &&\r\n        stringifyQuery(a.query) === stringifyQuery(b.query) &&\r\n        a.hash === b.hash);\r\n}\r\n/**\r\n * Check if two `RouteRecords` are equal. Takes into account aliases: they are\r\n * considered equal to the `RouteRecord` they are aliasing.\r\n *\r\n * @param a - first {@link RouteRecord}\r\n * @param b - second {@link RouteRecord}\r\n */\r\nfunction isSameRouteRecord(a, b) {\r\n    // since the original record has an undefined value for aliasOf\r\n    // but all aliases point to the original record, this will always compare\r\n    // the original record\r\n    return (a.aliasOf || a) === (b.aliasOf || b);\r\n}\r\nfunction isSameRouteLocationParams(a, b) {\r\n    if (Object.keys(a).length !== Object.keys(b).length)\r\n        return false;\r\n    for (const key in a) {\r\n        if (!isSameRouteLocationParamsValue(a[key], b[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\nfunction isSameRouteLocationParamsValue(a, b) {\r\n    return Array.isArray(a)\r\n        ? isEquivalentArray(a, b)\r\n        : Array.isArray(b)\r\n            ? isEquivalentArray(b, a)\r\n            : a === b;\r\n}\r\n/**\r\n * Check if two arrays are the same or if an array with one single entry is the\r\n * same as another primitive value. Used to check query and parameters\r\n *\r\n * @param a - array of values\r\n * @param b - array of values or a single value\r\n */\r\nfunction isEquivalentArray(a, b) {\r\n    return Array.isArray(b)\r\n        ? a.length === b.length && a.every((value, i) => value === b[i])\r\n        : a.length === 1 && a[0] === b;\r\n}\r\n/**\r\n * Resolves a relative path that starts with `.`.\r\n *\r\n * @param to - path location we are resolving\r\n * @param from - currentLocation.path, should start with `/`\r\n */\r\nfunction resolveRelativePath(to, from) {\r\n    if (to.startsWith('/'))\r\n        return to;\r\n    if ((process.env.NODE_ENV !== 'production') && !from.startsWith('/')) {\r\n        warn(`Cannot resolve a relative location without an absolute path. Trying to resolve \"${to}\" from \"${from}\". It should look like \"/${from}\".`);\r\n        return to;\r\n    }\r\n    if (!to)\r\n        return from;\r\n    const fromSegments = from.split('/');\r\n    const toSegments = to.split('/');\r\n    let position = fromSegments.length - 1;\r\n    let toPosition;\r\n    let segment;\r\n    for (toPosition = 0; toPosition < toSegments.length; toPosition++) {\r\n        segment = toSegments[toPosition];\r\n        // can't go below zero\r\n        if (position === 1 || segment === '.')\r\n            continue;\r\n        if (segment === '..')\r\n            position--;\r\n        // found something that is not relative path\r\n        else\r\n            break;\r\n    }\r\n    return (fromSegments.slice(0, position).join('/') +\r\n        '/' +\r\n        toSegments\r\n            .slice(toPosition - (toPosition === toSegments.length ? 1 : 0))\r\n            .join('/'));\r\n}\n\nvar NavigationType;\r\n(function (NavigationType) {\r\n    NavigationType[\"pop\"] = \"pop\";\r\n    NavigationType[\"push\"] = \"push\";\r\n})(NavigationType || (NavigationType = {}));\r\nvar NavigationDirection;\r\n(function (NavigationDirection) {\r\n    NavigationDirection[\"back\"] = \"back\";\r\n    NavigationDirection[\"forward\"] = \"forward\";\r\n    NavigationDirection[\"unknown\"] = \"\";\r\n})(NavigationDirection || (NavigationDirection = {}));\r\n/**\r\n * Starting location for Histories\r\n */\r\nconst START = '';\r\n// Generic utils\r\n/**\r\n * Normalizes a base by removing any trailing slash and reading the base tag if\r\n * present.\r\n *\r\n * @param base - base to normalize\r\n */\r\nfunction normalizeBase(base) {\r\n    if (!base) {\r\n        if (isBrowser) {\r\n            // respect <base> tag\r\n            const baseEl = document.querySelector('base');\r\n            base = (baseEl && baseEl.getAttribute('href')) || '/';\r\n            // strip full URL origin\r\n            base = base.replace(/^\\w+:\\/\\/[^\\/]+/, '');\r\n        }\r\n        else {\r\n            base = '/';\r\n        }\r\n    }\r\n    // ensure leading slash when it was removed by the regex above avoid leading\r\n    // slash with hash because the file could be read from the disk like file://\r\n    // and the leading slash would cause problems\r\n    if (base[0] !== '/' && base[0] !== '#')\r\n        base = '/' + base;\r\n    // remove the trailing slash so all other method can just do `base + fullPath`\r\n    // to build an href\r\n    return removeTrailingSlash(base);\r\n}\r\n// remove any character before the hash\r\nconst BEFORE_HASH_RE = /^[^#]+#/;\r\nfunction createHref(base, location) {\r\n    return base.replace(BEFORE_HASH_RE, '#') + location;\r\n}\n\nfunction getElementPosition(el, offset) {\r\n    const docRect = document.documentElement.getBoundingClientRect();\r\n    const elRect = el.getBoundingClientRect();\r\n    return {\r\n        behavior: offset.behavior,\r\n        left: elRect.left - docRect.left - (offset.left || 0),\r\n        top: elRect.top - docRect.top - (offset.top || 0),\r\n    };\r\n}\r\nconst computeScrollPosition = () => ({\r\n    left: window.pageXOffset,\r\n    top: window.pageYOffset,\r\n});\r\nfunction scrollToPosition(position) {\r\n    let scrollToOptions;\r\n    if ('el' in position) {\r\n        const positionEl = position.el;\r\n        const isIdSelector = typeof positionEl === 'string' && positionEl.startsWith('#');\r\n        /**\r\n         * `id`s can accept pretty much any characters, including CSS combinators\r\n         * like `>` or `~`. It's still possible to retrieve elements using\r\n         * `document.getElementById('~')` but it needs to be escaped when using\r\n         * `document.querySelector('#\\\\~')` for it to be valid. The only\r\n         * requirements for `id`s are them to be unique on the page and to not be\r\n         * empty (`id=\"\"`). Because of that, when passing an id selector, it should\r\n         * be properly escaped for it to work with `querySelector`. We could check\r\n         * for the id selector to be simple (no CSS combinators `+ >~`) but that\r\n         * would make things inconsistent since they are valid characters for an\r\n         * `id` but would need to be escaped when using `querySelector`, breaking\r\n         * their usage and ending up in no selector returned. Selectors need to be\r\n         * escaped:\r\n         *\r\n         * - `#1-thing` becomes `#\\31 -thing`\r\n         * - `#with~symbols` becomes `#with\\\\~symbols`\r\n         *\r\n         * - More information about  the topic can be found at\r\n         *   https://mathiasbynens.be/notes/html5-id-class.\r\n         * - Practical example: https://mathiasbynens.be/demo/html5-id\r\n         */\r\n        if ((process.env.NODE_ENV !== 'production') && typeof position.el === 'string') {\r\n            if (!isIdSelector || !document.getElementById(position.el.slice(1))) {\r\n                try {\r\n                    const foundEl = document.querySelector(position.el);\r\n                    if (isIdSelector && foundEl) {\r\n                        warn(`The selector \"${position.el}\" should be passed as \"el: document.querySelector('${position.el}')\" because it starts with \"#\".`);\r\n                        // return to avoid other warnings\r\n                        return;\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    warn(`The selector \"${position.el}\" is invalid. If you are using an id selector, make sure to escape it. You can find more information about escaping characters in selectors at https://mathiasbynens.be/notes/css-escapes or use CSS.escape (https://developer.mozilla.org/en-US/docs/Web/API/CSS/escape).`);\r\n                    // return to avoid other warnings\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        const el = typeof positionEl === 'string'\r\n            ? isIdSelector\r\n                ? document.getElementById(positionEl.slice(1))\r\n                : document.querySelector(positionEl)\r\n            : positionEl;\r\n        if (!el) {\r\n            (process.env.NODE_ENV !== 'production') &&\r\n                warn(`Couldn't find element using selector \"${position.el}\" returned by scrollBehavior.`);\r\n            return;\r\n        }\r\n        scrollToOptions = getElementPosition(el, position);\r\n    }\r\n    else {\r\n        scrollToOptions = position;\r\n    }\r\n    if ('scrollBehavior' in document.documentElement.style)\r\n        window.scrollTo(scrollToOptions);\r\n    else {\r\n        window.scrollTo(scrollToOptions.left != null ? scrollToOptions.left : window.pageXOffset, scrollToOptions.top != null ? scrollToOptions.top : window.pageYOffset);\r\n    }\r\n}\r\nfunction getScrollKey(path, delta) {\r\n    const position = history.state ? history.state.position - delta : -1;\r\n    return position + path;\r\n}\r\nconst scrollPositions = new Map();\r\nfunction saveScrollPosition(key, scrollPosition) {\r\n    scrollPositions.set(key, scrollPosition);\r\n}\r\nfunction getSavedScrollPosition(key) {\r\n    const scroll = scrollPositions.get(key);\r\n    // consume it so it's not used again\r\n    scrollPositions.delete(key);\r\n    return scroll;\r\n}\r\n// TODO: RFC about how to save scroll position\r\n/**\r\n * ScrollBehavior instance used by the router to compute and restore the scroll\r\n * position when navigating.\r\n */\r\n// export interface ScrollHandler<ScrollPositionEntry extends HistoryStateValue, ScrollPosition extends ScrollPositionEntry> {\r\n//   // returns a scroll position that can be saved in history\r\n//   compute(): ScrollPositionEntry\r\n//   // can take an extended ScrollPositionEntry\r\n//   scroll(position: ScrollPosition): void\r\n// }\r\n// export const scrollHandler: ScrollHandler<ScrollPosition> = {\r\n//   compute: computeScroll,\r\n//   scroll: scrollToPosition,\r\n// }\n\nlet createBaseLocation = () => location.protocol + '//' + location.host;\r\n/**\r\n * Creates a normalized history location from a window.location object\r\n * @param location -\r\n */\r\nfunction createCurrentLocation(base, location) {\r\n    const { pathname, search, hash } = location;\r\n    // allows hash bases like #, /#, #/, #!, #!/, /#!/, or even /folder#end\r\n    const hashPos = base.indexOf('#');\r\n    if (hashPos > -1) {\r\n        let slicePos = hash.includes(base.slice(hashPos))\r\n            ? base.slice(hashPos).length\r\n            : 1;\r\n        let pathFromHash = hash.slice(slicePos);\r\n        // prepend the starting slash to hash so the url starts with /#\r\n        if (pathFromHash[0] !== '/')\r\n            pathFromHash = '/' + pathFromHash;\r\n        return stripBase(pathFromHash, '');\r\n    }\r\n    const path = stripBase(pathname, base);\r\n    return path + search + hash;\r\n}\r\nfunction useHistoryListeners(base, historyState, currentLocation, replace) {\r\n    let listeners = [];\r\n    let teardowns = [];\r\n    // TODO: should it be a stack? a Dict. Check if the popstate listener\r\n    // can trigger twice\r\n    let pauseState = null;\r\n    const popStateHandler = ({ state, }) => {\r\n        const to = createCurrentLocation(base, location);\r\n        const from = currentLocation.value;\r\n        const fromState = historyState.value;\r\n        let delta = 0;\r\n        if (state) {\r\n            currentLocation.value = to;\r\n            historyState.value = state;\r\n            // ignore the popstate and reset the pauseState\r\n            if (pauseState && pauseState === from) {\r\n                pauseState = null;\r\n                return;\r\n            }\r\n            delta = fromState ? state.position - fromState.position : 0;\r\n        }\r\n        else {\r\n            replace(to);\r\n        }\r\n        // console.log({ deltaFromCurrent })\r\n        // Here we could also revert the navigation by calling history.go(-delta)\r\n        // this listener will have to be adapted to not trigger again and to wait for the url\r\n        // to be updated before triggering the listeners. Some kind of validation function would also\r\n        // need to be passed to the listeners so the navigation can be accepted\r\n        // call all listeners\r\n        listeners.forEach(listener => {\r\n            listener(currentLocation.value, from, {\r\n                delta,\r\n                type: NavigationType.pop,\r\n                direction: delta\r\n                    ? delta > 0\r\n                        ? NavigationDirection.forward\r\n                        : NavigationDirection.back\r\n                    : NavigationDirection.unknown,\r\n            });\r\n        });\r\n    };\r\n    function pauseListeners() {\r\n        pauseState = currentLocation.value;\r\n    }\r\n    function listen(callback) {\r\n        // setup the listener and prepare teardown callbacks\r\n        listeners.push(callback);\r\n        const teardown = () => {\r\n            const index = listeners.indexOf(callback);\r\n            if (index > -1)\r\n                listeners.splice(index, 1);\r\n        };\r\n        teardowns.push(teardown);\r\n        return teardown;\r\n    }\r\n    function beforeUnloadListener() {\r\n        const { history } = window;\r\n        if (!history.state)\r\n            return;\r\n        history.replaceState(assign({}, history.state, { scroll: computeScrollPosition() }), '');\r\n    }\r\n    function destroy() {\r\n        for (const teardown of teardowns)\r\n            teardown();\r\n        teardowns = [];\r\n        window.removeEventListener('popstate', popStateHandler);\r\n        window.removeEventListener('beforeunload', beforeUnloadListener);\r\n    }\r\n    // setup the listeners and prepare teardown callbacks\r\n    window.addEventListener('popstate', popStateHandler);\r\n    window.addEventListener('beforeunload', beforeUnloadListener);\r\n    return {\r\n        pauseListeners,\r\n        listen,\r\n        destroy,\r\n    };\r\n}\r\n/**\r\n * Creates a state object\r\n */\r\nfunction buildState(back, current, forward, replaced = false, computeScroll = false) {\r\n    return {\r\n        back,\r\n        current,\r\n        forward,\r\n        replaced,\r\n        position: window.history.length,\r\n        scroll: computeScroll ? computeScrollPosition() : null,\r\n    };\r\n}\r\nfunction useHistoryStateNavigation(base) {\r\n    const { history, location } = window;\r\n    // private variables\r\n    const currentLocation = {\r\n        value: createCurrentLocation(base, location),\r\n    };\r\n    const historyState = { value: history.state };\r\n    // build current history entry as this is a fresh navigation\r\n    if (!historyState.value) {\r\n        changeLocation(currentLocation.value, {\r\n            back: null,\r\n            current: currentLocation.value,\r\n            forward: null,\r\n            // the length is off by one, we need to decrease it\r\n            position: history.length - 1,\r\n            replaced: true,\r\n            // don't add a scroll as the user may have an anchor and we want\r\n            // scrollBehavior to be triggered without a saved position\r\n            scroll: null,\r\n        }, true);\r\n    }\r\n    function changeLocation(to, state, replace) {\r\n        /**\r\n         * if a base tag is provided and we are on a normal domain, we have to\r\n         * respect the provided `base` attribute because pushState() will use it and\r\n         * potentially erase anything before the `#` like at\r\n         * https://github.com/vuejs/router/issues/685 where a base of\r\n         * `/folder/#` but a base of `/` would erase the `/folder/` section. If\r\n         * there is no host, the `<base>` tag makes no sense and if there isn't a\r\n         * base tag we can just use everything after the `#`.\r\n         */\r\n        const hashIndex = base.indexOf('#');\r\n        const url = hashIndex > -1\r\n            ? (location.host && document.querySelector('base')\r\n                ? base\r\n                : base.slice(hashIndex)) + to\r\n            : createBaseLocation() + base + to;\r\n        try {\r\n            // BROWSER QUIRK\r\n            // NOTE: Safari throws a SecurityError when calling this function 100 times in 30 seconds\r\n            history[replace ? 'replaceState' : 'pushState'](state, '', url);\r\n            historyState.value = state;\r\n        }\r\n        catch (err) {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn('Error with push/replace State', err);\r\n            }\r\n            else {\r\n                console.error(err);\r\n            }\r\n            // Force the navigation, this also resets the call count\r\n            location[replace ? 'replace' : 'assign'](url);\r\n        }\r\n    }\r\n    function replace(to, data) {\r\n        const state = assign({}, history.state, buildState(historyState.value.back, \r\n        // keep back and forward entries but override current position\r\n        to, historyState.value.forward, true), data, { position: historyState.value.position });\r\n        changeLocation(to, state, true);\r\n        currentLocation.value = to;\r\n    }\r\n    function push(to, data) {\r\n        // Add to current entry the information of where we are going\r\n        // as well as saving the current position\r\n        const currentState = assign({}, \r\n        // use current history state to gracefully handle a wrong call to\r\n        // history.replaceState\r\n        // https://github.com/vuejs/router/issues/366\r\n        historyState.value, history.state, {\r\n            forward: to,\r\n            scroll: computeScrollPosition(),\r\n        });\r\n        if ((process.env.NODE_ENV !== 'production') && !history.state) {\r\n            warn(`history.state seems to have been manually replaced without preserving the necessary values. Make sure to preserve existing history state if you are manually calling history.replaceState:\\n\\n` +\r\n                `history.replaceState(history.state, '', url)\\n\\n` +\r\n                `You can find more information at https://next.router.vuejs.org/guide/migration/#usage-of-history-state.`);\r\n        }\r\n        changeLocation(currentState.current, currentState, true);\r\n        const state = assign({}, buildState(currentLocation.value, to, null), { position: currentState.position + 1 }, data);\r\n        changeLocation(to, state, false);\r\n        currentLocation.value = to;\r\n    }\r\n    return {\r\n        location: currentLocation,\r\n        state: historyState,\r\n        push,\r\n        replace,\r\n    };\r\n}\r\n/**\r\n * Creates an HTML5 history. Most common history for single page applications.\r\n *\r\n * @param base -\r\n */\r\nfunction createWebHistory(base) {\r\n    base = normalizeBase(base);\r\n    const historyNavigation = useHistoryStateNavigation(base);\r\n    const historyListeners = useHistoryListeners(base, historyNavigation.state, historyNavigation.location, historyNavigation.replace);\r\n    function go(delta, triggerListeners = true) {\r\n        if (!triggerListeners)\r\n            historyListeners.pauseListeners();\r\n        history.go(delta);\r\n    }\r\n    const routerHistory = assign({\r\n        // it's overridden right after\r\n        location: '',\r\n        base,\r\n        go,\r\n        createHref: createHref.bind(null, base),\r\n    }, historyNavigation, historyListeners);\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        enumerable: true,\r\n        get: () => historyNavigation.location.value,\r\n    });\r\n    Object.defineProperty(routerHistory, 'state', {\r\n        enumerable: true,\r\n        get: () => historyNavigation.state.value,\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a in-memory based history. The main purpose of this history is to handle SSR. It starts in a special location that is nowhere.\r\n * It's up to the user to replace that location with the starter location by either calling `router.push` or `router.replace`.\r\n *\r\n * @param base - Base applied to all urls, defaults to '/'\r\n * @returns a history object that can be passed to the router constructor\r\n */\r\nfunction createMemoryHistory(base = '') {\r\n    let listeners = [];\r\n    let queue = [START];\r\n    let position = 0;\r\n    base = normalizeBase(base);\r\n    function setLocation(location) {\r\n        position++;\r\n        if (position === queue.length) {\r\n            // we are at the end, we can simply append a new entry\r\n            queue.push(location);\r\n        }\r\n        else {\r\n            // we are in the middle, we remove everything from here in the queue\r\n            queue.splice(position);\r\n            queue.push(location);\r\n        }\r\n    }\r\n    function triggerListeners(to, from, { direction, delta }) {\r\n        const info = {\r\n            direction,\r\n            delta,\r\n            type: NavigationType.pop,\r\n        };\r\n        for (const callback of listeners) {\r\n            callback(to, from, info);\r\n        }\r\n    }\r\n    const routerHistory = {\r\n        // rewritten by Object.defineProperty\r\n        location: START,\r\n        // TODO: should be kept in queue\r\n        state: {},\r\n        base,\r\n        createHref: createHref.bind(null, base),\r\n        replace(to) {\r\n            // remove current entry and decrement position\r\n            queue.splice(position--, 1);\r\n            setLocation(to);\r\n        },\r\n        push(to, data) {\r\n            setLocation(to);\r\n        },\r\n        listen(callback) {\r\n            listeners.push(callback);\r\n            return () => {\r\n                const index = listeners.indexOf(callback);\r\n                if (index > -1)\r\n                    listeners.splice(index, 1);\r\n            };\r\n        },\r\n        destroy() {\r\n            listeners = [];\r\n            queue = [START];\r\n            position = 0;\r\n        },\r\n        go(delta, shouldTrigger = true) {\r\n            const from = this.location;\r\n            const direction = \r\n            // we are considering delta === 0 going forward, but in abstract mode\r\n            // using 0 for the delta doesn't make sense like it does in html5 where\r\n            // it reloads the page\r\n            delta < 0 ? NavigationDirection.back : NavigationDirection.forward;\r\n            position = Math.max(0, Math.min(position + delta, queue.length - 1));\r\n            if (shouldTrigger) {\r\n                triggerListeners(this.location, from, {\r\n                    direction,\r\n                    delta,\r\n                });\r\n            }\r\n        },\r\n    };\r\n    Object.defineProperty(routerHistory, 'location', {\r\n        enumerable: true,\r\n        get: () => queue[position],\r\n    });\r\n    return routerHistory;\r\n}\n\n/**\r\n * Creates a hash history. Useful for web applications with no host (e.g.\r\n * `file://`) or when configuring a server to handle any URL is not possible.\r\n *\r\n * @param base - optional base to provide. Defaults to `location.pathname +\r\n * location.search` If there is a `<base>` tag in the `head`, its value will be\r\n * ignored in favor of this parameter **but note it affects all the\r\n * history.pushState() calls**, meaning that if you use a `<base>` tag, it's\r\n * `href` value **has to match this parameter** (ignoring anything after the\r\n * `#`).\r\n *\r\n * @example\r\n * ```js\r\n * // at https://example.com/folder\r\n * createWebHashHistory() // gives a url of `https://example.com/folder#`\r\n * createWebHashHistory('/folder/') // gives a url of `https://example.com/folder/#`\r\n * // if the `#` is provided in the base, it won't be added by `createWebHashHistory`\r\n * createWebHashHistory('/folder/#/app/') // gives a url of `https://example.com/folder/#/app/`\r\n * // you should avoid doing this because it changes the original url and breaks copying urls\r\n * createWebHashHistory('/other-folder/') // gives a url of `https://example.com/other-folder/#`\r\n *\r\n * // at file:///usr/etc/folder/index.html\r\n * // for locations with no `host`, the base is ignored\r\n * createWebHashHistory('/iAmIgnored') // gives a url of `file:///usr/etc/folder/index.html#`\r\n * ```\r\n */\r\nfunction createWebHashHistory(base) {\r\n    // Make sure this implementation is fine in terms of encoding, specially for IE11\r\n    // for `file://`, directly use the pathname and ignore the base\r\n    // location.pathname contains an initial `/` even at the root: `https://example.com`\r\n    base = location.host ? base || location.pathname + location.search : '';\r\n    // allow the user to provide a `#` in the middle: `/base/#/app`\r\n    if (!base.includes('#'))\r\n        base += '#';\r\n    if ((process.env.NODE_ENV !== 'production') && !base.endsWith('#/') && !base.endsWith('#')) {\r\n        warn(`A hash base must end with a \"#\":\\n\"${base}\" should be \"${base.replace(/#.*$/, '#')}\".`);\r\n    }\r\n    return createWebHistory(base);\r\n}\n\nfunction isRouteLocation(route) {\r\n    return typeof route === 'string' || (route && typeof route === 'object');\r\n}\r\nfunction isRouteName(name) {\r\n    return typeof name === 'string' || typeof name === 'symbol';\r\n}\n\n/**\r\n * Initial route location where the router is. Can be used in navigation guards\r\n * to differentiate the initial navigation.\r\n *\r\n * @example\r\n * ```js\r\n * import { START_LOCATION } from 'vue-router'\r\n *\r\n * router.beforeEach((to, from) => {\r\n *   if (from === START_LOCATION) {\r\n *     // initial navigation\r\n *   }\r\n * })\r\n * ```\r\n */\r\nconst START_LOCATION_NORMALIZED = {\r\n    path: '/',\r\n    name: undefined,\r\n    params: {},\r\n    query: {},\r\n    hash: '',\r\n    fullPath: '/',\r\n    matched: [],\r\n    meta: {},\r\n    redirectedFrom: undefined,\r\n};\n\nconst NavigationFailureSymbol = /*#__PURE__*/ PolySymbol((process.env.NODE_ENV !== 'production') ? 'navigation failure' : 'nf');\r\n/**\r\n * Enumeration with all possible types for navigation failures. Can be passed to\r\n * {@link isNavigationFailure} to check for specific failures.\r\n */\r\nvar NavigationFailureType;\r\n(function (NavigationFailureType) {\r\n    /**\r\n     * An aborted navigation is a navigation that failed because a navigation\r\n     * guard returned `false` or called `next(false)`\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"aborted\"] = 4] = \"aborted\";\r\n    /**\r\n     * A cancelled navigation is a navigation that failed because a more recent\r\n     * navigation finished started (not necessarily finished).\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"cancelled\"] = 8] = \"cancelled\";\r\n    /**\r\n     * A duplicated navigation is a navigation that failed because it was\r\n     * initiated while already being at the exact same location.\r\n     */\r\n    NavigationFailureType[NavigationFailureType[\"duplicated\"] = 16] = \"duplicated\";\r\n})(NavigationFailureType || (NavigationFailureType = {}));\r\n// DEV only debug messages\r\nconst ErrorTypeMessages = {\r\n    [1 /* MATCHER_NOT_FOUND */]({ location, currentLocation }) {\r\n        return `No match for\\n ${JSON.stringify(location)}${currentLocation\r\n            ? '\\nwhile being at\\n' + JSON.stringify(currentLocation)\r\n            : ''}`;\r\n    },\r\n    [2 /* NAVIGATION_GUARD_REDIRECT */]({ from, to, }) {\r\n        return `Redirected from \"${from.fullPath}\" to \"${stringifyRoute(to)}\" via a navigation guard.`;\r\n    },\r\n    [4 /* NAVIGATION_ABORTED */]({ from, to }) {\r\n        return `Navigation aborted from \"${from.fullPath}\" to \"${to.fullPath}\" via a navigation guard.`;\r\n    },\r\n    [8 /* NAVIGATION_CANCELLED */]({ from, to }) {\r\n        return `Navigation cancelled from \"${from.fullPath}\" to \"${to.fullPath}\" with a new navigation.`;\r\n    },\r\n    [16 /* NAVIGATION_DUPLICATED */]({ from, to }) {\r\n        return `Avoided redundant navigation to current location: \"${from.fullPath}\".`;\r\n    },\r\n};\r\nfunction createRouterError(type, params) {\r\n    // keep full error messages in cjs versions\r\n    if ((process.env.NODE_ENV !== 'production') || !true) {\r\n        return assign(new Error(ErrorTypeMessages[type](params)), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n    else {\r\n        return assign(new Error(), {\r\n            type,\r\n            [NavigationFailureSymbol]: true,\r\n        }, params);\r\n    }\r\n}\r\nfunction isNavigationFailure(error, type) {\r\n    return (error instanceof Error &&\r\n        NavigationFailureSymbol in error &&\r\n        (type == null || !!(error.type & type)));\r\n}\r\nconst propertiesToLog = ['params', 'query', 'hash'];\r\nfunction stringifyRoute(to) {\r\n    if (typeof to === 'string')\r\n        return to;\r\n    if ('path' in to)\r\n        return to.path;\r\n    const location = {};\r\n    for (const key of propertiesToLog) {\r\n        if (key in to)\r\n            location[key] = to[key];\r\n    }\r\n    return JSON.stringify(location, null, 2);\r\n}\n\n// default pattern for a param: non greedy everything but /\r\nconst BASE_PARAM_PATTERN = '[^/]+?';\r\nconst BASE_PATH_PARSER_OPTIONS = {\r\n    sensitive: false,\r\n    strict: false,\r\n    start: true,\r\n    end: true,\r\n};\r\n// Special Regex characters that must be escaped in static tokens\r\nconst REGEX_CHARS_RE = /[.+*?^${}()[\\]/\\\\]/g;\r\n/**\r\n * Creates a path parser from an array of Segments (a segment is an array of Tokens)\r\n *\r\n * @param segments - array of segments returned by tokenizePath\r\n * @param extraOptions - optional options for the regexp\r\n * @returns a PathParser\r\n */\r\nfunction tokensToParser(segments, extraOptions) {\r\n    const options = assign({}, BASE_PATH_PARSER_OPTIONS, extraOptions);\r\n    // the amount of scores is the same as the length of segments except for the root segment \"/\"\r\n    const score = [];\r\n    // the regexp as a string\r\n    let pattern = options.start ? '^' : '';\r\n    // extracted keys\r\n    const keys = [];\r\n    for (const segment of segments) {\r\n        // the root segment needs special treatment\r\n        const segmentScores = segment.length ? [] : [90 /* Root */];\r\n        // allow trailing slash\r\n        if (options.strict && !segment.length)\r\n            pattern += '/';\r\n        for (let tokenIndex = 0; tokenIndex < segment.length; tokenIndex++) {\r\n            const token = segment[tokenIndex];\r\n            // resets the score if we are inside a sub segment /:a-other-:b\r\n            let subSegmentScore = 40 /* Segment */ +\r\n                (options.sensitive ? 0.25 /* BonusCaseSensitive */ : 0);\r\n            if (token.type === 0 /* Static */) {\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    pattern += '/';\r\n                pattern += token.value.replace(REGEX_CHARS_RE, '\\\\$&');\r\n                subSegmentScore += 40 /* Static */;\r\n            }\r\n            else if (token.type === 1 /* Param */) {\r\n                const { value, repeatable, optional, regexp } = token;\r\n                keys.push({\r\n                    name: value,\r\n                    repeatable,\r\n                    optional,\r\n                });\r\n                const re = regexp ? regexp : BASE_PARAM_PATTERN;\r\n                // the user provided a custom regexp /:id(\\\\d+)\r\n                if (re !== BASE_PARAM_PATTERN) {\r\n                    subSegmentScore += 10 /* BonusCustomRegExp */;\r\n                    // make sure the regexp is valid before using it\r\n                    try {\r\n                        new RegExp(`(${re})`);\r\n                    }\r\n                    catch (err) {\r\n                        throw new Error(`Invalid custom RegExp for param \"${value}\" (${re}): ` +\r\n                            err.message);\r\n                    }\r\n                }\r\n                // when we repeat we must take care of the repeating leading slash\r\n                let subPattern = repeatable ? `((?:${re})(?:/(?:${re}))*)` : `(${re})`;\r\n                // prepend the slash if we are starting a new segment\r\n                if (!tokenIndex)\r\n                    subPattern =\r\n                        // avoid an optional / if there are more segments e.g. /:p?-static\r\n                        // or /:p?-:p2\r\n                        optional && segment.length < 2\r\n                            ? `(?:/${subPattern})`\r\n                            : '/' + subPattern;\r\n                if (optional)\r\n                    subPattern += '?';\r\n                pattern += subPattern;\r\n                subSegmentScore += 20 /* Dynamic */;\r\n                if (optional)\r\n                    subSegmentScore += -8 /* BonusOptional */;\r\n                if (repeatable)\r\n                    subSegmentScore += -20 /* BonusRepeatable */;\r\n                if (re === '.*')\r\n                    subSegmentScore += -50 /* BonusWildcard */;\r\n            }\r\n            segmentScores.push(subSegmentScore);\r\n        }\r\n        // an empty array like /home/ -> [[{home}], []]\r\n        // if (!segment.length) pattern += '/'\r\n        score.push(segmentScores);\r\n    }\r\n    // only apply the strict bonus to the last score\r\n    if (options.strict && options.end) {\r\n        const i = score.length - 1;\r\n        score[i][score[i].length - 1] += 0.7000000000000001 /* BonusStrict */;\r\n    }\r\n    // TODO: dev only warn double trailing slash\r\n    if (!options.strict)\r\n        pattern += '/?';\r\n    if (options.end)\r\n        pattern += '$';\r\n    // allow paths like /dynamic to only match dynamic or dynamic/... but not dynamic_something_else\r\n    else if (options.strict)\r\n        pattern += '(?:/|$)';\r\n    const re = new RegExp(pattern, options.sensitive ? '' : 'i');\r\n    function parse(path) {\r\n        const match = path.match(re);\r\n        const params = {};\r\n        if (!match)\r\n            return null;\r\n        for (let i = 1; i < match.length; i++) {\r\n            const value = match[i] || '';\r\n            const key = keys[i - 1];\r\n            params[key.name] = value && key.repeatable ? value.split('/') : value;\r\n        }\r\n        return params;\r\n    }\r\n    function stringify(params) {\r\n        let path = '';\r\n        // for optional parameters to allow to be empty\r\n        let avoidDuplicatedSlash = false;\r\n        for (const segment of segments) {\r\n            if (!avoidDuplicatedSlash || !path.endsWith('/'))\r\n                path += '/';\r\n            avoidDuplicatedSlash = false;\r\n            for (const token of segment) {\r\n                if (token.type === 0 /* Static */) {\r\n                    path += token.value;\r\n                }\r\n                else if (token.type === 1 /* Param */) {\r\n                    const { value, repeatable, optional } = token;\r\n                    const param = value in params ? params[value] : '';\r\n                    if (Array.isArray(param) && !repeatable)\r\n                        throw new Error(`Provided param \"${value}\" is an array but it is not repeatable (* or + modifiers)`);\r\n                    const text = Array.isArray(param) ? param.join('/') : param;\r\n                    if (!text) {\r\n                        if (optional) {\r\n                            // if we have more than one optional param like /:a?-static we\r\n                            // don't need to care about the optional param\r\n                            if (segment.length < 2) {\r\n                                // remove the last slash as we could be at the end\r\n                                if (path.endsWith('/'))\r\n                                    path = path.slice(0, -1);\r\n                                // do not append a slash on the next iteration\r\n                                else\r\n                                    avoidDuplicatedSlash = true;\r\n                            }\r\n                        }\r\n                        else\r\n                            throw new Error(`Missing required param \"${value}\"`);\r\n                    }\r\n                    path += text;\r\n                }\r\n            }\r\n        }\r\n        return path;\r\n    }\r\n    return {\r\n        re,\r\n        score,\r\n        keys,\r\n        parse,\r\n        stringify,\r\n    };\r\n}\r\n/**\r\n * Compares an array of numbers as used in PathParser.score and returns a\r\n * number. This function can be used to `sort` an array\r\n *\r\n * @param a - first array of numbers\r\n * @param b - second array of numbers\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n * should be sorted first\r\n */\r\nfunction compareScoreArray(a, b) {\r\n    let i = 0;\r\n    while (i < a.length && i < b.length) {\r\n        const diff = b[i] - a[i];\r\n        // only keep going if diff === 0\r\n        if (diff)\r\n            return diff;\r\n        i++;\r\n    }\r\n    // if the last subsegment was Static, the shorter segments should be sorted first\r\n    // otherwise sort the longest segment first\r\n    if (a.length < b.length) {\r\n        return a.length === 1 && a[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? -1\r\n            : 1;\r\n    }\r\n    else if (a.length > b.length) {\r\n        return b.length === 1 && b[0] === 40 /* Static */ + 40 /* Segment */\r\n            ? 1\r\n            : -1;\r\n    }\r\n    return 0;\r\n}\r\n/**\r\n * Compare function that can be used with `sort` to sort an array of PathParser\r\n *\r\n * @param a - first PathParser\r\n * @param b - second PathParser\r\n * @returns 0 if both are equal, < 0 if a should be sorted first, > 0 if b\r\n */\r\nfunction comparePathParserScore(a, b) {\r\n    let i = 0;\r\n    const aScore = a.score;\r\n    const bScore = b.score;\r\n    while (i < aScore.length && i < bScore.length) {\r\n        const comp = compareScoreArray(aScore[i], bScore[i]);\r\n        // do not return if both are equal\r\n        if (comp)\r\n            return comp;\r\n        i++;\r\n    }\r\n    // if a and b share the same score entries but b has more, sort b first\r\n    return bScore.length - aScore.length;\r\n    // this is the ternary version\r\n    // return aScore.length < bScore.length\r\n    //   ? 1\r\n    //   : aScore.length > bScore.length\r\n    //   ? -1\r\n    //   : 0\r\n}\n\nconst ROOT_TOKEN = {\r\n    type: 0 /* Static */,\r\n    value: '',\r\n};\r\nconst VALID_PARAM_RE = /[a-zA-Z0-9_]/;\r\n// After some profiling, the cache seems to be unnecessary because tokenizePath\r\n// (the slowest part of adding a route) is very fast\r\n// const tokenCache = new Map<string, Token[][]>()\r\nfunction tokenizePath(path) {\r\n    if (!path)\r\n        return [[]];\r\n    if (path === '/')\r\n        return [[ROOT_TOKEN]];\r\n    if (!path.startsWith('/')) {\r\n        throw new Error((process.env.NODE_ENV !== 'production')\r\n            ? `Route paths should start with a \"/\": \"${path}\" should be \"/${path}\".`\r\n            : `Invalid path \"${path}\"`);\r\n    }\r\n    // if (tokenCache.has(path)) return tokenCache.get(path)!\r\n    function crash(message) {\r\n        throw new Error(`ERR (${state})/\"${buffer}\": ${message}`);\r\n    }\r\n    let state = 0 /* Static */;\r\n    let previousState = state;\r\n    const tokens = [];\r\n    // the segment will always be valid because we get into the initial state\r\n    // with the leading /\r\n    let segment;\r\n    function finalizeSegment() {\r\n        if (segment)\r\n            tokens.push(segment);\r\n        segment = [];\r\n    }\r\n    // index on the path\r\n    let i = 0;\r\n    // char at index\r\n    let char;\r\n    // buffer of the value read\r\n    let buffer = '';\r\n    // custom regexp for a param\r\n    let customRe = '';\r\n    function consumeBuffer() {\r\n        if (!buffer)\r\n            return;\r\n        if (state === 0 /* Static */) {\r\n            segment.push({\r\n                type: 0 /* Static */,\r\n                value: buffer,\r\n            });\r\n        }\r\n        else if (state === 1 /* Param */ ||\r\n            state === 2 /* ParamRegExp */ ||\r\n            state === 3 /* ParamRegExpEnd */) {\r\n            if (segment.length > 1 && (char === '*' || char === '+'))\r\n                crash(`A repeatable param (${buffer}) must be alone in its segment. eg: '/:ids+.`);\r\n            segment.push({\r\n                type: 1 /* Param */,\r\n                value: buffer,\r\n                regexp: customRe,\r\n                repeatable: char === '*' || char === '+',\r\n                optional: char === '*' || char === '?',\r\n            });\r\n        }\r\n        else {\r\n            crash('Invalid state to consume buffer');\r\n        }\r\n        buffer = '';\r\n    }\r\n    function addCharToBuffer() {\r\n        buffer += char;\r\n    }\r\n    while (i < path.length) {\r\n        char = path[i++];\r\n        if (char === '\\\\' && state !== 2 /* ParamRegExp */) {\r\n            previousState = state;\r\n            state = 4 /* EscapeNext */;\r\n            continue;\r\n        }\r\n        switch (state) {\r\n            case 0 /* Static */:\r\n                if (char === '/') {\r\n                    if (buffer) {\r\n                        consumeBuffer();\r\n                    }\r\n                    finalizeSegment();\r\n                }\r\n                else if (char === ':') {\r\n                    consumeBuffer();\r\n                    state = 1 /* Param */;\r\n                }\r\n                else {\r\n                    addCharToBuffer();\r\n                }\r\n                break;\r\n            case 4 /* EscapeNext */:\r\n                addCharToBuffer();\r\n                state = previousState;\r\n                break;\r\n            case 1 /* Param */:\r\n                if (char === '(') {\r\n                    state = 2 /* ParamRegExp */;\r\n                }\r\n                else if (VALID_PARAM_RE.test(char)) {\r\n                    addCharToBuffer();\r\n                }\r\n                else {\r\n                    consumeBuffer();\r\n                    state = 0 /* Static */;\r\n                    // go back one character if we were not modifying\r\n                    if (char !== '*' && char !== '?' && char !== '+')\r\n                        i--;\r\n                }\r\n                break;\r\n            case 2 /* ParamRegExp */:\r\n                // TODO: is it worth handling nested regexp? like :p(?:prefix_([^/]+)_suffix)\r\n                // it already works by escaping the closing )\r\n                // https://paths.esm.dev/?p=AAMeJbiAwQEcDKbAoAAkP60PG2R6QAvgNaA6AFACM2ABuQBB#\r\n                // is this really something people need since you can also write\r\n                // /prefix_:p()_suffix\r\n                if (char === ')') {\r\n                    // handle the escaped )\r\n                    if (customRe[customRe.length - 1] == '\\\\')\r\n                        customRe = customRe.slice(0, -1) + char;\r\n                    else\r\n                        state = 3 /* ParamRegExpEnd */;\r\n                }\r\n                else {\r\n                    customRe += char;\r\n                }\r\n                break;\r\n            case 3 /* ParamRegExpEnd */:\r\n                // same as finalizing a param\r\n                consumeBuffer();\r\n                state = 0 /* Static */;\r\n                // go back one character if we were not modifying\r\n                if (char !== '*' && char !== '?' && char !== '+')\r\n                    i--;\r\n                customRe = '';\r\n                break;\r\n            default:\r\n                crash('Unknown state');\r\n                break;\r\n        }\r\n    }\r\n    if (state === 2 /* ParamRegExp */)\r\n        crash(`Unfinished custom RegExp for param \"${buffer}\"`);\r\n    consumeBuffer();\r\n    finalizeSegment();\r\n    // tokenCache.set(path, tokens)\r\n    return tokens;\r\n}\n\nfunction createRouteRecordMatcher(record, parent, options) {\r\n    const parser = tokensToParser(tokenizePath(record.path), options);\r\n    // warn against params with the same name\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        const existingKeys = new Set();\r\n        for (const key of parser.keys) {\r\n            if (existingKeys.has(key.name))\r\n                warn(`Found duplicated params with name \"${key.name}\" for path \"${record.path}\". Only the last one will be available on \"$route.params\".`);\r\n            existingKeys.add(key.name);\r\n        }\r\n    }\r\n    const matcher = assign(parser, {\r\n        record,\r\n        parent,\r\n        // these needs to be populated by the parent\r\n        children: [],\r\n        alias: [],\r\n    });\r\n    if (parent) {\r\n        // both are aliases or both are not aliases\r\n        // we don't want to mix them because the order is used when\r\n        // passing originalRecord in Matcher.addRoute\r\n        if (!matcher.record.aliasOf === !parent.record.aliasOf)\r\n            parent.children.push(matcher);\r\n    }\r\n    return matcher;\r\n}\n\n/**\r\n * Creates a Router Matcher.\r\n *\r\n * @internal\r\n * @param routes - array of initial routes\r\n * @param globalOptions - global route options\r\n */\r\nfunction createRouterMatcher(routes, globalOptions) {\r\n    // normalized ordered array of matchers\r\n    const matchers = [];\r\n    const matcherMap = new Map();\r\n    globalOptions = mergeOptions({ strict: false, end: true, sensitive: false }, globalOptions);\r\n    function getRecordMatcher(name) {\r\n        return matcherMap.get(name);\r\n    }\r\n    function addRoute(record, parent, originalRecord) {\r\n        // used later on to remove by name\r\n        const isRootAdd = !originalRecord;\r\n        const mainNormalizedRecord = normalizeRouteRecord(record);\r\n        // we might be the child of an alias\r\n        mainNormalizedRecord.aliasOf = originalRecord && originalRecord.record;\r\n        const options = mergeOptions(globalOptions, record);\r\n        // generate an array of records to correctly handle aliases\r\n        const normalizedRecords = [\r\n            mainNormalizedRecord,\r\n        ];\r\n        if ('alias' in record) {\r\n            const aliases = typeof record.alias === 'string' ? [record.alias] : record.alias;\r\n            for (const alias of aliases) {\r\n                normalizedRecords.push(assign({}, mainNormalizedRecord, {\r\n                    // this allows us to hold a copy of the `components` option\r\n                    // so that async components cache is hold on the original record\r\n                    components: originalRecord\r\n                        ? originalRecord.record.components\r\n                        : mainNormalizedRecord.components,\r\n                    path: alias,\r\n                    // we might be the child of an alias\r\n                    aliasOf: originalRecord\r\n                        ? originalRecord.record\r\n                        : mainNormalizedRecord,\r\n                    // the aliases are always of the same kind as the original since they\r\n                    // are defined on the same record\r\n                }));\r\n            }\r\n        }\r\n        let matcher;\r\n        let originalMatcher;\r\n        for (const normalizedRecord of normalizedRecords) {\r\n            const { path } = normalizedRecord;\r\n            // Build up the path for nested routes if the child isn't an absolute\r\n            // route. Only add the / delimiter if the child path isn't empty and if the\r\n            // parent path doesn't have a trailing slash\r\n            if (parent && path[0] !== '/') {\r\n                const parentPath = parent.record.path;\r\n                const connectingSlash = parentPath[parentPath.length - 1] === '/' ? '' : '/';\r\n                normalizedRecord.path =\r\n                    parent.record.path + (path && connectingSlash + path);\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') && normalizedRecord.path === '*') {\r\n                throw new Error('Catch all routes (\"*\") must now be defined using a param with a custom regexp.\\n' +\r\n                    'See more at https://next.router.vuejs.org/guide/migration/#removed-star-or-catch-all-routes.');\r\n            }\r\n            // create the object before hand so it can be passed to children\r\n            matcher = createRouteRecordMatcher(normalizedRecord, parent, options);\r\n            if ((process.env.NODE_ENV !== 'production') && parent && path[0] === '/')\r\n                checkMissingParamsInAbsolutePath(matcher, parent);\r\n            // if we are an alias we must tell the original record that we exist\r\n            // so we can be removed\r\n            if (originalRecord) {\r\n                originalRecord.alias.push(matcher);\r\n                if ((process.env.NODE_ENV !== 'production')) {\r\n                    checkSameParams(originalRecord, matcher);\r\n                }\r\n            }\r\n            else {\r\n                // otherwise, the first record is the original and others are aliases\r\n                originalMatcher = originalMatcher || matcher;\r\n                if (originalMatcher !== matcher)\r\n                    originalMatcher.alias.push(matcher);\r\n                // remove the route if named and only for the top record (avoid in nested calls)\r\n                // this works because the original record is the first one\r\n                if (isRootAdd && record.name && !isAliasRecord(matcher))\r\n                    removeRoute(record.name);\r\n            }\r\n            if ('children' in mainNormalizedRecord) {\r\n                const children = mainNormalizedRecord.children;\r\n                for (let i = 0; i < children.length; i++) {\r\n                    addRoute(children[i], matcher, originalRecord && originalRecord.children[i]);\r\n                }\r\n            }\r\n            // if there was no original record, then the first one was not an alias and all\r\n            // other alias (if any) need to reference this record when adding children\r\n            originalRecord = originalRecord || matcher;\r\n            // TODO: add normalized records for more flexibility\r\n            // if (parent && isAliasRecord(originalRecord)) {\r\n            //   parent.children.push(originalRecord)\r\n            // }\r\n            insertMatcher(matcher);\r\n        }\r\n        return originalMatcher\r\n            ? () => {\r\n                // since other matchers are aliases, they should be removed by the original matcher\r\n                removeRoute(originalMatcher);\r\n            }\r\n            : noop;\r\n    }\r\n    function removeRoute(matcherRef) {\r\n        if (isRouteName(matcherRef)) {\r\n            const matcher = matcherMap.get(matcherRef);\r\n            if (matcher) {\r\n                matcherMap.delete(matcherRef);\r\n                matchers.splice(matchers.indexOf(matcher), 1);\r\n                matcher.children.forEach(removeRoute);\r\n                matcher.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n        else {\r\n            const index = matchers.indexOf(matcherRef);\r\n            if (index > -1) {\r\n                matchers.splice(index, 1);\r\n                if (matcherRef.record.name)\r\n                    matcherMap.delete(matcherRef.record.name);\r\n                matcherRef.children.forEach(removeRoute);\r\n                matcherRef.alias.forEach(removeRoute);\r\n            }\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matchers;\r\n    }\r\n    function insertMatcher(matcher) {\r\n        let i = 0;\r\n        while (i < matchers.length &&\r\n            comparePathParserScore(matcher, matchers[i]) >= 0 &&\r\n            // Adding children with empty path should still appear before the parent\r\n            // https://github.com/vuejs/router/issues/1124\r\n            (matcher.record.path !== matchers[i].record.path ||\r\n                !isRecordChildOf(matcher, matchers[i])))\r\n            i++;\r\n        matchers.splice(i, 0, matcher);\r\n        // only add the original record to the name map\r\n        if (matcher.record.name && !isAliasRecord(matcher))\r\n            matcherMap.set(matcher.record.name, matcher);\r\n    }\r\n    function resolve(location, currentLocation) {\r\n        let matcher;\r\n        let params = {};\r\n        let path;\r\n        let name;\r\n        if ('name' in location && location.name) {\r\n            matcher = matcherMap.get(location.name);\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                });\r\n            name = matcher.record.name;\r\n            params = assign(\r\n            // paramsFromLocation is a new object\r\n            paramsFromLocation(currentLocation.params, \r\n            // only keep params that exist in the resolved location\r\n            // TODO: only keep optional params coming from a parent record\r\n            matcher.keys.filter(k => !k.optional).map(k => k.name)), location.params);\r\n            // throws if cannot be stringified\r\n            path = matcher.stringify(params);\r\n        }\r\n        else if ('path' in location) {\r\n            // no need to resolve the path with the matcher as it was provided\r\n            // this also allows the user to control the encoding\r\n            path = location.path;\r\n            if ((process.env.NODE_ENV !== 'production') && !path.startsWith('/')) {\r\n                warn(`The Matcher cannot resolve relative paths but received \"${path}\". Unless you directly called \\`matcher.resolve(\"${path}\")\\`, this is probably a bug in vue-router. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/router.`);\r\n            }\r\n            matcher = matchers.find(m => m.re.test(path));\r\n            // matcher should have a value after the loop\r\n            if (matcher) {\r\n                // TODO: dev warning of unused params if provided\r\n                // we know the matcher works because we tested the regexp\r\n                params = matcher.parse(path);\r\n                name = matcher.record.name;\r\n            }\r\n            // location is a relative path\r\n        }\r\n        else {\r\n            // match by name or path of current route\r\n            matcher = currentLocation.name\r\n                ? matcherMap.get(currentLocation.name)\r\n                : matchers.find(m => m.re.test(currentLocation.path));\r\n            if (!matcher)\r\n                throw createRouterError(1 /* MATCHER_NOT_FOUND */, {\r\n                    location,\r\n                    currentLocation,\r\n                });\r\n            name = matcher.record.name;\r\n            // since we are navigating to the same location, we don't need to pick the\r\n            // params like when `name` is provided\r\n            params = assign({}, currentLocation.params, location.params);\r\n            path = matcher.stringify(params);\r\n        }\r\n        const matched = [];\r\n        let parentMatcher = matcher;\r\n        while (parentMatcher) {\r\n            // reversed order so parents are at the beginning\r\n            matched.unshift(parentMatcher.record);\r\n            parentMatcher = parentMatcher.parent;\r\n        }\r\n        return {\r\n            name,\r\n            path,\r\n            params,\r\n            matched,\r\n            meta: mergeMetaFields(matched),\r\n        };\r\n    }\r\n    // add initial routes\r\n    routes.forEach(route => addRoute(route));\r\n    return { addRoute, resolve, removeRoute, getRoutes, getRecordMatcher };\r\n}\r\nfunction paramsFromLocation(params, keys) {\r\n    const newParams = {};\r\n    for (const key of keys) {\r\n        if (key in params)\r\n            newParams[key] = params[key];\r\n    }\r\n    return newParams;\r\n}\r\n/**\r\n * Normalizes a RouteRecordRaw. Creates a copy\r\n *\r\n * @param record\r\n * @returns the normalized version\r\n */\r\nfunction normalizeRouteRecord(record) {\r\n    return {\r\n        path: record.path,\r\n        redirect: record.redirect,\r\n        name: record.name,\r\n        meta: record.meta || {},\r\n        aliasOf: undefined,\r\n        beforeEnter: record.beforeEnter,\r\n        props: normalizeRecordProps(record),\r\n        children: record.children || [],\r\n        instances: {},\r\n        leaveGuards: new Set(),\r\n        updateGuards: new Set(),\r\n        enterCallbacks: {},\r\n        components: 'components' in record\r\n            ? record.components || {}\r\n            : { default: record.component },\r\n    };\r\n}\r\n/**\r\n * Normalize the optional `props` in a record to always be an object similar to\r\n * components. Also accept a boolean for components.\r\n * @param record\r\n */\r\nfunction normalizeRecordProps(record) {\r\n    const propsObject = {};\r\n    // props does not exist on redirect records but we can set false directly\r\n    const props = record.props || false;\r\n    if ('component' in record) {\r\n        propsObject.default = props;\r\n    }\r\n    else {\r\n        // NOTE: we could also allow a function to be applied to every component.\r\n        // Would need user feedback for use cases\r\n        for (const name in record.components)\r\n            propsObject[name] = typeof props === 'boolean' ? props : props[name];\r\n    }\r\n    return propsObject;\r\n}\r\n/**\r\n * Checks if a record or any of its parent is an alias\r\n * @param record\r\n */\r\nfunction isAliasRecord(record) {\r\n    while (record) {\r\n        if (record.record.aliasOf)\r\n            return true;\r\n        record = record.parent;\r\n    }\r\n    return false;\r\n}\r\n/**\r\n * Merge meta fields of an array of records\r\n *\r\n * @param matched - array of matched records\r\n */\r\nfunction mergeMetaFields(matched) {\r\n    return matched.reduce((meta, record) => assign(meta, record.meta), {});\r\n}\r\nfunction mergeOptions(defaults, partialOptions) {\r\n    const options = {};\r\n    for (const key in defaults) {\r\n        options[key] = key in partialOptions ? partialOptions[key] : defaults[key];\r\n    }\r\n    return options;\r\n}\r\nfunction isSameParam(a, b) {\r\n    return (a.name === b.name &&\r\n        a.optional === b.optional &&\r\n        a.repeatable === b.repeatable);\r\n}\r\n/**\r\n * Check if a path and its alias have the same required params\r\n *\r\n * @param a - original record\r\n * @param b - alias record\r\n */\r\nfunction checkSameParams(a, b) {\r\n    for (const key of a.keys) {\r\n        if (!key.optional && !b.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n    for (const key of b.keys) {\r\n        if (!key.optional && !a.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Alias \"${b.record.path}\" and the original record: \"${a.record.path}\" should have the exact same param named \"${key.name}\"`);\r\n    }\r\n}\r\nfunction checkMissingParamsInAbsolutePath(record, parent) {\r\n    for (const key of parent.keys) {\r\n        if (!record.keys.find(isSameParam.bind(null, key)))\r\n            return warn(`Absolute path \"${record.record.path}\" should have the exact same param named \"${key.name}\" as its parent \"${parent.record.path}\".`);\r\n    }\r\n}\r\nfunction isRecordChildOf(record, parent) {\r\n    return parent.children.some(child => child === record || isRecordChildOf(record, child));\r\n}\n\n/**\r\n * Encoding Rules  = Space Path:  \" < > # ? { } Query:  \" < > # & = Hash:  \"\r\n * < > `\r\n *\r\n * On top of that, the RFC3986 (https://tools.ietf.org/html/rfc3986#section-2.2)\r\n * defines some extra characters to be encoded. Most browsers do not encode them\r\n * in encodeURI https://github.com/whatwg/url/issues/369, so it may be safer to\r\n * also encode `!'()*`. Leaving unencoded only ASCII alphanumeric(`a-zA-Z0-9`)\r\n * plus `-._~`. This extra safety should be applied to query by patching the\r\n * string returned by encodeURIComponent encodeURI also encodes `[\\]^`. `\\`\r\n * should be encoded to avoid ambiguity. Browsers (IE, FF, C) transform a `\\`\r\n * into a `/` if directly typed in. The _backtick_ (`````) should also be\r\n * encoded everywhere because some browsers like FF encode it when directly\r\n * written while others don't. Safari and IE don't encode ``\"<>{}``` in hash.\r\n */\r\n// const EXTRA_RESERVED_RE = /[!'()*]/g\r\n// const encodeReservedReplacer = (c: string) => '%' + c.charCodeAt(0).toString(16)\r\nconst HASH_RE = /#/g; // %23\r\nconst AMPERSAND_RE = /&/g; // %26\r\nconst SLASH_RE = /\\//g; // %2F\r\nconst EQUAL_RE = /=/g; // %3D\r\nconst IM_RE = /\\?/g; // %3F\r\nconst PLUS_RE = /\\+/g; // %2B\r\n/**\r\n * NOTE: It's not clear to me if we should encode the + symbol in queries, it\r\n * seems to be less flexible than not doing so and I can't find out the legacy\r\n * systems requiring this for regular requests like text/html. In the standard,\r\n * the encoding of the plus character is only mentioned for\r\n * application/x-www-form-urlencoded\r\n * (https://url.spec.whatwg.org/#urlencoded-parsing) and most browsers seems lo\r\n * leave the plus character as is in queries. To be more flexible, we allow the\r\n * plus character on the query but it can also be manually encoded by the user.\r\n *\r\n * Resources:\r\n * - https://url.spec.whatwg.org/#urlencoded-parsing\r\n * - https://stackoverflow.com/questions/1634271/url-encoding-the-space-character-or-20\r\n */\r\nconst ENC_BRACKET_OPEN_RE = /%5B/g; // [\r\nconst ENC_BRACKET_CLOSE_RE = /%5D/g; // ]\r\nconst ENC_CARET_RE = /%5E/g; // ^\r\nconst ENC_BACKTICK_RE = /%60/g; // `\r\nconst ENC_CURLY_OPEN_RE = /%7B/g; // {\r\nconst ENC_PIPE_RE = /%7C/g; // |\r\nconst ENC_CURLY_CLOSE_RE = /%7D/g; // }\r\nconst ENC_SPACE_RE = /%20/g; // }\r\n/**\r\n * Encode characters that need to be encoded on the path, search and hash\r\n * sections of the URL.\r\n *\r\n * @internal\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction commonEncode(text) {\r\n    return encodeURI('' + text)\r\n        .replace(ENC_PIPE_RE, '|')\r\n        .replace(ENC_BRACKET_OPEN_RE, '[')\r\n        .replace(ENC_BRACKET_CLOSE_RE, ']');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the hash section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeHash(text) {\r\n    return commonEncode(text)\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^');\r\n}\r\n/**\r\n * Encode characters that need to be encoded query values on the query\r\n * section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeQueryValue(text) {\r\n    return (commonEncode(text)\r\n        // Encode the space as +, encode the + to differentiate it from the space\r\n        .replace(PLUS_RE, '%2B')\r\n        .replace(ENC_SPACE_RE, '+')\r\n        .replace(HASH_RE, '%23')\r\n        .replace(AMPERSAND_RE, '%26')\r\n        .replace(ENC_BACKTICK_RE, '`')\r\n        .replace(ENC_CURLY_OPEN_RE, '{')\r\n        .replace(ENC_CURLY_CLOSE_RE, '}')\r\n        .replace(ENC_CARET_RE, '^'));\r\n}\r\n/**\r\n * Like `encodeQueryValue` but also encodes the `=` character.\r\n *\r\n * @param text - string to encode\r\n */\r\nfunction encodeQueryKey(text) {\r\n    return encodeQueryValue(text).replace(EQUAL_RE, '%3D');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodePath(text) {\r\n    return commonEncode(text).replace(HASH_RE, '%23').replace(IM_RE, '%3F');\r\n}\r\n/**\r\n * Encode characters that need to be encoded on the path section of the URL as a\r\n * param. This function encodes everything {@link encodePath} does plus the\r\n * slash (`/`) character. If `text` is `null` or `undefined`, returns an empty\r\n * string instead.\r\n *\r\n * @param text - string to encode\r\n * @returns encoded string\r\n */\r\nfunction encodeParam(text) {\r\n    return text == null ? '' : encodePath(text).replace(SLASH_RE, '%2F');\r\n}\r\n/**\r\n * Decode text using `decodeURIComponent`. Returns the original text if it\r\n * fails.\r\n *\r\n * @param text - string to decode\r\n * @returns decoded string\r\n */\r\nfunction decode(text) {\r\n    try {\r\n        return decodeURIComponent('' + text);\r\n    }\r\n    catch (err) {\r\n        (process.env.NODE_ENV !== 'production') && warn(`Error decoding \"${text}\". Using original value`);\r\n    }\r\n    return '' + text;\r\n}\n\n/**\r\n * Transforms a queryString into a {@link LocationQuery} object. Accept both, a\r\n * version with the leading `?` and without Should work as URLSearchParams\r\n\n * @internal\r\n *\r\n * @param search - search string to parse\r\n * @returns a query object\r\n */\r\nfunction parseQuery(search) {\r\n    const query = {};\r\n    // avoid creating an object with an empty key and empty value\r\n    // because of split('&')\r\n    if (search === '' || search === '?')\r\n        return query;\r\n    const hasLeadingIM = search[0] === '?';\r\n    const searchParams = (hasLeadingIM ? search.slice(1) : search).split('&');\r\n    for (let i = 0; i < searchParams.length; ++i) {\r\n        // pre decode the + into space\r\n        const searchParam = searchParams[i].replace(PLUS_RE, ' ');\r\n        // allow the = character\r\n        const eqPos = searchParam.indexOf('=');\r\n        const key = decode(eqPos < 0 ? searchParam : searchParam.slice(0, eqPos));\r\n        const value = eqPos < 0 ? null : decode(searchParam.slice(eqPos + 1));\r\n        if (key in query) {\r\n            // an extra variable for ts types\r\n            let currentValue = query[key];\r\n            if (!Array.isArray(currentValue)) {\r\n                currentValue = query[key] = [currentValue];\r\n            }\r\n            currentValue.push(value);\r\n        }\r\n        else {\r\n            query[key] = value;\r\n        }\r\n    }\r\n    return query;\r\n}\r\n/**\r\n * Stringifies a {@link LocationQueryRaw} object. Like `URLSearchParams`, it\r\n * doesn't prepend a `?`\r\n *\r\n * @internal\r\n *\r\n * @param query - query object to stringify\r\n * @returns string version of the query without the leading `?`\r\n */\r\nfunction stringifyQuery(query) {\r\n    let search = '';\r\n    for (let key in query) {\r\n        const value = query[key];\r\n        key = encodeQueryKey(key);\r\n        if (value == null) {\r\n            // only null adds the value\r\n            if (value !== undefined) {\r\n                search += (search.length ? '&' : '') + key;\r\n            }\r\n            continue;\r\n        }\r\n        // keep null values\r\n        const values = Array.isArray(value)\r\n            ? value.map(v => v && encodeQueryValue(v))\r\n            : [value && encodeQueryValue(value)];\r\n        values.forEach(value => {\r\n            // skip undefined values in arrays as if they were not present\r\n            // smaller code than using filter\r\n            if (value !== undefined) {\r\n                // only append & with non-empty search\r\n                search += (search.length ? '&' : '') + key;\r\n                if (value != null)\r\n                    search += '=' + value;\r\n            }\r\n        });\r\n    }\r\n    return search;\r\n}\r\n/**\r\n * Transforms a {@link LocationQueryRaw} into a {@link LocationQuery} by casting\r\n * numbers into strings, removing keys with an undefined value and replacing\r\n * undefined with null in arrays\r\n *\r\n * @param query - query object to normalize\r\n * @returns a normalized query object\r\n */\r\nfunction normalizeQuery(query) {\r\n    const normalizedQuery = {};\r\n    for (const key in query) {\r\n        const value = query[key];\r\n        if (value !== undefined) {\r\n            normalizedQuery[key] = Array.isArray(value)\r\n                ? value.map(v => (v == null ? null : '' + v))\r\n                : value == null\r\n                    ? value\r\n                    : '' + value;\r\n        }\r\n    }\r\n    return normalizedQuery;\r\n}\n\n/**\r\n * Create a list of callbacks that can be reset. Used to create before and after navigation guards list\r\n */\r\nfunction useCallbacks() {\r\n    let handlers = [];\r\n    function add(handler) {\r\n        handlers.push(handler);\r\n        return () => {\r\n            const i = handlers.indexOf(handler);\r\n            if (i > -1)\r\n                handlers.splice(i, 1);\r\n        };\r\n    }\r\n    function reset() {\r\n        handlers = [];\r\n    }\r\n    return {\r\n        add,\r\n        list: () => handlers,\r\n        reset,\r\n    };\r\n}\n\nfunction registerGuard(record, name, guard) {\r\n    const removeFromList = () => {\r\n        record[name].delete(guard);\r\n    };\r\n    onUnmounted(removeFromList);\r\n    onDeactivated(removeFromList);\r\n    onActivated(() => {\r\n        record[name].add(guard);\r\n    });\r\n    record[name].add(guard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the component for the current\r\n * location is about to be left. Similar to {@link beforeRouteLeave} but can be\r\n * used in any component. The guard is removed when the component is unmounted.\r\n *\r\n * @param leaveGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteLeave(leaveGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteLeave() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, \r\n    // to avoid warning\r\n    {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found when calling `onBeforeRouteLeave()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'leaveGuards', leaveGuard);\r\n}\r\n/**\r\n * Add a navigation guard that triggers whenever the current location is about\r\n * to be updated. Similar to {@link beforeRouteUpdate} but can be used in any\r\n * component. The guard is removed when the component is unmounted.\r\n *\r\n * @param updateGuard - {@link NavigationGuard}\r\n */\r\nfunction onBeforeRouteUpdate(updateGuard) {\r\n    if ((process.env.NODE_ENV !== 'production') && !getCurrentInstance()) {\r\n        warn('getCurrentInstance() returned null. onBeforeRouteUpdate() must be called at the top of a setup function');\r\n        return;\r\n    }\r\n    const activeRecord = inject(matchedRouteKey, \r\n    // to avoid warning\r\n    {}).value;\r\n    if (!activeRecord) {\r\n        (process.env.NODE_ENV !== 'production') &&\r\n            warn('No active route record was found when calling `onBeforeRouteUpdate()`. Make sure you call this function inside of a component child of <router-view>. Maybe you called it inside of App.vue?');\r\n        return;\r\n    }\r\n    registerGuard(activeRecord, 'updateGuards', updateGuard);\r\n}\r\nfunction guardToPromiseFn(guard, to, from, record, name) {\r\n    // keep a reference to the enterCallbackArray to prevent pushing callbacks if a new navigation took place\r\n    const enterCallbackArray = record &&\r\n        // name is defined if record is because of the function overload\r\n        (record.enterCallbacks[name] = record.enterCallbacks[name] || []);\r\n    return () => new Promise((resolve, reject) => {\r\n        const next = (valid) => {\r\n            if (valid === false)\r\n                reject(createRouterError(4 /* NAVIGATION_ABORTED */, {\r\n                    from,\r\n                    to,\r\n                }));\r\n            else if (valid instanceof Error) {\r\n                reject(valid);\r\n            }\r\n            else if (isRouteLocation(valid)) {\r\n                reject(createRouterError(2 /* NAVIGATION_GUARD_REDIRECT */, {\r\n                    from: to,\r\n                    to: valid,\r\n                }));\r\n            }\r\n            else {\r\n                if (enterCallbackArray &&\r\n                    // since enterCallbackArray is truthy, both record and name also are\r\n                    record.enterCallbacks[name] === enterCallbackArray &&\r\n                    typeof valid === 'function')\r\n                    enterCallbackArray.push(valid);\r\n                resolve();\r\n            }\r\n        };\r\n        // wrapping with Promise.resolve allows it to work with both async and sync guards\r\n        const guardReturn = guard.call(record && record.instances[name], to, from, (process.env.NODE_ENV !== 'production') ? canOnlyBeCalledOnce(next, to, from) : next);\r\n        let guardCall = Promise.resolve(guardReturn);\r\n        if (guard.length < 3)\r\n            guardCall = guardCall.then(next);\r\n        if ((process.env.NODE_ENV !== 'production') && guard.length > 2) {\r\n            const message = `The \"next\" callback was never called inside of ${guard.name ? '\"' + guard.name + '\"' : ''}:\\n${guard.toString()}\\n. If you are returning a value instead of calling \"next\", make sure to remove the \"next\" parameter from your function.`;\r\n            if (typeof guardReturn === 'object' && 'then' in guardReturn) {\r\n                guardCall = guardCall.then(resolvedValue => {\r\n                    // @ts-expect-error: _called is added at canOnlyBeCalledOnce\r\n                    if (!next._called) {\r\n                        warn(message);\r\n                        return Promise.reject(new Error('Invalid navigation guard'));\r\n                    }\r\n                    return resolvedValue;\r\n                });\r\n                // TODO: test me!\r\n            }\r\n            else if (guardReturn !== undefined) {\r\n                // @ts-expect-error: _called is added at canOnlyBeCalledOnce\r\n                if (!next._called) {\r\n                    warn(message);\r\n                    reject(new Error('Invalid navigation guard'));\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        guardCall.catch(err => reject(err));\r\n    });\r\n}\r\nfunction canOnlyBeCalledOnce(next, to, from) {\r\n    let called = 0;\r\n    return function () {\r\n        if (called++ === 1)\r\n            warn(`The \"next\" callback was called more than once in one navigation guard when going from \"${from.fullPath}\" to \"${to.fullPath}\". It should be called exactly one time in each navigation guard. This will fail in production.`);\r\n        // @ts-expect-error: we put it in the original one because it's easier to check\r\n        next._called = true;\r\n        if (called === 1)\r\n            next.apply(null, arguments);\r\n    };\r\n}\r\nfunction extractComponentsGuards(matched, guardType, to, from) {\r\n    const guards = [];\r\n    for (const record of matched) {\r\n        for (const name in record.components) {\r\n            let rawComponent = record.components[name];\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (!rawComponent ||\r\n                    (typeof rawComponent !== 'object' &&\r\n                        typeof rawComponent !== 'function')) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is not` +\r\n                        ` a valid component. Received \"${String(rawComponent)}\".`);\r\n                    // throw to ensure we stop here but warn to ensure the message isn't\r\n                    // missed by the user\r\n                    throw new Error('Invalid route component');\r\n                }\r\n                else if ('then' in rawComponent) {\r\n                    // warn if user wrote import('/component.vue') instead of () =>\r\n                    // import('./component.vue')\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a ` +\r\n                        `Promise instead of a function that returns a Promise. Did you ` +\r\n                        `write \"import('./MyPage.vue')\" instead of ` +\r\n                        `\"() => import('./MyPage.vue')\" ? This will break in ` +\r\n                        `production if not fixed.`);\r\n                    const promise = rawComponent;\r\n                    rawComponent = () => promise;\r\n                }\r\n                else if (rawComponent.__asyncLoader &&\r\n                    // warn only once per component\r\n                    !rawComponent.__warnedDefineAsync) {\r\n                    rawComponent.__warnedDefineAsync = true;\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is defined ` +\r\n                        `using \"defineAsyncComponent()\". ` +\r\n                        `Write \"() => import('./MyPage.vue')\" instead of ` +\r\n                        `\"defineAsyncComponent(() => import('./MyPage.vue'))\".`);\r\n                }\r\n            }\r\n            // skip update and leave guards if the route component is not mounted\r\n            if (guardType !== 'beforeRouteEnter' && !record.instances[name])\r\n                continue;\r\n            if (isRouteComponent(rawComponent)) {\r\n                // __vccOpts is added by vue-class-component and contain the regular options\r\n                const options = rawComponent.__vccOpts || rawComponent;\r\n                const guard = options[guardType];\r\n                guard && guards.push(guardToPromiseFn(guard, to, from, record, name));\r\n            }\r\n            else {\r\n                // start requesting the chunk already\r\n                let componentPromise = rawComponent();\r\n                if ((process.env.NODE_ENV !== 'production') && !('catch' in componentPromise)) {\r\n                    warn(`Component \"${name}\" in record with path \"${record.path}\" is a function that does not return a Promise. If you were passing a functional component, make sure to add a \"displayName\" to the component. This will break in production if not fixed.`);\r\n                    componentPromise = Promise.resolve(componentPromise);\r\n                }\r\n                guards.push(() => componentPromise.then(resolved => {\r\n                    if (!resolved)\r\n                        return Promise.reject(new Error(`Couldn't resolve component \"${name}\" at \"${record.path}\"`));\r\n                    const resolvedComponent = isESModule(resolved)\r\n                        ? resolved.default\r\n                        : resolved;\r\n                    // replace the function with the resolved component\r\n                    record.components[name] = resolvedComponent;\r\n                    // __vccOpts is added by vue-class-component and contain the regular options\r\n                    const options = resolvedComponent.__vccOpts || resolvedComponent;\r\n                    const guard = options[guardType];\r\n                    return guard && guardToPromiseFn(guard, to, from, record, name)();\r\n                }));\r\n            }\r\n        }\r\n    }\r\n    return guards;\r\n}\r\n/**\r\n * Allows differentiating lazy components from functional components and vue-class-component\r\n *\r\n * @param component\r\n */\r\nfunction isRouteComponent(component) {\r\n    return (typeof component === 'object' ||\r\n        'displayName' in component ||\r\n        'props' in component ||\r\n        '__vccOpts' in component);\r\n}\n\n// TODO: we could allow currentRoute as a prop to expose `isActive` and\r\n// `isExactActive` behavior should go through an RFC\r\nfunction useLink(props) {\r\n    const router = inject(routerKey);\r\n    const currentRoute = inject(routeLocationKey);\r\n    const route = computed(() => router.resolve(unref(props.to)));\r\n    const activeRecordIndex = computed(() => {\r\n        const { matched } = route.value;\r\n        const { length } = matched;\r\n        const routeMatched = matched[length - 1];\r\n        const currentMatched = currentRoute.matched;\r\n        if (!routeMatched || !currentMatched.length)\r\n            return -1;\r\n        const index = currentMatched.findIndex(isSameRouteRecord.bind(null, routeMatched));\r\n        if (index > -1)\r\n            return index;\r\n        // possible parent record\r\n        const parentRecordPath = getOriginalPath(matched[length - 2]);\r\n        return (\r\n        // we are dealing with nested routes\r\n        length > 1 &&\r\n            // if the parent and matched route have the same path, this link is\r\n            // referring to the empty child. Or we currently are on a different\r\n            // child of the same parent\r\n            getOriginalPath(routeMatched) === parentRecordPath &&\r\n            // avoid comparing the child with its parent\r\n            currentMatched[currentMatched.length - 1].path !== parentRecordPath\r\n            ? currentMatched.findIndex(isSameRouteRecord.bind(null, matched[length - 2]))\r\n            : index);\r\n    });\r\n    const isActive = computed(() => activeRecordIndex.value > -1 &&\r\n        includesParams(currentRoute.params, route.value.params));\r\n    const isExactActive = computed(() => activeRecordIndex.value > -1 &&\r\n        activeRecordIndex.value === currentRoute.matched.length - 1 &&\r\n        isSameRouteLocationParams(currentRoute.params, route.value.params));\r\n    function navigate(e = {}) {\r\n        if (guardEvent(e)) {\r\n            return router[unref(props.replace) ? 'replace' : 'push'](unref(props.to)\r\n            // avoid uncaught errors are they are logged anyway\r\n            ).catch(noop);\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    // devtools only\r\n    if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && isBrowser) {\r\n        const instance = getCurrentInstance();\r\n        if (instance) {\r\n            const linkContextDevtools = {\r\n                route: route.value,\r\n                isActive: isActive.value,\r\n                isExactActive: isExactActive.value,\r\n            };\r\n            // @ts-expect-error: this is internal\r\n            instance.__vrl_devtools = instance.__vrl_devtools || [];\r\n            // @ts-expect-error: this is internal\r\n            instance.__vrl_devtools.push(linkContextDevtools);\r\n            watchEffect(() => {\r\n                linkContextDevtools.route = route.value;\r\n                linkContextDevtools.isActive = isActive.value;\r\n                linkContextDevtools.isExactActive = isExactActive.value;\r\n            }, { flush: 'post' });\r\n        }\r\n    }\r\n    return {\r\n        route,\r\n        href: computed(() => route.value.href),\r\n        isActive,\r\n        isExactActive,\r\n        navigate,\r\n    };\r\n}\r\nconst RouterLinkImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterLink',\r\n    props: {\r\n        to: {\r\n            type: [String, Object],\r\n            required: true,\r\n        },\r\n        replace: Boolean,\r\n        activeClass: String,\r\n        // inactiveClass: String,\r\n        exactActiveClass: String,\r\n        custom: Boolean,\r\n        ariaCurrentValue: {\r\n            type: String,\r\n            default: 'page',\r\n        },\r\n    },\r\n    useLink,\r\n    setup(props, { slots }) {\r\n        const link = reactive(useLink(props));\r\n        const { options } = inject(routerKey);\r\n        const elClass = computed(() => ({\r\n            [getLinkClass(props.activeClass, options.linkActiveClass, 'router-link-active')]: link.isActive,\r\n            // [getLinkClass(\r\n            //   props.inactiveClass,\r\n            //   options.linkInactiveClass,\r\n            //   'router-link-inactive'\r\n            // )]: !link.isExactActive,\r\n            [getLinkClass(props.exactActiveClass, options.linkExactActiveClass, 'router-link-exact-active')]: link.isExactActive,\r\n        }));\r\n        return () => {\r\n            const children = slots.default && slots.default(link);\r\n            return props.custom\r\n                ? children\r\n                : h('a', {\r\n                    'aria-current': link.isExactActive\r\n                        ? props.ariaCurrentValue\r\n                        : null,\r\n                    href: link.href,\r\n                    // this would override user added attrs but Vue will still add\r\n                    // the listener so we end up triggering both\r\n                    onClick: link.navigate,\r\n                    class: elClass.value,\r\n                }, children);\r\n        };\r\n    },\r\n});\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to render a link that triggers a navigation on click.\r\n */\r\nconst RouterLink = RouterLinkImpl;\r\nfunction guardEvent(e) {\r\n    // don't redirect with control keys\r\n    if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)\r\n        return;\r\n    // don't redirect when preventDefault called\r\n    if (e.defaultPrevented)\r\n        return;\r\n    // don't redirect on right click\r\n    if (e.button !== undefined && e.button !== 0)\r\n        return;\r\n    // don't redirect if `target=\"_blank\"`\r\n    // @ts-expect-error getAttribute does exist\r\n    if (e.currentTarget && e.currentTarget.getAttribute) {\r\n        // @ts-expect-error getAttribute exists\r\n        const target = e.currentTarget.getAttribute('target');\r\n        if (/\\b_blank\\b/i.test(target))\r\n            return;\r\n    }\r\n    // this may be a Weex event which doesn't have this method\r\n    if (e.preventDefault)\r\n        e.preventDefault();\r\n    return true;\r\n}\r\nfunction includesParams(outer, inner) {\r\n    for (const key in inner) {\r\n        const innerValue = inner[key];\r\n        const outerValue = outer[key];\r\n        if (typeof innerValue === 'string') {\r\n            if (innerValue !== outerValue)\r\n                return false;\r\n        }\r\n        else {\r\n            if (!Array.isArray(outerValue) ||\r\n                outerValue.length !== innerValue.length ||\r\n                innerValue.some((value, i) => value !== outerValue[i]))\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Get the original path value of a record by following its aliasOf\r\n * @param record\r\n */\r\nfunction getOriginalPath(record) {\r\n    return record ? (record.aliasOf ? record.aliasOf.path : record.path) : '';\r\n}\r\n/**\r\n * Utility class to get the active class based on defaults.\r\n * @param propClass\r\n * @param globalClass\r\n * @param defaultClass\r\n */\r\nconst getLinkClass = (propClass, globalClass, defaultClass) => propClass != null\r\n    ? propClass\r\n    : globalClass != null\r\n        ? globalClass\r\n        : defaultClass;\n\nconst RouterViewImpl = /*#__PURE__*/ defineComponent({\r\n    name: 'RouterView',\r\n    // #674 we manually inherit them\r\n    inheritAttrs: false,\r\n    props: {\r\n        name: {\r\n            type: String,\r\n            default: 'default',\r\n        },\r\n        route: Object,\r\n    },\r\n    setup(props, { attrs, slots }) {\r\n        (process.env.NODE_ENV !== 'production') && warnDeprecatedUsage();\r\n        const injectedRoute = inject(routerViewLocationKey);\r\n        const routeToDisplay = computed(() => props.route || injectedRoute.value);\r\n        const depth = inject(viewDepthKey, 0);\r\n        const matchedRouteRef = computed(() => routeToDisplay.value.matched[depth]);\r\n        provide(viewDepthKey, depth + 1);\r\n        provide(matchedRouteKey, matchedRouteRef);\r\n        provide(routerViewLocationKey, routeToDisplay);\r\n        const viewRef = ref();\r\n        // watch at the same time the component instance, the route record we are\r\n        // rendering, and the name\r\n        watch(() => [viewRef.value, matchedRouteRef.value, props.name], ([instance, to, name], [oldInstance, from, oldName]) => {\r\n            // copy reused instances\r\n            if (to) {\r\n                // this will update the instance for new instances as well as reused\r\n                // instances when navigating to a new route\r\n                to.instances[name] = instance;\r\n                // the component instance is reused for a different route or name so\r\n                // we copy any saved update or leave guards. With async setup, the\r\n                // mounting component will mount before the matchedRoute changes,\r\n                // making instance === oldInstance, so we check if guards have been\r\n                // added before. This works because we remove guards when\r\n                // unmounting/deactivating components\r\n                if (from && from !== to && instance && instance === oldInstance) {\r\n                    if (!to.leaveGuards.size) {\r\n                        to.leaveGuards = from.leaveGuards;\r\n                    }\r\n                    if (!to.updateGuards.size) {\r\n                        to.updateGuards = from.updateGuards;\r\n                    }\r\n                }\r\n            }\r\n            // trigger beforeRouteEnter next callbacks\r\n            if (instance &&\r\n                to &&\r\n                // if there is no instance but to and from are the same this might be\r\n                // the first visit\r\n                (!from || !isSameRouteRecord(to, from) || !oldInstance)) {\r\n                (to.enterCallbacks[name] || []).forEach(callback => callback(instance));\r\n            }\r\n        }, { flush: 'post' });\r\n        return () => {\r\n            const route = routeToDisplay.value;\r\n            const matchedRoute = matchedRouteRef.value;\r\n            const ViewComponent = matchedRoute && matchedRoute.components[props.name];\r\n            // we need the value at the time we render because when we unmount, we\r\n            // navigated to a different location so the value is different\r\n            const currentName = props.name;\r\n            if (!ViewComponent) {\r\n                return normalizeSlot(slots.default, { Component: ViewComponent, route });\r\n            }\r\n            // props from route configuration\r\n            const routePropsOption = matchedRoute.props[props.name];\r\n            const routeProps = routePropsOption\r\n                ? routePropsOption === true\r\n                    ? route.params\r\n                    : typeof routePropsOption === 'function'\r\n                        ? routePropsOption(route)\r\n                        : routePropsOption\r\n                : null;\r\n            const onVnodeUnmounted = vnode => {\r\n                // remove the instance reference to prevent leak\r\n                if (vnode.component.isUnmounted) {\r\n                    matchedRoute.instances[currentName] = null;\r\n                }\r\n            };\r\n            const component = h(ViewComponent, assign({}, routeProps, attrs, {\r\n                onVnodeUnmounted,\r\n                ref: viewRef,\r\n            }));\r\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) &&\r\n                isBrowser &&\r\n                component.ref) {\r\n                // TODO: can display if it's an alias, its props\r\n                const info = {\r\n                    depth,\r\n                    name: matchedRoute.name,\r\n                    path: matchedRoute.path,\r\n                    meta: matchedRoute.meta,\r\n                };\r\n                const internalInstances = Array.isArray(component.ref)\r\n                    ? component.ref.map(r => r.i)\r\n                    : [component.ref.i];\r\n                internalInstances.forEach(instance => {\r\n                    // @ts-expect-error\r\n                    instance.__vrv_devtools = info;\r\n                });\r\n            }\r\n            return (\r\n            // pass the vnode to the slot as a prop.\r\n            // h and <component :is=\"...\"> both accept vnodes\r\n            normalizeSlot(slots.default, { Component: component, route }) ||\r\n                component);\r\n        };\r\n    },\r\n});\r\nfunction normalizeSlot(slot, data) {\r\n    if (!slot)\r\n        return null;\r\n    const slotContent = slot(data);\r\n    return slotContent.length === 1 ? slotContent[0] : slotContent;\r\n}\r\n// export the public type for h/tsx inference\r\n// also to avoid inline import() in generated d.ts files\r\n/**\r\n * Component to display the current route the user is at.\r\n */\r\nconst RouterView = RouterViewImpl;\r\n// warn against deprecated usage with <transition> & <keep-alive>\r\n// due to functional component being no longer eager in Vue 3\r\nfunction warnDeprecatedUsage() {\r\n    const instance = getCurrentInstance();\r\n    const parentName = instance.parent && instance.parent.type.name;\r\n    if (parentName &&\r\n        (parentName === 'KeepAlive' || parentName.includes('Transition'))) {\r\n        const comp = parentName === 'KeepAlive' ? 'keep-alive' : 'transition';\r\n        warn(`<router-view> can no longer be used directly inside <transition> or <keep-alive>.\\n` +\r\n            `Use slot props instead:\\n\\n` +\r\n            `<router-view v-slot=\"{ Component }\">\\n` +\r\n            `  <${comp}>\\n` +\r\n            `    <component :is=\"Component\" />\\n` +\r\n            `  </${comp}>\\n` +\r\n            `</router-view>`);\r\n    }\r\n}\n\nfunction formatRouteLocation(routeLocation, tooltip) {\r\n    const copy = assign({}, routeLocation, {\r\n        // remove variables that can contain vue instances\r\n        matched: routeLocation.matched.map(matched => omit(matched, ['instances', 'children', 'aliasOf'])),\r\n    });\r\n    return {\r\n        _custom: {\r\n            type: null,\r\n            readOnly: true,\r\n            display: routeLocation.fullPath,\r\n            tooltip,\r\n            value: copy,\r\n        },\r\n    };\r\n}\r\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\n// to support multiple router instances\r\nlet routerId = 0;\r\nfunction addDevtools(app, router, matcher) {\r\n    // Take over router.beforeEach and afterEach\r\n    // make sure we are not registering the devtool twice\r\n    if (router.__hasDevtools)\r\n        return;\r\n    router.__hasDevtools = true;\r\n    // increment to support multiple router instances\r\n    const id = routerId++;\r\n    setupDevtoolsPlugin({\r\n        id: 'org.vuejs.router' + (id ? '.' + id : ''),\r\n        label: 'Vue Router',\r\n        packageName: 'vue-router',\r\n        homepage: 'https://router.vuejs.org',\r\n        logo: 'https://router.vuejs.org/logo.png',\r\n        componentStateTypes: ['Routing'],\r\n        app,\r\n    }, api => {\r\n        // display state added by the router\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            if (payload.instanceData) {\r\n                payload.instanceData.state.push({\r\n                    type: 'Routing',\r\n                    key: '$route',\r\n                    editable: false,\r\n                    value: formatRouteLocation(router.currentRoute.value, 'Current Route'),\r\n                });\r\n            }\r\n        });\r\n        // mark router-link as active and display tags on router views\r\n        api.on.visitComponentTree(({ treeNode: node, componentInstance }) => {\r\n            if (componentInstance.__vrv_devtools) {\r\n                const info = componentInstance.__vrv_devtools;\r\n                node.tags.push({\r\n                    label: (info.name ? `${info.name.toString()}: ` : '') + info.path,\r\n                    textColor: 0,\r\n                    tooltip: 'This component is rendered by &lt;router-view&gt;',\r\n                    backgroundColor: PINK_500,\r\n                });\r\n            }\r\n            // if multiple useLink are used\r\n            if (Array.isArray(componentInstance.__vrl_devtools)) {\r\n                componentInstance.__devtoolsApi = api;\r\n                componentInstance.__vrl_devtools.forEach(devtoolsData => {\r\n                    let backgroundColor = ORANGE_400;\r\n                    let tooltip = '';\r\n                    if (devtoolsData.isExactActive) {\r\n                        backgroundColor = LIME_500;\r\n                        tooltip = 'This is exactly active';\r\n                    }\r\n                    else if (devtoolsData.isActive) {\r\n                        backgroundColor = BLUE_600;\r\n                        tooltip = 'This link is active';\r\n                    }\r\n                    node.tags.push({\r\n                        label: devtoolsData.route.path,\r\n                        textColor: 0,\r\n                        tooltip,\r\n                        backgroundColor,\r\n                    });\r\n                });\r\n            }\r\n        });\r\n        watch(router.currentRoute, () => {\r\n            // refresh active state\r\n            refreshRoutesView();\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(routerInspectorId);\r\n            api.sendInspectorState(routerInspectorId);\r\n        });\r\n        const navigationsLayerId = 'router:navigations:' + id;\r\n        api.addTimelineLayer({\r\n            id: navigationsLayerId,\r\n            label: `Router${id ? ' ' + id : ''} Navigations`,\r\n            color: 0x40a8c4,\r\n        });\r\n        // const errorsLayerId = 'router:errors'\r\n        // api.addTimelineLayer({\r\n        //   id: errorsLayerId,\r\n        //   label: 'Router Errors',\r\n        //   color: 0xea5455,\r\n        // })\r\n        router.onError((error, to) => {\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    title: 'Error during Navigation',\r\n                    subtitle: to.fullPath,\r\n                    logType: 'error',\r\n                    time: Date.now(),\r\n                    data: { error },\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        // attached to `meta` and used to group events\r\n        let navigationId = 0;\r\n        router.beforeEach((to, from) => {\r\n            const data = {\r\n                guard: formatDisplay('beforeEach'),\r\n                from: formatRouteLocation(from, 'Current Location during this navigation'),\r\n                to: formatRouteLocation(to, 'Target location'),\r\n            };\r\n            // Used to group navigations together, hide from devtools\r\n            Object.defineProperty(to.meta, '__navigationId', {\r\n                value: navigationId++,\r\n            });\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    time: Date.now(),\r\n                    title: 'Start of navigation',\r\n                    subtitle: to.fullPath,\r\n                    data,\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        router.afterEach((to, from, failure) => {\r\n            const data = {\r\n                guard: formatDisplay('afterEach'),\r\n            };\r\n            if (failure) {\r\n                data.failure = {\r\n                    _custom: {\r\n                        type: Error,\r\n                        readOnly: true,\r\n                        display: failure ? failure.message : '',\r\n                        tooltip: 'Navigation Failure',\r\n                        value: failure,\r\n                    },\r\n                };\r\n                data.status = formatDisplay('');\r\n            }\r\n            else {\r\n                data.status = formatDisplay('');\r\n            }\r\n            // we set here to have the right order\r\n            data.from = formatRouteLocation(from, 'Current Location during this navigation');\r\n            data.to = formatRouteLocation(to, 'Target location');\r\n            api.addTimelineEvent({\r\n                layerId: navigationsLayerId,\r\n                event: {\r\n                    title: 'End of navigation',\r\n                    subtitle: to.fullPath,\r\n                    time: Date.now(),\r\n                    data,\r\n                    logType: failure ? 'warning' : 'default',\r\n                    groupId: to.meta.__navigationId,\r\n                },\r\n            });\r\n        });\r\n        /**\r\n         * Inspector of Existing routes\r\n         */\r\n        const routerInspectorId = 'router-inspector:' + id;\r\n        api.addInspector({\r\n            id: routerInspectorId,\r\n            label: 'Routes' + (id ? ' ' + id : ''),\r\n            icon: 'book',\r\n            treeFilterPlaceholder: 'Search routes',\r\n        });\r\n        function refreshRoutesView() {\r\n            // the routes view isn't active\r\n            if (!activeRoutesPayload)\r\n                return;\r\n            const payload = activeRoutesPayload;\r\n            // children routes will appear as nested\r\n            let routes = matcher.getRoutes().filter(route => !route.parent);\r\n            // reset match state to false\r\n            routes.forEach(resetMatchStateOnRouteRecord);\r\n            // apply a match state if there is a payload\r\n            if (payload.filter) {\r\n                routes = routes.filter(route => \r\n                // save matches state based on the payload\r\n                isRouteMatching(route, payload.filter.toLowerCase()));\r\n            }\r\n            // mark active routes\r\n            routes.forEach(route => markRouteRecordActive(route, router.currentRoute.value));\r\n            payload.rootNodes = routes.map(formatRouteRecordForInspector);\r\n        }\r\n        let activeRoutesPayload;\r\n        api.on.getInspectorTree(payload => {\r\n            activeRoutesPayload = payload;\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                refreshRoutesView();\r\n            }\r\n        });\r\n        /**\r\n         * Display information about the currently selected route record\r\n         */\r\n        api.on.getInspectorState(payload => {\r\n            if (payload.app === app && payload.inspectorId === routerInspectorId) {\r\n                const routes = matcher.getRoutes();\r\n                const route = routes.find(route => route.record.__vd_id === payload.nodeId);\r\n                if (route) {\r\n                    payload.state = {\r\n                        options: formatRouteRecordMatcherForStateInspector(route),\r\n                    };\r\n                }\r\n            }\r\n        });\r\n        api.sendInspectorTree(routerInspectorId);\r\n        api.sendInspectorState(routerInspectorId);\r\n    });\r\n}\r\nfunction modifierForKey(key) {\r\n    if (key.optional) {\r\n        return key.repeatable ? '*' : '?';\r\n    }\r\n    else {\r\n        return key.repeatable ? '+' : '';\r\n    }\r\n}\r\nfunction formatRouteRecordMatcherForStateInspector(route) {\r\n    const { record } = route;\r\n    const fields = [\r\n        { editable: false, key: 'path', value: record.path },\r\n    ];\r\n    if (record.name != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'name',\r\n            value: record.name,\r\n        });\r\n    }\r\n    fields.push({ editable: false, key: 'regexp', value: route.re });\r\n    if (route.keys.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'keys',\r\n            value: {\r\n                _custom: {\r\n                    type: null,\r\n                    readOnly: true,\r\n                    display: route.keys\r\n                        .map(key => `${key.name}${modifierForKey(key)}`)\r\n                        .join(' '),\r\n                    tooltip: 'Param keys',\r\n                    value: route.keys,\r\n                },\r\n            },\r\n        });\r\n    }\r\n    if (record.redirect != null) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'redirect',\r\n            value: record.redirect,\r\n        });\r\n    }\r\n    if (route.alias.length) {\r\n        fields.push({\r\n            editable: false,\r\n            key: 'aliases',\r\n            value: route.alias.map(alias => alias.record.path),\r\n        });\r\n    }\r\n    fields.push({\r\n        key: 'score',\r\n        editable: false,\r\n        value: {\r\n            _custom: {\r\n                type: null,\r\n                readOnly: true,\r\n                display: route.score.map(score => score.join(', ')).join(' | '),\r\n                tooltip: 'Score used to sort routes',\r\n                value: route.score,\r\n            },\r\n        },\r\n    });\r\n    return fields;\r\n}\r\n/**\r\n * Extracted from tailwind palette\r\n */\r\nconst PINK_500 = 0xec4899;\r\nconst BLUE_600 = 0x2563eb;\r\nconst LIME_500 = 0x84cc16;\r\nconst CYAN_400 = 0x22d3ee;\r\nconst ORANGE_400 = 0xfb923c;\r\n// const GRAY_100 = 0xf4f4f5\r\nconst DARK = 0x666666;\r\nfunction formatRouteRecordForInspector(route) {\r\n    const tags = [];\r\n    const { record } = route;\r\n    if (record.name != null) {\r\n        tags.push({\r\n            label: String(record.name),\r\n            textColor: 0,\r\n            backgroundColor: CYAN_400,\r\n        });\r\n    }\r\n    if (record.aliasOf) {\r\n        tags.push({\r\n            label: 'alias',\r\n            textColor: 0,\r\n            backgroundColor: ORANGE_400,\r\n        });\r\n    }\r\n    if (route.__vd_match) {\r\n        tags.push({\r\n            label: 'matches',\r\n            textColor: 0,\r\n            backgroundColor: PINK_500,\r\n        });\r\n    }\r\n    if (route.__vd_exactActive) {\r\n        tags.push({\r\n            label: 'exact',\r\n            textColor: 0,\r\n            backgroundColor: LIME_500,\r\n        });\r\n    }\r\n    if (route.__vd_active) {\r\n        tags.push({\r\n            label: 'active',\r\n            textColor: 0,\r\n            backgroundColor: BLUE_600,\r\n        });\r\n    }\r\n    if (record.redirect) {\r\n        tags.push({\r\n            label: 'redirect: ' +\r\n                (typeof record.redirect === 'string' ? record.redirect : 'Object'),\r\n            textColor: 0xffffff,\r\n            backgroundColor: DARK,\r\n        });\r\n    }\r\n    // add an id to be able to select it. Using the `path` is not possible because\r\n    // empty path children would collide with their parents\r\n    let id = record.__vd_id;\r\n    if (id == null) {\r\n        id = String(routeRecordId++);\r\n        record.__vd_id = id;\r\n    }\r\n    return {\r\n        id,\r\n        label: record.path,\r\n        tags,\r\n        children: route.children.map(formatRouteRecordForInspector),\r\n    };\r\n}\r\n//  incremental id for route records and inspector state\r\nlet routeRecordId = 0;\r\nconst EXTRACT_REGEXP_RE = /^\\/(.*)\\/([a-z]*)$/;\r\nfunction markRouteRecordActive(route, currentRoute) {\r\n    // no route will be active if matched is empty\r\n    // reset the matching state\r\n    const isExactActive = currentRoute.matched.length &&\r\n        isSameRouteRecord(currentRoute.matched[currentRoute.matched.length - 1], route.record);\r\n    route.__vd_exactActive = route.__vd_active = isExactActive;\r\n    if (!isExactActive) {\r\n        route.__vd_active = currentRoute.matched.some(match => isSameRouteRecord(match, route.record));\r\n    }\r\n    route.children.forEach(childRoute => markRouteRecordActive(childRoute, currentRoute));\r\n}\r\nfunction resetMatchStateOnRouteRecord(route) {\r\n    route.__vd_match = false;\r\n    route.children.forEach(resetMatchStateOnRouteRecord);\r\n}\r\nfunction isRouteMatching(route, filter) {\r\n    const found = String(route.re).match(EXTRACT_REGEXP_RE);\r\n    route.__vd_match = false;\r\n    if (!found || found.length < 3) {\r\n        return false;\r\n    }\r\n    // use a regexp without $ at the end to match nested routes better\r\n    const nonEndingRE = new RegExp(found[1].replace(/\\$$/, ''), found[2]);\r\n    if (nonEndingRE.test(filter)) {\r\n        // mark children as matches\r\n        route.children.forEach(child => isRouteMatching(child, filter));\r\n        // exception case: `/`\r\n        if (route.record.path !== '/' || filter === '/') {\r\n            route.__vd_match = route.re.test(filter);\r\n            return true;\r\n        }\r\n        // hide the / route\r\n        return false;\r\n    }\r\n    const path = route.record.path.toLowerCase();\r\n    const decodedPath = decode(path);\r\n    // also allow partial matching on the path\r\n    if (!filter.startsWith('/') &&\r\n        (decodedPath.includes(filter) || path.includes(filter)))\r\n        return true;\r\n    if (decodedPath.startsWith(filter) || path.startsWith(filter))\r\n        return true;\r\n    if (route.record.name && String(route.record.name).includes(filter))\r\n        return true;\r\n    return route.children.some(child => isRouteMatching(child, filter));\r\n}\r\nfunction omit(obj, keys) {\r\n    const ret = {};\r\n    for (const key in obj) {\r\n        if (!keys.includes(key)) {\r\n            // @ts-expect-error\r\n            ret[key] = obj[key];\r\n        }\r\n    }\r\n    return ret;\r\n}\n\n/**\r\n * Creates a Router instance that can be used by a Vue app.\r\n *\r\n * @param options - {@link RouterOptions}\r\n */\r\nfunction createRouter(options) {\r\n    const matcher = createRouterMatcher(options.routes, options);\r\n    const parseQuery$1 = options.parseQuery || parseQuery;\r\n    const stringifyQuery$1 = options.stringifyQuery || stringifyQuery;\r\n    const routerHistory = options.history;\r\n    if ((process.env.NODE_ENV !== 'production') && !routerHistory)\r\n        throw new Error('Provide the \"history\" option when calling \"createRouter()\":' +\r\n            ' https://next.router.vuejs.org/api/#history.');\r\n    const beforeGuards = useCallbacks();\r\n    const beforeResolveGuards = useCallbacks();\r\n    const afterGuards = useCallbacks();\r\n    const currentRoute = shallowRef(START_LOCATION_NORMALIZED);\r\n    let pendingLocation = START_LOCATION_NORMALIZED;\r\n    // leave the scrollRestoration if no scrollBehavior is provided\r\n    if (isBrowser && options.scrollBehavior && 'scrollRestoration' in history) {\r\n        history.scrollRestoration = 'manual';\r\n    }\r\n    const normalizeParams = applyToParams.bind(null, paramValue => '' + paramValue);\r\n    const encodeParams = applyToParams.bind(null, encodeParam);\r\n    const decodeParams = \r\n    // @ts-expect-error: intentionally avoid the type check\r\n    applyToParams.bind(null, decode);\r\n    function addRoute(parentOrRoute, route) {\r\n        let parent;\r\n        let record;\r\n        if (isRouteName(parentOrRoute)) {\r\n            parent = matcher.getRecordMatcher(parentOrRoute);\r\n            record = route;\r\n        }\r\n        else {\r\n            record = parentOrRoute;\r\n        }\r\n        return matcher.addRoute(record, parent);\r\n    }\r\n    function removeRoute(name) {\r\n        const recordMatcher = matcher.getRecordMatcher(name);\r\n        if (recordMatcher) {\r\n            matcher.removeRoute(recordMatcher);\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            warn(`Cannot remove non-existent route \"${String(name)}\"`);\r\n        }\r\n    }\r\n    function getRoutes() {\r\n        return matcher.getRoutes().map(routeMatcher => routeMatcher.record);\r\n    }\r\n    function hasRoute(name) {\r\n        return !!matcher.getRecordMatcher(name);\r\n    }\r\n    function resolve(rawLocation, currentLocation) {\r\n        // const objectLocation = routerLocationAsObject(rawLocation)\r\n        // we create a copy to modify it later\r\n        currentLocation = assign({}, currentLocation || currentRoute.value);\r\n        if (typeof rawLocation === 'string') {\r\n            const locationNormalized = parseURL(parseQuery$1, rawLocation, currentLocation.path);\r\n            const matchedRoute = matcher.resolve({ path: locationNormalized.path }, currentLocation);\r\n            const href = routerHistory.createHref(locationNormalized.fullPath);\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                if (href.startsWith('//'))\r\n                    warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n                else if (!matchedRoute.matched.length) {\r\n                    warn(`No match found for location with path \"${rawLocation}\"`);\r\n                }\r\n            }\r\n            // locationNormalized is always a new object\r\n            return assign(locationNormalized, matchedRoute, {\r\n                params: decodeParams(matchedRoute.params),\r\n                hash: decode(locationNormalized.hash),\r\n                redirectedFrom: undefined,\r\n                href,\r\n            });\r\n        }\r\n        let matcherLocation;\r\n        // path could be relative in object as well\r\n        if ('path' in rawLocation) {\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                'params' in rawLocation &&\r\n                !('name' in rawLocation) &&\r\n                // @ts-expect-error: the type is never\r\n                Object.keys(rawLocation.params).length) {\r\n                warn(`Path \"${\r\n                // @ts-expect-error: the type is never\r\n                rawLocation.path}\" was passed with params but they will be ignored. Use a named route alongside params instead.`);\r\n            }\r\n            matcherLocation = assign({}, rawLocation, {\r\n                path: parseURL(parseQuery$1, rawLocation.path, currentLocation.path).path,\r\n            });\r\n        }\r\n        else {\r\n            // remove any nullish param\r\n            const targetParams = assign({}, rawLocation.params);\r\n            for (const key in targetParams) {\r\n                if (targetParams[key] == null) {\r\n                    delete targetParams[key];\r\n                }\r\n            }\r\n            // pass encoded values to the matcher so it can produce encoded path and fullPath\r\n            matcherLocation = assign({}, rawLocation, {\r\n                params: encodeParams(rawLocation.params),\r\n            });\r\n            // current location params are decoded, we need to encode them in case the\r\n            // matcher merges the params\r\n            currentLocation.params = encodeParams(currentLocation.params);\r\n        }\r\n        const matchedRoute = matcher.resolve(matcherLocation, currentLocation);\r\n        const hash = rawLocation.hash || '';\r\n        if ((process.env.NODE_ENV !== 'production') && hash && !hash.startsWith('#')) {\r\n            warn(`A \\`hash\\` should always start with the character \"#\". Replace \"${hash}\" with \"#${hash}\".`);\r\n        }\r\n        // decoding them) the matcher might have merged current location params so\r\n        // we need to run the decoding again\r\n        matchedRoute.params = normalizeParams(decodeParams(matchedRoute.params));\r\n        const fullPath = stringifyURL(stringifyQuery$1, assign({}, rawLocation, {\r\n            hash: encodeHash(hash),\r\n            path: matchedRoute.path,\r\n        }));\r\n        const href = routerHistory.createHref(fullPath);\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            if (href.startsWith('//')) {\r\n                warn(`Location \"${rawLocation}\" resolved to \"${href}\". A resolved location cannot start with multiple slashes.`);\r\n            }\r\n            else if (!matchedRoute.matched.length) {\r\n                warn(`No match found for location with path \"${'path' in rawLocation ? rawLocation.path : rawLocation}\"`);\r\n            }\r\n        }\r\n        return assign({\r\n            fullPath,\r\n            // keep the hash encoded so fullPath is effectively path + encodedQuery +\r\n            // hash\r\n            hash,\r\n            query: \r\n            // if the user is using a custom query lib like qs, we might have\r\n            // nested objects, so we keep the query as is, meaning it can contain\r\n            // numbers at `$route.query`, but at the point, the user will have to\r\n            // use their own type anyway.\r\n            // https://github.com/vuejs/router/issues/328#issuecomment-649481567\r\n            stringifyQuery$1 === stringifyQuery\r\n                ? normalizeQuery(rawLocation.query)\r\n                : (rawLocation.query || {}),\r\n        }, matchedRoute, {\r\n            redirectedFrom: undefined,\r\n            href,\r\n        });\r\n    }\r\n    function locationAsObject(to) {\r\n        return typeof to === 'string'\r\n            ? parseURL(parseQuery$1, to, currentRoute.value.path)\r\n            : assign({}, to);\r\n    }\r\n    function checkCanceledNavigation(to, from) {\r\n        if (pendingLocation !== to) {\r\n            return createRouterError(8 /* NAVIGATION_CANCELLED */, {\r\n                from,\r\n                to,\r\n            });\r\n        }\r\n    }\r\n    function push(to) {\r\n        return pushWithRedirect(to);\r\n    }\r\n    function replace(to) {\r\n        return push(assign(locationAsObject(to), { replace: true }));\r\n    }\r\n    function handleRedirectRecord(to) {\r\n        const lastMatched = to.matched[to.matched.length - 1];\r\n        if (lastMatched && lastMatched.redirect) {\r\n            const { redirect } = lastMatched;\r\n            let newTargetLocation = typeof redirect === 'function' ? redirect(to) : redirect;\r\n            if (typeof newTargetLocation === 'string') {\r\n                newTargetLocation =\r\n                    newTargetLocation.includes('?') || newTargetLocation.includes('#')\r\n                        ? (newTargetLocation = locationAsObject(newTargetLocation))\r\n                        : // force empty params\r\n                            { path: newTargetLocation };\r\n                // @ts-expect-error: force empty params when a string is passed to let\r\n                // the router parse them again\r\n                newTargetLocation.params = {};\r\n            }\r\n            if ((process.env.NODE_ENV !== 'production') &&\r\n                !('path' in newTargetLocation) &&\r\n                !('name' in newTargetLocation)) {\r\n                warn(`Invalid redirect found:\\n${JSON.stringify(newTargetLocation, null, 2)}\\n when navigating to \"${to.fullPath}\". A redirect must contain a name or path. This will break in production.`);\r\n                throw new Error('Invalid redirect');\r\n            }\r\n            return assign({\r\n                query: to.query,\r\n                hash: to.hash,\r\n                params: to.params,\r\n            }, newTargetLocation);\r\n        }\r\n    }\r\n    function pushWithRedirect(to, redirectedFrom) {\r\n        const targetLocation = (pendingLocation = resolve(to));\r\n        const from = currentRoute.value;\r\n        const data = to.state;\r\n        const force = to.force;\r\n        // to could be a string where `replace` is a function\r\n        const replace = to.replace === true;\r\n        const shouldRedirect = handleRedirectRecord(targetLocation);\r\n        if (shouldRedirect)\r\n            return pushWithRedirect(assign(locationAsObject(shouldRedirect), {\r\n                state: data,\r\n                force,\r\n                replace,\r\n            }), \r\n            // keep original redirectedFrom if it exists\r\n            redirectedFrom || targetLocation);\r\n        // if it was a redirect we already called `pushWithRedirect` above\r\n        const toLocation = targetLocation;\r\n        toLocation.redirectedFrom = redirectedFrom;\r\n        let failure;\r\n        if (!force && isSameRouteLocation(stringifyQuery$1, from, targetLocation)) {\r\n            failure = createRouterError(16 /* NAVIGATION_DUPLICATED */, { to: toLocation, from });\r\n            // trigger scroll to allow scrolling to the same anchor\r\n            handleScroll(from, from, \r\n            // this is a push, the only way for it to be triggered from a\r\n            // history.listen is with a redirect, which makes it become a push\r\n            true, \r\n            // This cannot be the first navigation because the initial location\r\n            // cannot be manually navigated to\r\n            false);\r\n        }\r\n        return (failure ? Promise.resolve(failure) : navigate(toLocation, from))\r\n            .catch((error) => isNavigationFailure(error)\r\n            ? // navigation redirects still mark the router as ready\r\n                isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)\r\n                    ? error\r\n                    : markAsReady(error) // also returns the error\r\n            : // reject any unknown error\r\n                triggerError(error, toLocation, from))\r\n            .then((failure) => {\r\n            if (failure) {\r\n                if (isNavigationFailure(failure, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    if ((process.env.NODE_ENV !== 'production') &&\r\n                        // we are redirecting to the same location we were already at\r\n                        isSameRouteLocation(stringifyQuery$1, resolve(failure.to), toLocation) &&\r\n                        // and we have done it a couple of times\r\n                        redirectedFrom &&\r\n                        // @ts-expect-error: added only in dev\r\n                        (redirectedFrom._count = redirectedFrom._count\r\n                            ? // @ts-expect-error\r\n                                redirectedFrom._count + 1\r\n                            : 1) > 10) {\r\n                        warn(`Detected an infinite redirection in a navigation guard when going from \"${from.fullPath}\" to \"${toLocation.fullPath}\". Aborting to avoid a Stack Overflow. This will break in production if not fixed.`);\r\n                        return Promise.reject(new Error('Infinite redirect in navigation guard'));\r\n                    }\r\n                    return pushWithRedirect(\r\n                    // keep options\r\n                    assign(locationAsObject(failure.to), {\r\n                        state: data,\r\n                        force,\r\n                        replace,\r\n                    }), \r\n                    // preserve the original redirectedFrom if any\r\n                    redirectedFrom || toLocation);\r\n                }\r\n            }\r\n            else {\r\n                // if we fail we don't finalize the navigation\r\n                failure = finalizeNavigation(toLocation, from, true, replace, data);\r\n            }\r\n            triggerAfterEach(toLocation, from, failure);\r\n            return failure;\r\n        });\r\n    }\r\n    /**\r\n     * Helper to reject and skip all navigation guards if a new navigation happened\r\n     * @param to\r\n     * @param from\r\n     */\r\n    function checkCanceledNavigationAndReject(to, from) {\r\n        const error = checkCanceledNavigation(to, from);\r\n        return error ? Promise.reject(error) : Promise.resolve();\r\n    }\r\n    // TODO: refactor the whole before guards by internally using router.beforeEach\r\n    function navigate(to, from) {\r\n        let guards;\r\n        const [leavingRecords, updatingRecords, enteringRecords] = extractChangingRecords(to, from);\r\n        // all components here have been resolved once because we are leaving\r\n        guards = extractComponentsGuards(leavingRecords.reverse(), 'beforeRouteLeave', to, from);\r\n        // leavingRecords is already reversed\r\n        for (const record of leavingRecords) {\r\n            record.leaveGuards.forEach(guard => {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            });\r\n        }\r\n        const canceledNavigationCheck = checkCanceledNavigationAndReject.bind(null, to, from);\r\n        guards.push(canceledNavigationCheck);\r\n        // run the queue of per route beforeRouteLeave guards\r\n        return (runGuardQueue(guards)\r\n            .then(() => {\r\n            // check global guards beforeEach\r\n            guards = [];\r\n            for (const guard of beforeGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check in components beforeRouteUpdate\r\n            guards = extractComponentsGuards(updatingRecords, 'beforeRouteUpdate', to, from);\r\n            for (const record of updatingRecords) {\r\n                record.updateGuards.forEach(guard => {\r\n                    guards.push(guardToPromiseFn(guard, to, from));\r\n                });\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check the route beforeEnter\r\n            guards = [];\r\n            for (const record of to.matched) {\r\n                // do not trigger beforeEnter on reused views\r\n                if (record.beforeEnter && !from.matched.includes(record)) {\r\n                    if (Array.isArray(record.beforeEnter)) {\r\n                        for (const beforeEnter of record.beforeEnter)\r\n                            guards.push(guardToPromiseFn(beforeEnter, to, from));\r\n                    }\r\n                    else {\r\n                        guards.push(guardToPromiseFn(record.beforeEnter, to, from));\r\n                    }\r\n                }\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // NOTE: at this point to.matched is normalized and does not contain any () => Promise<Component>\r\n            // clear existing enterCallbacks, these are added by extractComponentsGuards\r\n            to.matched.forEach(record => (record.enterCallbacks = {}));\r\n            // check in-component beforeRouteEnter\r\n            guards = extractComponentsGuards(enteringRecords, 'beforeRouteEnter', to, from);\r\n            guards.push(canceledNavigationCheck);\r\n            // run the queue of per route beforeEnter guards\r\n            return runGuardQueue(guards);\r\n        })\r\n            .then(() => {\r\n            // check global guards beforeResolve\r\n            guards = [];\r\n            for (const guard of beforeResolveGuards.list()) {\r\n                guards.push(guardToPromiseFn(guard, to, from));\r\n            }\r\n            guards.push(canceledNavigationCheck);\r\n            return runGuardQueue(guards);\r\n        })\r\n            // catch any navigation canceled\r\n            .catch(err => isNavigationFailure(err, 8 /* NAVIGATION_CANCELLED */)\r\n            ? err\r\n            : Promise.reject(err)));\r\n    }\r\n    function triggerAfterEach(to, from, failure) {\r\n        // navigation is confirmed, call afterGuards\r\n        // TODO: wrap with error handlers\r\n        for (const guard of afterGuards.list())\r\n            guard(to, from, failure);\r\n    }\r\n    /**\r\n     * - Cleans up any navigation guards\r\n     * - Changes the url if necessary\r\n     * - Calls the scrollBehavior\r\n     */\r\n    function finalizeNavigation(toLocation, from, isPush, replace, data) {\r\n        // a more recent navigation took place\r\n        const error = checkCanceledNavigation(toLocation, from);\r\n        if (error)\r\n            return error;\r\n        // only consider as push if it's not the first navigation\r\n        const isFirstNavigation = from === START_LOCATION_NORMALIZED;\r\n        const state = !isBrowser ? {} : history.state;\r\n        // change URL only if the user did a push/replace and if it's not the initial navigation because\r\n        // it's just reflecting the url\r\n        if (isPush) {\r\n            // on the initial navigation, we want to reuse the scroll position from\r\n            // history state if it exists\r\n            if (replace || isFirstNavigation)\r\n                routerHistory.replace(toLocation.fullPath, assign({\r\n                    scroll: isFirstNavigation && state && state.scroll,\r\n                }, data));\r\n            else\r\n                routerHistory.push(toLocation.fullPath, data);\r\n        }\r\n        // accept current navigation\r\n        currentRoute.value = toLocation;\r\n        handleScroll(toLocation, from, isPush, isFirstNavigation);\r\n        markAsReady();\r\n    }\r\n    let removeHistoryListener;\r\n    // attach listener to history to trigger navigations\r\n    function setupListeners() {\r\n        removeHistoryListener = routerHistory.listen((to, _from, info) => {\r\n            // cannot be a redirect route because it was in history\r\n            const toLocation = resolve(to);\r\n            // due to dynamic routing, and to hash history with manual navigation\r\n            // (manually changing the url or calling history.hash = '#/somewhere'),\r\n            // there could be a redirect record in history\r\n            const shouldRedirect = handleRedirectRecord(toLocation);\r\n            if (shouldRedirect) {\r\n                pushWithRedirect(assign(shouldRedirect, { replace: true }), toLocation).catch(noop);\r\n                return;\r\n            }\r\n            pendingLocation = toLocation;\r\n            const from = currentRoute.value;\r\n            // TODO: should be moved to web history?\r\n            if (isBrowser) {\r\n                saveScrollPosition(getScrollKey(from.fullPath, info.delta), computeScrollPosition());\r\n            }\r\n            navigate(toLocation, from)\r\n                .catch((error) => {\r\n                if (isNavigationFailure(error, 4 /* NAVIGATION_ABORTED */ | 8 /* NAVIGATION_CANCELLED */)) {\r\n                    return error;\r\n                }\r\n                if (isNavigationFailure(error, 2 /* NAVIGATION_GUARD_REDIRECT */)) {\r\n                    // Here we could call if (info.delta) routerHistory.go(-info.delta,\r\n                    // false) but this is bug prone as we have no way to wait the\r\n                    // navigation to be finished before calling pushWithRedirect. Using\r\n                    // a setTimeout of 16ms seems to work but there is not guarantee for\r\n                    // it to work on every browser. So Instead we do not restore the\r\n                    // history entry and trigger a new navigation as requested by the\r\n                    // navigation guard.\r\n                    // the error is already handled by router.push we just want to avoid\r\n                    // logging the error\r\n                    pushWithRedirect(error.to, toLocation\r\n                    // avoid an uncaught rejection, let push call triggerError\r\n                    )\r\n                        .then(failure => {\r\n                        // manual change in hash history #916 ending up in the URL not\r\n                        // changing but it was changed by the manual url change, so we\r\n                        // need to manually change it ourselves\r\n                        if (isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ |\r\n                            16 /* NAVIGATION_DUPLICATED */) &&\r\n                            !info.delta &&\r\n                            info.type === NavigationType.pop) {\r\n                            routerHistory.go(-1, false);\r\n                        }\r\n                    })\r\n                        .catch(noop);\r\n                    // avoid the then branch\r\n                    return Promise.reject();\r\n                }\r\n                // do not restore history on unknown direction\r\n                if (info.delta)\r\n                    routerHistory.go(-info.delta, false);\r\n                // unrecognized error, transfer to the global handler\r\n                return triggerError(error, toLocation, from);\r\n            })\r\n                .then((failure) => {\r\n                failure =\r\n                    failure ||\r\n                        finalizeNavigation(\r\n                        // after navigation, all matched components are resolved\r\n                        toLocation, from, false);\r\n                // revert the navigation\r\n                if (failure) {\r\n                    if (info.delta) {\r\n                        routerHistory.go(-info.delta, false);\r\n                    }\r\n                    else if (info.type === NavigationType.pop &&\r\n                        isNavigationFailure(failure, 4 /* NAVIGATION_ABORTED */ | 16 /* NAVIGATION_DUPLICATED */)) {\r\n                        // manual change in hash history #916\r\n                        // it's like a push but lacks the information of the direction\r\n                        routerHistory.go(-1, false);\r\n                    }\r\n                }\r\n                triggerAfterEach(toLocation, from, failure);\r\n            })\r\n                .catch(noop);\r\n        });\r\n    }\r\n    // Initialization and Errors\r\n    let readyHandlers = useCallbacks();\r\n    let errorHandlers = useCallbacks();\r\n    let ready;\r\n    /**\r\n     * Trigger errorHandlers added via onError and throws the error as well\r\n     *\r\n     * @param error - error to throw\r\n     * @param to - location we were navigating to when the error happened\r\n     * @param from - location we were navigating from when the error happened\r\n     * @returns the error as a rejected promise\r\n     */\r\n    function triggerError(error, to, from) {\r\n        markAsReady(error);\r\n        const list = errorHandlers.list();\r\n        if (list.length) {\r\n            list.forEach(handler => handler(error, to, from));\r\n        }\r\n        else {\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                warn('uncaught error during route navigation:');\r\n            }\r\n            console.error(error);\r\n        }\r\n        return Promise.reject(error);\r\n    }\r\n    function isReady() {\r\n        if (ready && currentRoute.value !== START_LOCATION_NORMALIZED)\r\n            return Promise.resolve();\r\n        return new Promise((resolve, reject) => {\r\n            readyHandlers.add([resolve, reject]);\r\n        });\r\n    }\r\n    function markAsReady(err) {\r\n        if (!ready) {\r\n            // still not ready if an error happened\r\n            ready = !err;\r\n            setupListeners();\r\n            readyHandlers\r\n                .list()\r\n                .forEach(([resolve, reject]) => (err ? reject(err) : resolve()));\r\n            readyHandlers.reset();\r\n        }\r\n        return err;\r\n    }\r\n    // Scroll behavior\r\n    function handleScroll(to, from, isPush, isFirstNavigation) {\r\n        const { scrollBehavior } = options;\r\n        if (!isBrowser || !scrollBehavior)\r\n            return Promise.resolve();\r\n        const scrollPosition = (!isPush && getSavedScrollPosition(getScrollKey(to.fullPath, 0))) ||\r\n            ((isFirstNavigation || !isPush) &&\r\n                history.state &&\r\n                history.state.scroll) ||\r\n            null;\r\n        return nextTick()\r\n            .then(() => scrollBehavior(to, from, scrollPosition))\r\n            .then(position => position && scrollToPosition(position))\r\n            .catch(err => triggerError(err, to, from));\r\n    }\r\n    const go = (delta) => routerHistory.go(delta);\r\n    let started;\r\n    const installedApps = new Set();\r\n    const router = {\r\n        currentRoute,\r\n        addRoute,\r\n        removeRoute,\r\n        hasRoute,\r\n        getRoutes,\r\n        resolve,\r\n        options,\r\n        push,\r\n        replace,\r\n        go,\r\n        back: () => go(-1),\r\n        forward: () => go(1),\r\n        beforeEach: beforeGuards.add,\r\n        beforeResolve: beforeResolveGuards.add,\r\n        afterEach: afterGuards.add,\r\n        onError: errorHandlers.add,\r\n        isReady,\r\n        install(app) {\r\n            const router = this;\r\n            app.component('RouterLink', RouterLink);\r\n            app.component('RouterView', RouterView);\r\n            app.config.globalProperties.$router = router;\r\n            Object.defineProperty(app.config.globalProperties, '$route', {\r\n                enumerable: true,\r\n                get: () => unref(currentRoute),\r\n            });\r\n            // this initial navigation is only necessary on client, on server it doesn't\r\n            // make sense because it will create an extra unnecessary navigation and could\r\n            // lead to problems\r\n            if (isBrowser &&\r\n                // used for the initial navigation client side to avoid pushing\r\n                // multiple times when the router is used in multiple apps\r\n                !started &&\r\n                currentRoute.value === START_LOCATION_NORMALIZED) {\r\n                // see above\r\n                started = true;\r\n                push(routerHistory.location).catch(err => {\r\n                    if ((process.env.NODE_ENV !== 'production'))\r\n                        warn('Unexpected error when starting the router:', err);\r\n                });\r\n            }\r\n            const reactiveRoute = {};\r\n            for (const key in START_LOCATION_NORMALIZED) {\r\n                // @ts-expect-error: the key matches\r\n                reactiveRoute[key] = computed(() => currentRoute.value[key]);\r\n            }\r\n            app.provide(routerKey, router);\r\n            app.provide(routeLocationKey, reactive(reactiveRoute));\r\n            app.provide(routerViewLocationKey, currentRoute);\r\n            const unmountApp = app.unmount;\r\n            installedApps.add(app);\r\n            app.unmount = function () {\r\n                installedApps.delete(app);\r\n                // the router is not attached to an app anymore\r\n                if (installedApps.size < 1) {\r\n                    // invalidate the current navigation\r\n                    pendingLocation = START_LOCATION_NORMALIZED;\r\n                    removeHistoryListener && removeHistoryListener();\r\n                    currentRoute.value = START_LOCATION_NORMALIZED;\r\n                    started = false;\r\n                    ready = false;\r\n                }\r\n                unmountApp();\r\n            };\r\n            if (((process.env.NODE_ENV !== 'production') || __VUE_PROD_DEVTOOLS__) && isBrowser) {\r\n                addDevtools(app, router, matcher);\r\n            }\r\n        },\r\n    };\r\n    return router;\r\n}\r\nfunction runGuardQueue(guards) {\r\n    return guards.reduce((promise, guard) => promise.then(() => guard()), Promise.resolve());\r\n}\r\nfunction extractChangingRecords(to, from) {\r\n    const leavingRecords = [];\r\n    const updatingRecords = [];\r\n    const enteringRecords = [];\r\n    const len = Math.max(from.matched.length, to.matched.length);\r\n    for (let i = 0; i < len; i++) {\r\n        const recordFrom = from.matched[i];\r\n        if (recordFrom) {\r\n            if (to.matched.find(record => isSameRouteRecord(record, recordFrom)))\r\n                updatingRecords.push(recordFrom);\r\n            else\r\n                leavingRecords.push(recordFrom);\r\n        }\r\n        const recordTo = to.matched[i];\r\n        if (recordTo) {\r\n            // the type doesn't matter because we are comparing per reference\r\n            if (!from.matched.find(record => isSameRouteRecord(record, recordTo))) {\r\n                enteringRecords.push(recordTo);\r\n            }\r\n        }\r\n    }\r\n    return [leavingRecords, updatingRecords, enteringRecords];\r\n}\n\n/**\r\n * Returns the router instance. Equivalent to using `$router` inside\r\n * templates.\r\n */\r\nfunction useRouter() {\r\n    return inject(routerKey);\r\n}\r\n/**\r\n * Returns the current route location. Equivalent to using `$route` inside\r\n * templates.\r\n */\r\nfunction useRoute() {\r\n    return inject(routeLocationKey);\r\n}\n\nexport { NavigationFailureType, RouterLink, RouterView, START_LOCATION_NORMALIZED as START_LOCATION, createMemoryHistory, createRouter, createRouterMatcher, createWebHashHistory, createWebHistory, isNavigationFailure, matchedRouteKey, onBeforeRouteLeave, onBeforeRouteUpdate, parseQuery, routeLocationKey, routerKey, routerViewLocationKey, stringifyQuery, useLink, useRoute, useRouter, viewDepthKey };\n","(function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.VueTheMask=t():e.VueTheMask=t()})(this,function(){return function(e){function t(r){if(n[r])return n[r].exports;var a=n[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}var n={};return t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,\"a\",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p=\".\",t(t.s=10)}([function(e,t){e.exports={\"#\":{pattern:/\\d/},X:{pattern:/[0-9a-zA-Z]/},S:{pattern:/[a-zA-Z]/},A:{pattern:/[a-zA-Z]/,transform:function(e){return e.toLocaleUpperCase()}},a:{pattern:/[a-zA-Z]/,transform:function(e){return e.toLocaleLowerCase()}},\"!\":{escape:!0}}},function(e,t,n){\"use strict\";function r(e){var t=document.createEvent(\"Event\");return t.initEvent(e,!0,!0),t}var a=n(2),o=n(0),i=n.n(o);t.a=function(e,t){var o=t.value;if((Array.isArray(o)||\"string\"==typeof o)&&(o={mask:o,tokens:i.a}),\"INPUT\"!==e.tagName.toLocaleUpperCase()){var u=e.getElementsByTagName(\"input\");if(1!==u.length)throw new Error(\"v-mask directive requires 1 input, found \"+u.length);e=u[0]}e.oninput=function(t){if(t.isTrusted){var i=e.selectionEnd,u=e.value[i-1];for(e.value=n.i(a.a)(e.value,o.mask,!0,o.tokens);i<e.value.length&&e.value.charAt(i-1)!==u;)i++;e===document.activeElement&&(e.setSelectionRange(i,i),setTimeout(function(){e.setSelectionRange(i,i)},0)),e.dispatchEvent(r(\"input\"))}};var s=n.i(a.a)(e.value,o.mask,!0,o.tokens);s!==e.value&&(e.value=s,e.dispatchEvent(r(\"input\")))}},function(e,t,n){\"use strict\";var r=n(6),a=n(5);t.a=function(e,t){var o=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=arguments[3];return Array.isArray(t)?n.i(a.a)(r.a,t,i)(e,t,o,i):n.i(r.a)(e,t,o,i)}},function(e,t,n){\"use strict\";function r(e){e.component(s.a.name,s.a),e.directive(\"mask\",i.a)}Object.defineProperty(t,\"__esModule\",{value:!0});var a=n(0),o=n.n(a),i=n(1),u=n(7),s=n.n(u);n.d(t,\"TheMask\",function(){return s.a}),n.d(t,\"mask\",function(){return i.a}),n.d(t,\"tokens\",function(){return o.a}),n.d(t,\"version\",function(){return c});var c=\"0.11.1\";t.default=r,\"undefined\"!=typeof window&&window.Vue&&window.Vue.use(r)},function(e,t,n){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var r=n(1),a=n(0),o=n.n(a),i=n(2);t.default={name:\"TheMask\",props:{value:[String,Number],mask:{type:[String,Array],required:!0},masked:{type:Boolean,default:!1},tokens:{type:Object,default:function(){return o.a}}},directives:{mask:r.a},data:function(){return{lastValue:null,display:this.value}},watch:{value:function(e){e!==this.lastValue&&(this.display=e)},masked:function(){this.refresh(this.display)}},computed:{config:function(){return{mask:this.mask,tokens:this.tokens,masked:this.masked}}},methods:{onInput:function(e){e.isTrusted||this.refresh(e.target.value)},refresh:function(e){this.display=e;var e=n.i(i.a)(e,this.mask,this.masked,this.tokens);e!==this.lastValue&&(this.lastValue=e,this.$emit(\"input\",e))}}}},function(e,t,n){\"use strict\";function r(e,t,n){return t=t.sort(function(e,t){return e.length-t.length}),function(r,a){for(var o=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=0;i<t.length;){var u=t[i];i++;var s=t[i];if(!(s&&e(r,s,!0,n).length>u.length))return e(r,u,o,n)}return\"\"}}t.a=r},function(e,t,n){\"use strict\";function r(e,t){var n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],r=arguments[3];e=e||\"\",t=t||\"\";for(var a=0,o=0,i=\"\";a<t.length&&o<e.length;){var u=t[a],s=r[u],c=e[o];s&&!s.escape?(s.pattern.test(c)&&(i+=s.transform?s.transform(c):c,a++),o++):(s&&s.escape&&(a++,u=t[a]),n&&(i+=u),c===u&&o++,a++)}for(var f=\"\";a<t.length&&n;){var u=t[a];if(r[u]){f=\"\";break}f+=u,a++}return i+f}t.a=r},function(e,t,n){var r=n(8)(n(4),n(9),null,null);e.exports=r.exports},function(e,t){e.exports=function(e,t,n,r){var a,o=e=e||{},i=typeof e.default;\"object\"!==i&&\"function\"!==i||(a=e,o=e.default);var u=\"function\"==typeof o?o.options:o;if(t&&(u.render=t.render,u.staticRenderFns=t.staticRenderFns),n&&(u._scopeId=n),r){var s=u.computed||(u.computed={});Object.keys(r).forEach(function(e){var t=r[e];s[e]=function(){return t}})}return{esModule:a,exports:o,options:u}}},function(e,t){e.exports={render:function(){var e=this,t=e.$createElement;return(e._self._c||t)(\"input\",{directives:[{name:\"mask\",rawName:\"v-mask\",value:e.config,expression:\"config\"}],attrs:{type:\"text\"},domProps:{value:e.display},on:{input:e.onInput}})},staticRenderFns:[]}},function(e,t,n){e.exports=n(3)}])});"],"names":["activeEffectScope","EffectScope","constructor","detached","this","_active","effects","cleanups","parent","index","scopes","push","active","run","fn","currentEffectScope","process","on","off","stop","fromParent","i","l","length","last","pop","undefined","recordEffectScope","effect","scope","getCurrentScope","createDep","dep","Set","w","n","wasTracked","trackOpBit","newTracked","initDepMarkers","deps","finalizeDepMarkers","ptr","delete","targetMap","WeakMap","effectTrackDepth","maxMarkerBits","activeEffect","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","ReactiveEffect","scheduler","lastShouldTrack","shouldTrack","cleanupEffect","deferStop","onStop","trackStack","pauseTracking","resetTracking","track","target","type","key","depsMap","get","set","Map","eventInfo","trackEffects","debuggerEventExtraInfo","has","add","trigger","newValue","oldValue","oldTarget","values","isArray","newLength","Number","forEach","isIntegerKey","isMap","triggerEffects","computed","triggerEffect","allowRecurse","isNonTrackableKeys","makeMap","builtInSymbols","Object","getOwnPropertyNames","filter","map","isSymbol","get$1","createGetter","shallowGet","readonlyGet","arrayInstrumentations","createArrayInstrumentations","instrumentations","args","arr","toRaw","res","apply","hasOwnProperty","obj","isReadonly","shallow","receiver","shallowReadonlyMap","readonlyMap","shallowReactiveMap","reactiveMap","targetIsArray","hasOwn","Reflect","isRef","value","isObject","readonly","reactive","set$1","createSetter","shallowSet","isShallow","hadKey","result","hasChanged","deleteProperty","has$1","ownKeys","mutableHandlers","readonlyHandlers","shallowReactiveHandlers","extend","toShallow","getProto","v","getPrototypeOf","rawTarget","rawKey","wrap","toReadonly","toReactive","call","size","proto","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","method","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","createInstrumentations","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","shallowReadonlyInstrumentations","iteratorMethods","createInstrumentationGetter","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","targetTypeMap","rawType","getTargetType","isExtensible","toRawType","createReactiveObject","shallowReactive","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","isProxy","raw","markRaw","def","trackRefValue","ref","triggerRefValue","newVal","r","__v_isRef","createRef","shallowRef","rawValue","RefImpl","__v_isShallow","_rawValue","_value","useDirectValue","unref","shallowUnwrapHandlers","proxyRefs","objectWithRefs","_a$1","ComputedRefImpl","getter","_setter","isSSR","_dirty","_cacheable","self","getterOrOptions","debugOptions","setter","onlyGetter","isFunction","NOOP","cRef","svgNS","doc","document","templateContainer","createElement","nodeOps","insert","child","anchor","insertBefore","remove","parentNode","removeChild","tag","isSVG","is","props","el","createElementNS","multiple","setAttribute","createText","text","createTextNode","createComment","setText","node","nodeValue","setElementText","textContent","nextSibling","querySelector","selector","setScopeId","id","insertStaticContent","content","start","end","before","previousSibling","lastChild","cloneNode","innerHTML","template","wrapper","firstChild","appendChild","patchClass","transitionClasses","_vtc","join","removeAttribute","className","patchStyle","prev","style","isCssString","isString","setStyle","currentDisplay","display","cssText","importantRE","name","val","startsWith","setProperty","prefixed","autoPrefix","test","hyphenate","replace","prefixes","prefixCache","rawName","cached","camelize","capitalize","xlinkNS","patchAttr","instance","removeAttributeNS","slice","setAttributeNS","isBoolean","isSpecialBooleanAttr","includeBooleanAttr","patchDOMProp","prevChildren","parentComponent","parentSuspense","unmountChildren","tagName","includes","needRemove","e","addEventListener","event","handler","options","removeEventListener","patchEvent","prevValue","nextValue","invokers","_vei","existingInvoker","parseName","invoker","createInvoker","optionsModifierRE","m","match","toLowerCase","cachedNow","p","Promise","resolve","getNow","then","Date","now","initialValue","_vts","attached","callWithAsyncErrorHandling","patchStopImmediatePropagation","originalStop","stopImmediatePropagation","_stopped","nativeOnRE","patchProp","isOn","isModelListener","shouldSetAsProp","_trueValue","_falseValue","HTMLElement","TRANSITION","ANIMATION","Transition","slots","h","BaseTransition","resolveTransitionProps","displayName","DOMTransitionPropsValidators","String","css","Boolean","default","duration","enterFromClass","enterActiveClass","enterToClass","appearFromClass","appearActiveClass","appearToClass","leaveFromClass","leaveActiveClass","leaveToClass","TransitionPropsValidators","callHook","hook","hasExplicitCallback","some","rawProps","baseProps","durations","normalizeDuration","enterDuration","leaveDuration","onBeforeEnter","onEnter","onEnterCancelled","onLeave","onLeaveCancelled","onBeforeAppear","onAppear","onAppearCancelled","finishEnter","isAppear","removeTransitionClass","finishLeave","_isLeaving","makeEnterHook","nextFrame","addTransitionClass","whenTransitionEnds","forceReflow","NumberOf","enter","leave","toNumber","cls","split","c","classList","cb","requestAnimationFrame","endId","expectedType","explicitTimeout","_endId","resolveIfNotStale","setTimeout","timeout","propCount","getTransitionInfo","endEvent","ended","onEnd","styles","window","getComputedStyle","getStyleProperties","transitionDelays","transitionDurations","transitionTimeout","getTimeout","animationDelays","animationDurations","animationTimeout","Math","max","hasTransform","toString","delays","concat","d","toMs","s","body","offsetHeight","positionMap","newPositionMap","TransitionGroupImpl","moveClass","setup","getCurrentInstance","state","useTransitionState","children","onUpdated","hasCSSTransform","vnode","callPendingCbs","recordPosition","movedChildren","applyTranslation","transform","webkitTransform","transitionDuration","_moveCb","propertyName","cssTransitionProps","Fragment","getTransitionRawChildren","setTransitionHooks","resolveTransitionHooks","getBoundingClientRect","createVNode","_enterCb","oldPos","newPos","dx","left","dy","top","root","clone","container","nodeType","getModelAssigner","invokeArrayFns","onCompositionStart","composing","onCompositionEnd","dispatchEvent","Event","vModelText","created","modifiers","lazy","trim","number","_assign","castToNumber","domValue","looseToNumber","mounted","beforeUpdate","activeElement","vModelCheckbox","deep","_","modelValue","_modelValue","elementValue","getValue","checked","assign","looseIndexOf","found","filtered","splice","isSet","cloned","getCheckboxValue","setChecked","binding","looseEqual","vModelSelect","isSetModel","selectedVal","Array","prototype","o","selected","setSelected","_binding","updated","isMultiple","option","optionValue","selectedIndex","systemModifiers","modifierGuards","stopPropagation","prevent","preventDefault","currentTarget","ctrl","ctrlKey","shift","shiftKey","alt","altKey","meta","metaKey","button","middle","right","exact","withModifiers","guard","vShow","beforeMount","transition","_vod","beforeEnter","setDisplay","beforeUnmount","rendererOptions","renderer","ensureRenderer","createRenderer","createApp","app","mount","containerOrSelector","normalizeContainer","component","_component","render","SVGElement","Element","str","expectsLowerCase","create","list","GLOBALS_WHITE_LISTED","isGloballyWhitelisted","normalizeStyle","item","normalized","parseStringStyle","listDelimiterRE","propertyDelimiterRE","styleCommentRE","ret","tmp","normalizeClass","specialBooleanAttrs","looseCompareArrays","a","b","equal","aValidType","isDate","bValidType","getTime","aKeysCount","keys","bKeysCount","aHasKey","bHasKey","findIndex","toDisplayString","objectToString","JSON","stringify","replacer","_key","entries","reduce","isPlainObject","EMPTY_OBJ","EMPTY_ARR","NO","onRE","indexOf","toTypeString","isRegExp","isPromise","catch","parseInt","isReservedProp","cacheStringFunction","cache","hit","camelizeRE","toUpperCase","hyphenateRE","charAt","toHandlerKey","fns","arg","defineProperty","configurable","enumerable","parseFloat","isNaN","NaN","_globalThis","getGlobalThis","globalThis","global","exports","sfc","__vccOpts","hasSymbol","toStringTag","PolySymbol","matchedRouteKey","viewDepthKey","routerKey","routeLocationKey","routerViewLocationKey","isBrowser","isESModule","__esModule","applyToParams","params","newParams","noop","TRAILING_SLASH_RE","removeTrailingSlash","path","parseURL","parseQuery","location","currentLocation","query","searchString","hash","searchPos","hashPos","resolveRelativePath","fullPath","stringifyURL","stringifyQuery","stripBase","pathname","base","isSameRouteLocation","aLastIndex","matched","bLastIndex","isSameRouteRecord","isSameRouteLocationParams","aliasOf","isSameRouteLocationParamsValue","isEquivalentArray","every","to","from","fromSegments","toSegments","toPosition","segment","position","NavigationType","NavigationDirection","normalizeBase","baseEl","getAttribute","BEFORE_HASH_RE","createHref","getElementPosition","offset","docRect","documentElement","elRect","behavior","computeScrollPosition","pageXOffset","pageYOffset","scrollToPosition","scrollToOptions","positionEl","isIdSelector","getElementById","scrollTo","getScrollKey","delta","history","scrollPositions","saveScrollPosition","scrollPosition","getSavedScrollPosition","scroll","createBaseLocation","protocol","host","createCurrentLocation","search","slicePos","pathFromHash","useHistoryListeners","historyState","listeners","teardowns","pauseState","popStateHandler","fromState","listener","direction","forward","back","unknown","pauseListeners","listen","teardown","beforeUnloadListener","replaceState","destroy","buildState","current","replaced","computeScroll","useHistoryStateNavigation","changeLocation","hashIndex","url","err","console","error","data","currentState","createWebHistory","historyNavigation","historyListeners","go","triggerListeners","routerHistory","bind","isRouteLocation","route","isRouteName","START_LOCATION_NORMALIZED","redirectedFrom","NavigationFailureSymbol","NavigationFailureType","createRouterError","Error","isNavigationFailure","BASE_PARAM_PATTERN","BASE_PATH_PARSER_OPTIONS","sensitive","strict","REGEX_CHARS_RE","tokensToParser","segments","extraOptions","score","pattern","segmentScores","tokenIndex","token","subSegmentScore","repeatable","optional","regexp","re","RegExp","message","subPattern","parse","avoidDuplicatedSlash","endsWith","param","compareScoreArray","diff","comparePathParserScore","aScore","bScore","comp","ROOT_TOKEN","VALID_PARAM_RE","tokenizePath","crash","buffer","previousState","tokens","finalizeSegment","char","customRe","consumeBuffer","addCharToBuffer","createRouteRecordMatcher","record","parser","matcher","alias","createRouterMatcher","routes","globalOptions","matchers","matcherMap","getRecordMatcher","addRoute","originalRecord","isRootAdd","mainNormalizedRecord","normalizeRouteRecord","mergeOptions","normalizedRecords","aliases","components","originalMatcher","normalizedRecord","parentPath","connectingSlash","isAliasRecord","removeRoute","insertMatcher","matcherRef","getRoutes","isRecordChildOf","paramsFromLocation","k","find","parentMatcher","unshift","mergeMetaFields","redirect","normalizeRecordProps","instances","leaveGuards","updateGuards","enterCallbacks","propsObject","defaults","partialOptions","HASH_RE","AMPERSAND_RE","SLASH_RE","EQUAL_RE","IM_RE","PLUS_RE","ENC_BRACKET_OPEN_RE","ENC_BRACKET_CLOSE_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_CURLY_OPEN_RE","ENC_PIPE_RE","ENC_CURLY_CLOSE_RE","ENC_SPACE_RE","commonEncode","encodeURI","encodeHash","encodeQueryValue","encodeQueryKey","encodePath","encodeParam","decode","decodeURIComponent","hasLeadingIM","searchParams","searchParam","eqPos","currentValue","normalizeQuery","normalizedQuery","useCallbacks","handlers","reset","guardToPromiseFn","enterCallbackArray","reject","valid","guardReturn","guardCall","extractComponentsGuards","guardType","guards","rawComponent","isRouteComponent","componentPromise","resolved","resolvedComponent","useLink","router","inject","currentRoute","activeRecordIndex","routeMatched","currentMatched","parentRecordPath","getOriginalPath","isActive","includesParams","isExactActive","navigate","guardEvent","href","RouterLinkImpl","defineComponent","required","activeClass","exactActiveClass","custom","ariaCurrentValue","link","elClass","getLinkClass","linkActiveClass","linkExactActiveClass","onClick","class","RouterLink","defaultPrevented","outer","inner","innerValue","outerValue","propClass","globalClass","defaultClass","RouterViewImpl","inheritAttrs","attrs","injectedRoute","routeToDisplay","depth","matchedRouteRef","provide","viewRef","watch","oldInstance","oldName","flush","matchedRoute","ViewComponent","currentName","normalizeSlot","Component","routePropsOption","routeProps","onVnodeUnmounted","isUnmounted","slot","slotContent","RouterView","createRouter","parseQuery$1","stringifyQuery$1","beforeGuards","beforeResolveGuards","afterGuards","pendingLocation","scrollBehavior","scrollRestoration","normalizeParams","paramValue","encodeParams","decodeParams","parentOrRoute","recordMatcher","routeMatcher","hasRoute","rawLocation","locationNormalized","matcherLocation","targetParams","locationAsObject","checkCanceledNavigation","pushWithRedirect","handleRedirectRecord","lastMatched","newTargetLocation","targetLocation","force","shouldRedirect","toLocation","failure","handleScroll","markAsReady","triggerError","finalizeNavigation","triggerAfterEach","checkCanceledNavigationAndReject","leavingRecords","updatingRecords","enteringRecords","extractChangingRecords","reverse","canceledNavigationCheck","runGuardQueue","isPush","isFirstNavigation","removeHistoryListener","setupListeners","_from","info","ready","readyHandlers","errorHandlers","isReady","nextTick","started","installedApps","beforeEach","beforeResolve","afterEach","onError","install","config","globalProperties","$router","warn","reactiveRoute","unmountApp","unmount","promise","len","recordFrom","recordTo","t","module","X","S","A","toLocaleUpperCase","toLocaleLowerCase","escape","createEvent","initEvent","mask","u","getElementsByTagName","oninput","isTrusted","selectionEnd","setSelectionRange","arguments","directive","Vue","use","masked","directives","lastValue","refresh","methods","onInput","$emit","sort","f","staticRenderFns","_scopeId","esModule","$createElement","_self","_c","expression","domProps","input"],"sourceRoot":""}